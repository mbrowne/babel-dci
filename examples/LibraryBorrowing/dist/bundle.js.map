{
  "version": 3,
  "sources": [
    "../node_modules/browser-pack/_prelude.js",
    "../node_modules/process/browser.js",
    "../node_modules/ractive/ractive.js",
    "../src/BorrowLibraryItems.js",
    "../src/Command.js",
    "../src/Controller.js",
    "../src/Deferred.js",
    "../src/ObjectStore.js",
    "../src/app.js",
    "../src/data-objects/Book.js",
    "../src/data-objects/DVD.js",
    "../src/data-objects/ItemRecord.js",
    "../src/data-objects/Loan.js",
    "../src/data-objects/User.js",
    "../src/index.js",
    "../src/loadDemoData.js",
    "../../../../../../node_modules/babel-polyfill/lib/index.js",
    "../../../../../../node_modules/babel-regenerator-runtime/runtime.js",
    "../../../../../../node_modules/core-js/modules/$.a-function.js",
    "../../../../../../node_modules/core-js/modules/$.add-to-unscopables.js",
    "../../../../../../node_modules/core-js/modules/$.an-object.js",
    "../../../../../../node_modules/core-js/modules/$.array-copy-within.js",
    "../../../../../../node_modules/core-js/modules/$.array-fill.js",
    "../../../../../../node_modules/core-js/modules/$.array-includes.js",
    "../../../../../../node_modules/core-js/modules/$.array-methods.js",
    "../../../../../../node_modules/core-js/modules/$.array-species-create.js",
    "../../../../../../node_modules/core-js/modules/$.classof.js",
    "../../../../../../node_modules/core-js/modules/$.cof.js",
    "../../../../../../node_modules/core-js/modules/$.collection-strong.js",
    "../../../../../../node_modules/core-js/modules/$.collection-to-json.js",
    "../../../../../../node_modules/core-js/modules/$.collection-weak.js",
    "../../../../../../node_modules/core-js/modules/$.collection.js",
    "../../../../../../node_modules/core-js/modules/$.core.js",
    "../../../../../../node_modules/core-js/modules/$.ctx.js",
    "../../../../../../node_modules/core-js/modules/$.defined.js",
    "../../../../../../node_modules/core-js/modules/$.descriptors.js",
    "../../../../../../node_modules/core-js/modules/$.dom-create.js",
    "../../../../../../node_modules/core-js/modules/$.enum-keys.js",
    "../../../../../../node_modules/core-js/modules/$.export.js",
    "../../../../../../node_modules/core-js/modules/$.fails-is-regexp.js",
    "../../../../../../node_modules/core-js/modules/$.fails.js",
    "../../../../../../node_modules/core-js/modules/$.fix-re-wks.js",
    "../../../../../../node_modules/core-js/modules/$.flags.js",
    "../../../../../../node_modules/core-js/modules/$.for-of.js",
    "../../../../../../node_modules/core-js/modules/$.get-names.js",
    "../../../../../../node_modules/core-js/modules/$.global.js",
    "../../../../../../node_modules/core-js/modules/$.has.js",
    "../../../../../../node_modules/core-js/modules/$.hide.js",
    "../../../../../../node_modules/core-js/modules/$.html.js",
    "../../../../../../node_modules/core-js/modules/$.invoke.js",
    "../../../../../../node_modules/core-js/modules/$.iobject.js",
    "../../../../../../node_modules/core-js/modules/$.is-array-iter.js",
    "../../../../../../node_modules/core-js/modules/$.is-array.js",
    "../../../../../../node_modules/core-js/modules/$.is-integer.js",
    "../../../../../../node_modules/core-js/modules/$.is-object.js",
    "../../../../../../node_modules/core-js/modules/$.is-regexp.js",
    "../../../../../../node_modules/core-js/modules/$.iter-call.js",
    "../../../../../../node_modules/core-js/modules/$.iter-create.js",
    "../../../../../../node_modules/core-js/modules/$.iter-define.js",
    "../../../../../../node_modules/core-js/modules/$.iter-detect.js",
    "../../../../../../node_modules/core-js/modules/$.iter-step.js",
    "../../../../../../node_modules/core-js/modules/$.iterators.js",
    "../../../../../../node_modules/core-js/modules/$.js",
    "../../../../../../node_modules/core-js/modules/$.keyof.js",
    "../../../../../../node_modules/core-js/modules/$.library.js",
    "../../../../../../node_modules/core-js/modules/$.math-expm1.js",
    "../../../../../../node_modules/core-js/modules/$.math-log1p.js",
    "../../../../../../node_modules/core-js/modules/$.math-sign.js",
    "../../../../../../node_modules/core-js/modules/$.microtask.js",
    "../../../../../../node_modules/core-js/modules/$.object-assign.js",
    "../../../../../../node_modules/core-js/modules/$.object-sap.js",
    "../../../../../../node_modules/core-js/modules/$.object-to-array.js",
    "../../../../../../node_modules/core-js/modules/$.own-keys.js",
    "../../../../../../node_modules/core-js/modules/$.partial.js",
    "../../../../../../node_modules/core-js/modules/$.path.js",
    "../../../../../../node_modules/core-js/modules/$.property-desc.js",
    "../../../../../../node_modules/core-js/modules/$.redefine-all.js",
    "../../../../../../node_modules/core-js/modules/$.redefine.js",
    "../../../../../../node_modules/core-js/modules/$.replacer.js",
    "../../../../../../node_modules/core-js/modules/$.same-value.js",
    "../../../../../../node_modules/core-js/modules/$.set-proto.js",
    "../../../../../../node_modules/core-js/modules/$.set-species.js",
    "../../../../../../node_modules/core-js/modules/$.set-to-string-tag.js",
    "../../../../../../node_modules/core-js/modules/$.shared.js",
    "../../../../../../node_modules/core-js/modules/$.species-constructor.js",
    "../../../../../../node_modules/core-js/modules/$.strict-new.js",
    "../../../../../../node_modules/core-js/modules/$.string-at.js",
    "../../../../../../node_modules/core-js/modules/$.string-context.js",
    "../../../../../../node_modules/core-js/modules/$.string-pad.js",
    "../../../../../../node_modules/core-js/modules/$.string-repeat.js",
    "../../../../../../node_modules/core-js/modules/$.string-trim.js",
    "../../../../../../node_modules/core-js/modules/$.task.js",
    "../../../../../../node_modules/core-js/modules/$.to-index.js",
    "../../../../../../node_modules/core-js/modules/$.to-integer.js",
    "../../../../../../node_modules/core-js/modules/$.to-iobject.js",
    "../../../../../../node_modules/core-js/modules/$.to-length.js",
    "../../../../../../node_modules/core-js/modules/$.to-object.js",
    "../../../../../../node_modules/core-js/modules/$.to-primitive.js",
    "../../../../../../node_modules/core-js/modules/$.uid.js",
    "../../../../../../node_modules/core-js/modules/$.wks.js",
    "../../../../../../node_modules/core-js/modules/core.get-iterator-method.js",
    "../../../../../../node_modules/core-js/modules/es5.js",
    "../../../../../../node_modules/core-js/modules/es6.array.copy-within.js",
    "../../../../../../node_modules/core-js/modules/es6.array.fill.js",
    "../../../../../../node_modules/core-js/modules/es6.array.find-index.js",
    "../../../../../../node_modules/core-js/modules/es6.array.find.js",
    "../../../../../../node_modules/core-js/modules/es6.array.from.js",
    "../../../../../../node_modules/core-js/modules/es6.array.iterator.js",
    "../../../../../../node_modules/core-js/modules/es6.array.of.js",
    "../../../../../../node_modules/core-js/modules/es6.array.species.js",
    "../../../../../../node_modules/core-js/modules/es6.function.has-instance.js",
    "../../../../../../node_modules/core-js/modules/es6.function.name.js",
    "../../../../../../node_modules/core-js/modules/es6.map.js",
    "../../../../../../node_modules/core-js/modules/es6.math.acosh.js",
    "../../../../../../node_modules/core-js/modules/es6.math.asinh.js",
    "../../../../../../node_modules/core-js/modules/es6.math.atanh.js",
    "../../../../../../node_modules/core-js/modules/es6.math.cbrt.js",
    "../../../../../../node_modules/core-js/modules/es6.math.clz32.js",
    "../../../../../../node_modules/core-js/modules/es6.math.cosh.js",
    "../../../../../../node_modules/core-js/modules/es6.math.expm1.js",
    "../../../../../../node_modules/core-js/modules/es6.math.fround.js",
    "../../../../../../node_modules/core-js/modules/es6.math.hypot.js",
    "../../../../../../node_modules/core-js/modules/es6.math.imul.js",
    "../../../../../../node_modules/core-js/modules/es6.math.log10.js",
    "../../../../../../node_modules/core-js/modules/es6.math.log1p.js",
    "../../../../../../node_modules/core-js/modules/es6.math.log2.js",
    "../../../../../../node_modules/core-js/modules/es6.math.sign.js",
    "../../../../../../node_modules/core-js/modules/es6.math.sinh.js",
    "../../../../../../node_modules/core-js/modules/es6.math.tanh.js",
    "../../../../../../node_modules/core-js/modules/es6.math.trunc.js",
    "../../../../../../node_modules/core-js/modules/es6.number.constructor.js",
    "../../../../../../node_modules/core-js/modules/es6.number.epsilon.js",
    "../../../../../../node_modules/core-js/modules/es6.number.is-finite.js",
    "../../../../../../node_modules/core-js/modules/es6.number.is-integer.js",
    "../../../../../../node_modules/core-js/modules/es6.number.is-nan.js",
    "../../../../../../node_modules/core-js/modules/es6.number.is-safe-integer.js",
    "../../../../../../node_modules/core-js/modules/es6.number.max-safe-integer.js",
    "../../../../../../node_modules/core-js/modules/es6.number.min-safe-integer.js",
    "../../../../../../node_modules/core-js/modules/es6.number.parse-float.js",
    "../../../../../../node_modules/core-js/modules/es6.number.parse-int.js",
    "../../../../../../node_modules/core-js/modules/es6.object.assign.js",
    "../../../../../../node_modules/core-js/modules/es6.object.freeze.js",
    "../../../../../../node_modules/core-js/modules/es6.object.get-own-property-descriptor.js",
    "../../../../../../node_modules/core-js/modules/es6.object.get-own-property-names.js",
    "../../../../../../node_modules/core-js/modules/es6.object.get-prototype-of.js",
    "../../../../../../node_modules/core-js/modules/es6.object.is-extensible.js",
    "../../../../../../node_modules/core-js/modules/es6.object.is-frozen.js",
    "../../../../../../node_modules/core-js/modules/es6.object.is-sealed.js",
    "../../../../../../node_modules/core-js/modules/es6.object.is.js",
    "../../../../../../node_modules/core-js/modules/es6.object.keys.js",
    "../../../../../../node_modules/core-js/modules/es6.object.prevent-extensions.js",
    "../../../../../../node_modules/core-js/modules/es6.object.seal.js",
    "../../../../../../node_modules/core-js/modules/es6.object.set-prototype-of.js",
    "../../../../../../node_modules/core-js/modules/es6.object.to-string.js",
    "../../../../../../node_modules/core-js/modules/es6.promise.js",
    "../../../../../../node_modules/core-js/modules/es6.reflect.apply.js",
    "../../../../../../node_modules/core-js/modules/es6.reflect.construct.js",
    "../../../../../../node_modules/core-js/modules/es6.reflect.define-property.js",
    "../../../../../../node_modules/core-js/modules/es6.reflect.delete-property.js",
    "../../../../../../node_modules/core-js/modules/es6.reflect.enumerate.js",
    "../../../../../../node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js",
    "../../../../../../node_modules/core-js/modules/es6.reflect.get-prototype-of.js",
    "../../../../../../node_modules/core-js/modules/es6.reflect.get.js",
    "../../../../../../node_modules/core-js/modules/es6.reflect.has.js",
    "../../../../../../node_modules/core-js/modules/es6.reflect.is-extensible.js",
    "../../../../../../node_modules/core-js/modules/es6.reflect.own-keys.js",
    "../../../../../../node_modules/core-js/modules/es6.reflect.prevent-extensions.js",
    "../../../../../../node_modules/core-js/modules/es6.reflect.set-prototype-of.js",
    "../../../../../../node_modules/core-js/modules/es6.reflect.set.js",
    "../../../../../../node_modules/core-js/modules/es6.regexp.constructor.js",
    "../../../../../../node_modules/core-js/modules/es6.regexp.flags.js",
    "../../../../../../node_modules/core-js/modules/es6.regexp.match.js",
    "../../../../../../node_modules/core-js/modules/es6.regexp.replace.js",
    "../../../../../../node_modules/core-js/modules/es6.regexp.search.js",
    "../../../../../../node_modules/core-js/modules/es6.regexp.split.js",
    "../../../../../../node_modules/core-js/modules/es6.set.js",
    "../../../../../../node_modules/core-js/modules/es6.string.code-point-at.js",
    "../../../../../../node_modules/core-js/modules/es6.string.ends-with.js",
    "../../../../../../node_modules/core-js/modules/es6.string.from-code-point.js",
    "../../../../../../node_modules/core-js/modules/es6.string.includes.js",
    "../../../../../../node_modules/core-js/modules/es6.string.iterator.js",
    "../../../../../../node_modules/core-js/modules/es6.string.raw.js",
    "../../../../../../node_modules/core-js/modules/es6.string.repeat.js",
    "../../../../../../node_modules/core-js/modules/es6.string.starts-with.js",
    "../../../../../../node_modules/core-js/modules/es6.string.trim.js",
    "../../../../../../node_modules/core-js/modules/es6.symbol.js",
    "../../../../../../node_modules/core-js/modules/es6.weak-map.js",
    "../../../../../../node_modules/core-js/modules/es6.weak-set.js",
    "../../../../../../node_modules/core-js/modules/es7.array.includes.js",
    "../../../../../../node_modules/core-js/modules/es7.map.to-json.js",
    "../../../../../../node_modules/core-js/modules/es7.object.entries.js",
    "../../../../../../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js",
    "../../../../../../node_modules/core-js/modules/es7.object.values.js",
    "../../../../../../node_modules/core-js/modules/es7.regexp.escape.js",
    "../../../../../../node_modules/core-js/modules/es7.set.to-json.js",
    "../../../../../../node_modules/core-js/modules/es7.string.at.js",
    "../../../../../../node_modules/core-js/modules/es7.string.pad-left.js",
    "../../../../../../node_modules/core-js/modules/es7.string.pad-right.js",
    "../../../../../../node_modules/core-js/modules/es7.string.trim-left.js",
    "../../../../../../node_modules/core-js/modules/es7.string.trim-right.js",
    "../../../../../../node_modules/core-js/modules/js.array.statics.js",
    "../../../../../../node_modules/core-js/modules/web.dom.iterable.js",
    "../../../../../../node_modules/core-js/modules/web.immediate.js",
    "../../../../../../node_modules/core-js/modules/web.timers.js",
    "../../../../../../node_modules/core-js/shim.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;kBC7tgBwB,kBAAkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAP1C,IAAI,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC;;;;;;;AAAC,AAOrB,SAAS,kBAAkB,CAAC,QAAc,EAAE,WAAmB,EAAE,UAAU,EAAE;iBAd3F,IAAI,KAAG,SAAS,IAAK,OAAO,MAAM,KAAK,WAAW,IAAI,IAAI,KAAK,MAAM,AAAC,IAAK,OAAO,MAAM,KAAK,WAAW,IAAI,IAAI,KAAK,MAAM,AAAC,GAAG,EAAE,GAAE,IAAI;;sBAwBlI;UAAQ,WA+BR;QAAM,WA+BN;UAAQ,WAUR;SAAO;;;;;UAvEX;kBAAc,0BAAC,MAAc;qBAC5B;;SAAI,QAAoB,GAAG,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,AACpD;SAAI,KAAK,YAAA,CAAC,AAEV;;SAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,EAAE,AAC5B;WAAK,GAAG,mEAAmE;;AAAC,MAE5E,MACI,IAAI,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,AACxC;YAAK,GAAG,YAAY,GAAG,QAAQ,CAAC,KAAK,GAAG,wBAAwB,CAAC;OACjE,AAED;;SAAI,KAAK,EAAE,AACV;YAAM,CAAC,eAAe,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC,AACxC;YAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;MACxB,MACI,AACJ;UAAI,IAAI,GAAG,mBAAS,QAAQ,EAAE,QAAQ,CAAC,CAAC,AACxC;cAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;;AAAC,AAEpB,mBAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC,AACzC;YAAM,CAAC,eAAe,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;MACvC,AACD;yBAAO,cAAc,MAArB,MAAM,EAAkB;;;;;UAQnB;kBAAc;;gBAEf,GAAG,EAOD,gBAAgB;;;;;sBARtB;;cAAI,CAAC,aAAa,EAAE,CAAC;;iBACL,MAAM,CAAC,WAAW,EAAE;;eAAhC;aAAG;wBACC,GAAG,CAAC,IAAI;0CACE,aAAa,uBAGzB,mBAAmB,wBACP,sBAAsB;;;eAHvB;gCAAS,cAAc,MAAvB,QAAQ,EAAiB,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,EAAW;;;gBAI/D;0BAAgB,GAAG,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,CACzD;;gBAAM,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,CAAC,AAC1C;cAAI,GAAG,CAAC,IAAI,IAAI,mBAAmB,EAAE,AACpC;iBAAM,CAAC,WAAW,CAAC,QAAQ,EAAE,gBAAgB,EAAE,IAAI,IAAI,EAAE,CAAC,CAAC,AAC3D;kBAAO,CAAC,KAAK,EAAE,CAAC;WAChB;;;;gBAGK,KAAK,CAAC,oBAAoB,GAAG,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC;;;;;;;;;;;;;;;;;;;UAcrD;qBAAiB,6BAAC,EAAU;qBAC3B;;YAAQ,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAc;;;;;;;;;;GAzExC;;SAAQ,GAAG,QAAQ,CAAC;0BAApB,QAAQ,GAAR,QAAQ,CACR;OAAM,GAAG,UAAU,CAAC;0BAApB,MAAM,GAAN,MAAM,CACN;SAAQ,GAAG,cAAI,WAAW,CAAC;0BAA3B,QAAQ,GAAR,QAAQ,CACR;QAAO,GAAG,MAAM,CAAC;;0BAAjB,OAAO,GAAP,OAAO,CAEP;KAAI,aAAsC,GAAG,IAAI,GAAG,EAAE,CAAC,AAEvD;;uBAAS,cAAc,MAAvB,QAAQ,EAAgB,WAAW,EAAE;CA6ErC;;;;;;;;;;kBCnGuB,OAAO;AAAhB,SAAS,OAAO,CAAC,IAAY,EAAE,IAAiB,EAAE,AAChE;KAAI,CAAC,KAAK,GAAG,IAAI,CAAC,AAClB;KAAI,CAAC,KAAK,GAAG,IAAI,CAAC;CAClB;;AAED,OAAO,CAAC,SAAS,GAAG,AACnB;YAAW,EAAE,OAAO,AACpB;KAAI,IAAI,GAAG,AAAC;SAAO,IAAI,CAAC,KAAK,CAAA;EAAC,AAC9B;KAAI,SAAS,GAAG,AAAC;SAAO,IAAI,CAAC,KAAK,CAAA;EAAC;CACnC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFF,IAAI,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC;;;;;;AAAC,SAKb,UAAU;uBAAV,UAAU,GAZjC,MAAM,KAAK,CAAC,iGAAiG,CAAC,CAAC;;;;sBA8BzG;SAAO;;;;;UAEX;aAAS;qBACR;;SAAI,GAAG,GAAG,CAAC;SAAE,GAAG,GAAG,CAAC,CAAC,AACrB;YAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC,CAAA,AAAC,CAAC,GAAG,GAAG,CAAC;;;;;;GAV3D;MAAI;mBAAJ,IAAI,GAAG,AACN;QAAI,CAAC,YAAY,EAAE,CAAC,AACpB;QAAI,CAAC,WAAW,EAAE,CAAC,AACnB;QAAI,CAAC,kBAAkB,EAAE,CAAC;IAC1B;GAUD;iBAAe;mBAAf,eAAe,CAAC,IAAgB,EAAE,oBAA6B,EAAE,AAChE;QAAI,CAAC,MAAM,CAAC,GAAG,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC,AACrC;QAAI,CAAC,MAAM,CAAC,GAAG,CAAC,sBAAsB,EAAE,oBAAoB,CAAC,CAAC;IAC9D;GAED;eAAa;mBAAb,aAAa,GAAG,AACf;QAAI,CAAC,SAAS,CAAC,GAAG,CAAC,qBAAqB,EAAE,IAAI,CAAC,CAAC;IAChD;GAED;WAAS;mBAAT,SAAS,CAAC,MAAc,EAAE,AACzB;SAAK,CAAC,MAAM,CAAC,CAAC;IACd;GAED;oBAAkB;mBAAlB,kBAAkB,GAAG,AACpB;QAAI,IAAI,GAAG,IAAI;QACd,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,AAEvB;;QAAI,CAAC,EAAE,CAAC,eAAe,EAAE,YAAW,AAInC;;;;uCAAmB,cAAI,OAAO,CAAC,IAAI,uBAAU,SAAS,MAAjB,OAAO,GAAc,IAAI,CAAC,CAAC;KAChE,CAAC,CAAC,AAEH;;QAAI,CAAC,EAAE,CAAC,aAAa,EAAE,YAAW,AACjC;SAAI,CAAC,YAAY,CAAC,aAAa,EAAE,sBAAS,SAAS,MAAjB,OAAO,EAAa,CAAC,CAAC;KACxD,CAAC,CAAC,AAEH;;QAAI,CAAC,EAAE,CAAC,mBAAmB,EAAE,YAAW,AACvC;SAAI,CAAC,YAAY,CAAC,mBAAmB,CAAC,CAAC;KACvC,CAAC,CAAC,AAEH;;QAAI,CAAC,EAAE,CAAC,sBAAsB,EAAE,YAAW,AAC1C;SAAI,CAAC,YAAY,CAAC,sBAAsB,CAAC,CAAC;KAC1C,CAAC,CAAC;IACH;GAED;cAAY;mBAAZ,YAAY,CAAC,WAAmB,EAAE,IAAiB,EAAE,AACpD;QAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,sBAAY,WAAW,EAAE,IAAI,CAAC,CAAC,CAAC,AAClE;QAAI,CAAC,oBAAoB,GAAG,wBAAc,CAAC;IAC3C;GAEK;aAAW;;;;;;;;;;;;;;+CAET,MAAK,oBAAoB,CAAC,OAAO;;;;;;;;;;;;;;;;;;aAFnC,WAAW;;;;WAAX,WAAW;;GAKjB;cAAY;mBAAZ,YAAY,GAAG,AACd;QAAI,CAAC,MAAM,GAAG,sBAAY,AACzB;OAAE,EAAE,WAAW,AACf;aAAQ,EAAE,gBAAgB;KAC1B,CAAC,CAAC;IACH;GAED;aAAW;mBAAX,WAAW,GAAG,AACb;QAAI,CAAC,SAAS,GAAG,sBAAY,AAC5B;OAAE,EAAE,MAAM,AACV;aAAQ,EAAE,eAAe,AACzB;SAAI,EAAE,AACL;sBAAgB,EAAE,KAAK;MACvB;KACD,CAAC,CAAC;IACH;GAED;kBAAgB;mBAAhB,gBAAgB,CAAC,SAA4B,EAAE,AAC9C;QAAI,CAAC,iBAAiB,GAAG,sBAAY,AACpC;OAAE,EAAE,WAAW,AACf;aAAQ,EAAE,uBAAuB,AACjC;SAAI,EAAE,AACL;eAAS,EAAT,SAAS;MACT;KACD,CAAC,CAAC;IACH;GAED;aAAW;mBAAX,WAAW,CAAC,QAAa,EAAE,SAA4B,EAAE,IAAU,EAAE,AACpE;QAAI,CAAC,YAAY,GAAG,sBAAY,AAC/B;OAAE,EAAE,SAAS,AACb;aAAQ,EAAE,kBAAkB,AAC5B;SAAI,EAAE,AACL;cAAQ,EAAR,QAAQ,AACR;eAAS,EAAT,SAAS,AACT;UAAI,EAAJ,IAAI;MACJ;KACD,CAAC,CAAC;IACH;;IAtGA;;QAAO,GAAG,IAAI,CAAC;0BAAf,OAAO,GAAP,OAAO,CACP;KAAI,CAAC,oBAAoB,GAAG,wBAAc,CAAC;;;kBATtB,UAAU;;;;;;;;kBCOT,QAAQ;;;;;;;;;;;;;;;;;;;;AAAjB,SAAS,QAAQ,CAAC,KAAc,EAAE,AAChD;MAAI,IAAI,GAAG,IAAI,CAAC,AAChB;MAAI,CAAC,OAAO,GAAG,IAAI,OAAO,CAAC,UAAS,OAAO,EAAE,MAAM,EAAE,AACpD;QAAI,CAAC,OAAO,GAAG,OAAO,CAAC,AACvB;QAAI,CAAC,MAAM,GAAG,MAAM,CAAC;GACrB,EAAE,KAAK,CAAC,CAAC;CACV;;;;;;;;;;;;;;;;;;;;SCtBsB,WAAW;uBAAX,WAAW,GAHlC,MAAM,KAAK,CAAC,iGAAiG,CAAC,CAAC;;;;;;;;GAU9G;MAAI;mBAAJ,IAAI,CAAC,MAAc,EAAE,AACpB;QAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,EAC9B,IAAI,CAAC,SAAS,CAAC,GAAG,CAAE,MAAM,CAAC,EAAE,EAAW,MAAM,CAAC,CAAC;IACjD;GAED;SAAO;mBAAP,OAAO,CAAC,EAAmB,EAAU,AACpC;WAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAE,EAAE,CAAU,CAAC;IACxC;GAED;QAAM;mBAAN,MAAM,CAAC,IAA8B,EAAE,AACtC;QAAI,QAAO,IAAI,yCAAJ,IAAI,OAAK,QAAQ,EAAE;;;;;SAC7B;2BAAmB,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,8HAAE;WAAnC,MAAM,eACd;;WAAI,IAAI,KAAK,MAAM,EAAE,AACpB;YAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,AACzB;eAAO;QACP;OACD;;;;;;;;;;;;;;;KACD,MACI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;IAC3B;GAED;YAAU;mBAAV,UAAU,CAAC,EAAmB,EAAE,AAC/B;QAAI,CAAC,SAAS,CAAC,MAAM,CAAE,EAAE,CAAU,CAAC;IACpC;;IA1BA;;KAAI,CAAC,SAAS,GAAG,IAAI,GAAG,EAAE,CAAC;;;kBAJN,WAAW;;;;;;;;;;;;;;;;;;;;;ACAlC,IAAI,GAAG,GAAG,EAAE,CAAC;kBACE,GAAG;;AAElB,GAAG,CAAC,OAAO,GAAG,AACb;KAAI,EAAE,mBAAS,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC;CACrC,CAAC;;AAEF,GAAG,CAAC,WAAW,GAAG,2BAAiB,CAAC;;;;;;;;kBCRZ,IAAI;;;;;;;;;;AAAb,SAAS,IAAI,CAAC,EAAU,EAAE,KAAa,EAAE,AACvD;sBAAW,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;CACjC;;AAED,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,qBAAW,SAAS,CAAC,CAAC;AACrD,IAAI,CAAC,SAAS,CAAC,WAAW,GAAG,IAAI,CAAC;;;;;;;;kBCLV,GAAG;;;;;;;;;;AAAZ,SAAS,GAAG,CAAC,EAAU,EAAE,KAAa,EAAE,AACtD;sBAAW,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;CACjC;;AAED,GAAG,CAAC,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,qBAAW,SAAS,CAAC,CAAC;AACpD,GAAG,CAAC,SAAS,CAAC,WAAW,GAAG,GAAG,CAAC;;;;;;;;kBCPR,UAAU;AAAnB,SAAS,UAAU,CAAC,EAAU,EAAE,KAAa,EAAE,AAC7D;KAAI,CAAC,GAAG,GAAG,EAAE,CAAC,AACd;KAAI,CAAC,MAAM,GAAG,KAAK,CAAC;CACpB;;AAED,UAAU,CAAC,SAAS,GAAG,AACtB;YAAW,EAAE,UAAU,AAGvB;;;YAAW,GAAG,AACb;SAAO,uBAAuB,CAAC,IAAI,CAAC,CAAC;EACrC,AAED;;KAAI,EAAE,GAAW,AAAC;SAAO,IAAI,CAAC,GAAG,CAAA;EAAC,AAClC;KAAI,KAAK,GAAW,AAAC;SAAO,IAAI,CAAC,MAAM,CAAA;EAAC;CACxC;;;AAAC,AAGF,SAAS,uBAAuB,CAAC,QAAoB,EAAE,AAEtD;;QAAO,IAAI,CAAC;CACZ;;;;;;;;kBCrBuB,IAAI;AAAb,SAAS,IAAI,CAAC,QAAc,EAAE,UAAsB,EAAE,OAAe,EAAE,AACrF;KAAI,CAAC,GAAG,GAAG,IAAI;AAAC,AAChB,KAAI,CAAC,SAAS,GAAG,QAAQ,CAAC,AAC1B;KAAI,CAAC,WAAW,GAAG,UAAU,CAAC,AAC9B;KAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;CACxB;;AAED,IAAI,CAAC,SAAS,GAAG,AAChB;YAAW,EAAE,IAAI,AACjB;KAAI,EAAE,GAAW,AAAC;SAAO,IAAI,CAAC,GAAG,CAAA;EAAC,AAClC;KAAI,QAAQ,GAAS,AAAC;SAAO,IAAI,CAAC,SAAS,CAAA;EAAC,AAC5C;KAAI,UAAU,GAAe,AAAC;SAAO,IAAI,CAAC,WAAW,CAAA;EAAC,AACtD;KAAI,OAAO,GAAW,AAAC;SAAO,IAAI,CAAC,QAAQ,CAAA;EAAC;CAC5C,CAAC;;;;;;;;kBCbsB,IAAI;AAAb,SAAS,IAAI,CAAC,UAAkB,EAAE,SAAiB,EAAE,QAAgB,EAAE,AACrF;KAAI,CAAC,WAAW,GAAG,UAAU,CAAC,AAC9B;KAAI,CAAC,SAAS,GAAG,SAAS,CAAC,AAC3B;KAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;CACzB;;AAED,IAAI,CAAC,SAAS,GAAG,AAChB;YAAW,EAAE,IAAI,AACjB;KAAI,IAAI,GAAW,AAClB;SAAO,IAAI,CAAC,SAAS,GAAG,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC;EAC5C,AACD;KAAI,UAAU,GAAW,AAAC;SAAO,IAAI,CAAC,WAAW,CAAA;EAAC;CAClD,CAAC;;;;;;;;;;;;;;;;;;;;;;;ACLF,6BAAc;;;;;AAAC,AAIf,0BAAgB,CAAC,IAAI,EAAE;;;AAAC;;;;;;;kBCPA,YAAY;;;;;;;;;;;;;;;;;;AAArB,SAAS,YAAY,GAAG,AACtC;KAAI,KAAK,GAAG,CACX,mBAAS,CAAC,EAAE,wBAAwB,CAAC,EACrC,mBAAS,CAAC,EAAE,2BAA2B,CAAC,EACxC,mBAAS,CAAC,EAAE,aAAa,CAAC,EAC1B,mBAAS,CAAC,EAAE,iBAAiB,CAAC,EAC9B,kBAAQ,CAAC,EAAE,iCAAiC,CAAC,EAC7C,kBAAQ,CAAC,EAAE,eAAe,CAAC,EAC3B,kBAAQ,CAAC,EAAE,0BAA0B,CAAC,CACtC,CAAC;;;;;;KAEF;uBAAiB,KAAK,8HAAE;OAAf,IAAI,eACZ;;iBAAI,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;GAC3B;;;;;;;;;;;;;;;CACD;;;;AClBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjpBA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;;ACFA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;;ACAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnRA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n",
    "/*\n\tRactive.js v0.7.3\n\tSat Apr 25 2015 13:52:38 GMT-0400 (EDT) - commit da40f81c660ba2f09c45a09a9c20fdd34ee36d80\n\n\thttp://ractivejs.org\n\thttp://twitter.com/RactiveJS\n\n\tReleased under the MIT License.\n*/\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.Ractive = factory()\n}(this, function () { 'use strict';\n\n  var TEMPLATE_VERSION = 3;\n\n  var defaultOptions = {\n\n  \t// render placement:\n  \tel: void 0,\n  \tappend: false,\n\n  \t// template:\n  \ttemplate: { v: TEMPLATE_VERSION, t: [] },\n\n  \t// parse:     // TODO static delimiters?\n  \tpreserveWhitespace: false,\n  \tsanitize: false,\n  \tstripComments: true,\n  \tdelimiters: [\"{{\", \"}}\"],\n  \ttripleDelimiters: [\"{{{\", \"}}}\"],\n  \tinterpolate: false,\n\n  \t// data & binding:\n  \tdata: {},\n  \tcomputed: {},\n  \tmagic: false,\n  \tmodifyArrays: true,\n  \tadapt: [],\n  \tisolated: false,\n  \ttwoway: true,\n  \tlazy: false,\n\n  \t// transitions:\n  \tnoIntro: false,\n  \ttransitionsEnabled: true,\n  \tcomplete: void 0,\n\n  \t// css:\n  \tcss: null,\n  \tnoCssTransform: false\n  };\n\n  var config_defaults = defaultOptions;\n\n  // These are a subset of the easing equations found at\n  // https://raw.github.com/danro/easing-js - license info\n  // follows:\n\n  // --------------------------------------------------\n  // easing.js v0.5.4\n  // Generic set of easing functions with AMD support\n  // https://github.com/danro/easing-js\n  // This code may be freely distributed under the MIT license\n  // http://danro.mit-license.org/\n  // --------------------------------------------------\n  // All functions adapted from Thomas Fuchs & Jeremy Kahn\n  // Easing Equations (c) 2003 Robert Penner, BSD license\n  // https://raw.github.com/danro/easing-js/master/LICENSE\n  // --------------------------------------------------\n\n  // In that library, the functions named easeIn, easeOut, and\n  // easeInOut below are named easeInCubic, easeOutCubic, and\n  // (you guessed it) easeInOutCubic.\n  //\n  // You can add additional easing functions to this list, and they\n  // will be globally available.\n\n  var static_easing = {\n  \tlinear: function (pos) {\n  \t\treturn pos;\n  \t},\n  \teaseIn: function (pos) {\n  \t\treturn Math.pow(pos, 3);\n  \t},\n  \teaseOut: function (pos) {\n  \t\treturn Math.pow(pos - 1, 3) + 1;\n  \t},\n  \teaseInOut: function (pos) {\n  \t\tif ((pos /= 0.5) < 1) {\n  \t\t\treturn 0.5 * Math.pow(pos, 3);\n  \t\t}\n  \t\treturn 0.5 * (Math.pow(pos - 2, 3) + 2);\n  \t}\n  };\n\n  /*global console, navigator */\n  var isClient, isJsdom, hasConsole, environment__magic, namespaces, svg, vendors;\n\n  isClient = typeof document === \"object\";\n\n  isJsdom = typeof navigator !== \"undefined\" && /jsDom/.test(navigator.appName);\n\n  hasConsole = typeof console !== \"undefined\" && typeof console.warn === \"function\" && typeof console.warn.apply === \"function\";\n\n  try {\n  \tObject.defineProperty({}, \"test\", { value: 0 });\n  \tenvironment__magic = true;\n  } catch (e) {\n  \tenvironment__magic = false;\n  }\n\n  namespaces = {\n  \thtml: \"http://www.w3.org/1999/xhtml\",\n  \tmathml: \"http://www.w3.org/1998/Math/MathML\",\n  \tsvg: \"http://www.w3.org/2000/svg\",\n  \txlink: \"http://www.w3.org/1999/xlink\",\n  \txml: \"http://www.w3.org/XML/1998/namespace\",\n  \txmlns: \"http://www.w3.org/2000/xmlns/\"\n  };\n\n  if (typeof document === \"undefined\") {\n  \tsvg = false;\n  } else {\n  \tsvg = document && document.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\", \"1.1\");\n  }\n\n  vendors = [\"o\", \"ms\", \"moz\", \"webkit\"];\n\n  var createElement, matches, dom__div, methodNames, unprefixed, prefixed, dom__i, j, makeFunction;\n\n  // Test for SVG support\n  if (!svg) {\n  \tcreateElement = function (type, ns) {\n  \t\tif (ns && ns !== namespaces.html) {\n  \t\t\tthrow \"This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information\";\n  \t\t}\n\n  \t\treturn document.createElement(type);\n  \t};\n  } else {\n  \tcreateElement = function (type, ns) {\n  \t\tif (!ns || ns === namespaces.html) {\n  \t\t\treturn document.createElement(type);\n  \t\t}\n\n  \t\treturn document.createElementNS(ns, type);\n  \t};\n  }\n\n  function getElement(input) {\n  \tvar output;\n\n  \tif (!input || typeof input === \"boolean\") {\n  \t\treturn;\n  \t}\n\n  \tif (typeof window === \"undefined\" || !document || !input) {\n  \t\treturn null;\n  \t}\n\n  \t// We already have a DOM node - no work to do. (Duck typing alert!)\n  \tif (input.nodeType) {\n  \t\treturn input;\n  \t}\n\n  \t// Get node from string\n  \tif (typeof input === \"string\") {\n  \t\t// try ID first\n  \t\toutput = document.getElementById(input);\n\n  \t\t// then as selector, if possible\n  \t\tif (!output && document.querySelector) {\n  \t\t\toutput = document.querySelector(input);\n  \t\t}\n\n  \t\t// did it work?\n  \t\tif (output && output.nodeType) {\n  \t\t\treturn output;\n  \t\t}\n  \t}\n\n  \t// If we've been given a collection (jQuery, Zepto etc), extract the first item\n  \tif (input[0] && input[0].nodeType) {\n  \t\treturn input[0];\n  \t}\n\n  \treturn null;\n  }\n\n  if (!isClient) {\n  \tmatches = null;\n  } else {\n  \tdom__div = createElement(\"div\");\n  \tmethodNames = [\"matches\", \"matchesSelector\"];\n\n  \tmakeFunction = function (methodName) {\n  \t\treturn function (node, selector) {\n  \t\t\treturn node[methodName](selector);\n  \t\t};\n  \t};\n\n  \tdom__i = methodNames.length;\n\n  \twhile (dom__i-- && !matches) {\n  \t\tunprefixed = methodNames[dom__i];\n\n  \t\tif (dom__div[unprefixed]) {\n  \t\t\tmatches = makeFunction(unprefixed);\n  \t\t} else {\n  \t\t\tj = vendors.length;\n  \t\t\twhile (j--) {\n  \t\t\t\tprefixed = vendors[dom__i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);\n\n  \t\t\t\tif (dom__div[prefixed]) {\n  \t\t\t\t\tmatches = makeFunction(prefixed);\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// IE8...\n  \tif (!matches) {\n  \t\tmatches = function (node, selector) {\n  \t\t\tvar nodes, parentNode, i;\n\n  \t\t\tparentNode = node.parentNode;\n\n  \t\t\tif (!parentNode) {\n  \t\t\t\t// empty dummy <div>\n  \t\t\t\tdom__div.innerHTML = \"\";\n\n  \t\t\t\tparentNode = dom__div;\n  \t\t\t\tnode = node.cloneNode();\n\n  \t\t\t\tdom__div.appendChild(node);\n  \t\t\t}\n\n  \t\t\tnodes = parentNode.querySelectorAll(selector);\n\n  \t\t\ti = nodes.length;\n  \t\t\twhile (i--) {\n  \t\t\t\tif (nodes[i] === node) {\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\treturn false;\n  \t\t};\n  \t}\n  }\n\n  function detachNode(node) {\n  \tif (node && typeof node.parentNode !== \"unknown\" && node.parentNode) {\n  \t\tnode.parentNode.removeChild(node);\n  \t}\n\n  \treturn node;\n  }\n\n  function safeToStringValue(value) {\n  \treturn value == null || !value.toString ? \"\" : value;\n  }\n\n  var legacy = null;\n\n  var create, defineProperty, defineProperties;\n\n  try {\n  \tObject.defineProperty({}, \"test\", { value: 0 });\n\n  \tif (isClient) {\n  \t\tObject.defineProperty(document.createElement(\"div\"), \"test\", { value: 0 });\n  \t}\n\n  \tdefineProperty = Object.defineProperty;\n  } catch (err) {\n  \t// Object.defineProperty doesn't exist, or we're in IE8 where you can\n  \t// only use it with DOM objects (what were you smoking, MSFT?)\n  \tdefineProperty = function (obj, prop, desc) {\n  \t\tobj[prop] = desc.value;\n  \t};\n  }\n\n  try {\n  \ttry {\n  \t\tObject.defineProperties({}, { test: { value: 0 } });\n  \t} catch (err) {\n  \t\t// TODO how do we account for this? noMagic = true;\n  \t\tthrow err;\n  \t}\n\n  \tif (isClient) {\n  \t\tObject.defineProperties(createElement(\"div\"), { test: { value: 0 } });\n  \t}\n\n  \tdefineProperties = Object.defineProperties;\n  } catch (err) {\n  \tdefineProperties = function (obj, props) {\n  \t\tvar prop;\n\n  \t\tfor (prop in props) {\n  \t\t\tif (props.hasOwnProperty(prop)) {\n  \t\t\t\tdefineProperty(obj, prop, props[prop]);\n  \t\t\t}\n  \t\t}\n  \t};\n  }\n\n  try {\n  \tObject.create(null);\n\n  \tcreate = Object.create;\n  } catch (err) {\n  \t// sigh\n  \tcreate = (function () {\n  \t\tvar F = function () {};\n\n  \t\treturn function (proto, props) {\n  \t\t\tvar obj;\n\n  \t\t\tif (proto === null) {\n  \t\t\t\treturn {};\n  \t\t\t}\n\n  \t\t\tF.prototype = proto;\n  \t\t\tobj = new F();\n\n  \t\t\tif (props) {\n  \t\t\t\tObject.defineProperties(obj, props);\n  \t\t\t}\n\n  \t\t\treturn obj;\n  \t\t};\n  \t})();\n  }\n\n  function utils_object__extend(target) {\n  \tfor (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\tsources[_key - 1] = arguments[_key];\n  \t}\n\n  \tvar prop, source;\n\n  \twhile (source = sources.shift()) {\n  \t\tfor (prop in source) {\n  \t\t\tif (hasOwn.call(source, prop)) {\n  \t\t\t\ttarget[prop] = source[prop];\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn target;\n  }\n\n  function fillGaps(target) {\n  \tfor (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\tsources[_key - 1] = arguments[_key];\n  \t}\n\n  \tsources.forEach(function (s) {\n  \t\tfor (var key in s) {\n  \t\t\tif (s.hasOwnProperty(key) && !(key in target)) {\n  \t\t\t\ttarget[key] = s[key];\n  \t\t\t}\n  \t\t}\n  \t});\n\n  \treturn target;\n  }\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  // thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n  var is__toString = Object.prototype.toString,\n      arrayLikePattern = /^\\[object (?:Array|FileList)\\]$/;\n  function isArray(thing) {\n  \treturn is__toString.call(thing) === \"[object Array]\";\n  }\n\n  function isArrayLike(obj) {\n  \treturn arrayLikePattern.test(is__toString.call(obj));\n  }\n\n  function isEqual(a, b) {\n  \tif (a === null && b === null) {\n  \t\treturn true;\n  \t}\n\n  \tif (typeof a === \"object\" || typeof b === \"object\") {\n  \t\treturn false;\n  \t}\n\n  \treturn a === b;\n  }\n\n  function is__isNumeric(thing) {\n  \treturn !isNaN(parseFloat(thing)) && isFinite(thing);\n  }\n\n  function isObject(thing) {\n  \treturn thing && is__toString.call(thing) === \"[object Object]\";\n  }\n\n  var noop = function () {};\n\n  /* global console */\n  var alreadyWarned = {},\n      log,\n      printWarning,\n      welcome;\n\n  if (hasConsole) {\n  \t(function () {\n  \t\tvar welcomeIntro = [\"%cRactive.js %c0.7.3 %cin debug mode, %cmore...\", \"color: rgb(114, 157, 52); font-weight: normal;\", \"color: rgb(85, 85, 85); font-weight: normal;\", \"color: rgb(85, 85, 85); font-weight: normal;\", \"color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;\"];\n  \t\tvar welcomeMessage = \"You're running Ractive 0.7.3 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\\n\\nTo disable debug mode, add this line at the start of your app:\\n  Ractive.DEBUG = false;\\n\\nTo disable debug mode when your app is minified, add this snippet:\\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\\n\\nGet help and support:\\n  http://docs.ractivejs.org\\n  http://stackoverflow.com/questions/tagged/ractivejs\\n  http://groups.google.com/forum/#!forum/ractive-js\\n  http://twitter.com/ractivejs\\n\\nFound a bug? Raise an issue:\\n  https://github.com/ractivejs/ractive/issues\\n\\n\";\n\n  \t\twelcome = function () {\n  \t\t\tvar hasGroup = !!console.groupCollapsed;\n  \t\t\tconsole[hasGroup ? \"groupCollapsed\" : \"log\"].apply(console, welcomeIntro);\n  \t\t\tconsole.log(welcomeMessage);\n  \t\t\tif (hasGroup) {\n  \t\t\t\tconsole.groupEnd(welcomeIntro);\n  \t\t\t}\n\n  \t\t\twelcome = noop;\n  \t\t};\n\n  \t\tprintWarning = function (message, args) {\n  \t\t\twelcome();\n\n  \t\t\t// extract information about the instance this message pertains to, if applicable\n  \t\t\tif (typeof args[args.length - 1] === \"object\") {\n  \t\t\t\tvar options = args.pop();\n  \t\t\t\tvar ractive = options ? options.ractive : null;\n\n  \t\t\t\tif (ractive) {\n  \t\t\t\t\t// if this is an instance of a component that we know the name of, add\n  \t\t\t\t\t// it to the message\n  \t\t\t\t\tvar _name = undefined;\n  \t\t\t\t\tif (ractive.component && (_name = ractive.component.name)) {\n  \t\t\t\t\t\tmessage = \"<\" + _name + \"> \" + message;\n  \t\t\t\t\t}\n\n  \t\t\t\t\tvar node = undefined;\n  \t\t\t\t\tif (node = options.node || ractive.fragment && ractive.fragment.rendered && ractive.find(\"*\")) {\n  \t\t\t\t\t\targs.push(node);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tconsole.warn.apply(console, [\"%cRactive.js: %c\" + message, \"color: rgb(114, 157, 52);\", \"color: rgb(85, 85, 85);\"].concat(args));\n  \t\t};\n\n  \t\tlog = function () {\n  \t\t\tconsole.log.apply(console, arguments);\n  \t\t};\n  \t})();\n  } else {\n  \tprintWarning = log = welcome = noop;\n  }\n\n  function format(message, args) {\n  \treturn message.replace(/%s/g, function () {\n  \t\treturn args.shift();\n  \t});\n  }\n\n  function fatal(message) {\n  \tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\targs[_key - 1] = arguments[_key];\n  \t}\n\n  \tmessage = format(message, args);\n  \tthrow new Error(message);\n  }\n\n  function logIfDebug() {\n  \tif (_Ractive.DEBUG) {\n  \t\tlog.apply(null, arguments);\n  \t}\n  }\n\n  function warn(message) {\n  \tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\targs[_key - 1] = arguments[_key];\n  \t}\n\n  \tmessage = format(message, args);\n  \tprintWarning(message, args);\n  }\n\n  function warnOnce(message) {\n  \tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\targs[_key - 1] = arguments[_key];\n  \t}\n\n  \tmessage = format(message, args);\n\n  \tif (alreadyWarned[message]) {\n  \t\treturn;\n  \t}\n\n  \talreadyWarned[message] = true;\n  \tprintWarning(message, args);\n  }\n\n  function warnIfDebug() {\n  \tif (_Ractive.DEBUG) {\n  \t\twarn.apply(null, arguments);\n  \t}\n  }\n\n  function warnOnceIfDebug() {\n  \tif (_Ractive.DEBUG) {\n  \t\twarnOnce.apply(null, arguments);\n  \t}\n  }\n\n  // Error messages that are used (or could be) in multiple places\n  var badArguments = \"Bad arguments\";\n  var noRegistryFunctionReturn = \"A function was specified for \\\"%s\\\" %s, but no %s was returned\";\n  var missingPlugin = function (name, type) {\n    return \"Missing \\\"\" + name + \"\\\" \" + type + \" plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#\" + type + \"s\";\n  };\n\n  function findInViewHierarchy(registryName, ractive, name) {\n  \tvar instance = findInstance(registryName, ractive, name);\n  \treturn instance ? instance[registryName][name] : null;\n  }\n\n  function findInstance(registryName, ractive, name) {\n  \twhile (ractive) {\n  \t\tif (name in ractive[registryName]) {\n  \t\t\treturn ractive;\n  \t\t}\n\n  \t\tif (ractive.isolated) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tractive = ractive.parent;\n  \t}\n  }\n\n  var interpolate = function (from, to, ractive, type) {\n  \tif (from === to) {\n  \t\treturn snap(to);\n  \t}\n\n  \tif (type) {\n\n  \t\tvar interpol = findInViewHierarchy(\"interpolators\", ractive, type);\n  \t\tif (interpol) {\n  \t\t\treturn interpol(from, to) || snap(to);\n  \t\t}\n\n  \t\tfatal(missingPlugin(type, \"interpolator\"));\n  \t}\n\n  \treturn static_interpolators.number(from, to) || static_interpolators.array(from, to) || static_interpolators.object(from, to) || snap(to);\n  };\n\n  var shared_interpolate = interpolate;\n\n  function snap(to) {\n  \treturn function () {\n  \t\treturn to;\n  \t};\n  }\n\n  var interpolators = {\n  \tnumber: function (from, to) {\n  \t\tvar delta;\n\n  \t\tif (!is__isNumeric(from) || !is__isNumeric(to)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tfrom = +from;\n  \t\tto = +to;\n\n  \t\tdelta = to - from;\n\n  \t\tif (!delta) {\n  \t\t\treturn function () {\n  \t\t\t\treturn from;\n  \t\t\t};\n  \t\t}\n\n  \t\treturn function (t) {\n  \t\t\treturn from + t * delta;\n  \t\t};\n  \t},\n\n  \tarray: function (from, to) {\n  \t\tvar intermediate, interpolators, len, i;\n\n  \t\tif (!isArray(from) || !isArray(to)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tintermediate = [];\n  \t\tinterpolators = [];\n\n  \t\ti = len = Math.min(from.length, to.length);\n  \t\twhile (i--) {\n  \t\t\tinterpolators[i] = shared_interpolate(from[i], to[i]);\n  \t\t}\n\n  \t\t// surplus values - don't interpolate, but don't exclude them either\n  \t\tfor (i = len; i < from.length; i += 1) {\n  \t\t\tintermediate[i] = from[i];\n  \t\t}\n\n  \t\tfor (i = len; i < to.length; i += 1) {\n  \t\t\tintermediate[i] = to[i];\n  \t\t}\n\n  \t\treturn function (t) {\n  \t\t\tvar i = len;\n\n  \t\t\twhile (i--) {\n  \t\t\t\tintermediate[i] = interpolators[i](t);\n  \t\t\t}\n\n  \t\t\treturn intermediate;\n  \t\t};\n  \t},\n\n  \tobject: function (from, to) {\n  \t\tvar properties, len, interpolators, intermediate, prop;\n\n  \t\tif (!isObject(from) || !isObject(to)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tproperties = [];\n  \t\tintermediate = {};\n  \t\tinterpolators = {};\n\n  \t\tfor (prop in from) {\n  \t\t\tif (hasOwn.call(from, prop)) {\n  \t\t\t\tif (hasOwn.call(to, prop)) {\n  \t\t\t\t\tproperties.push(prop);\n  \t\t\t\t\tinterpolators[prop] = shared_interpolate(from[prop], to[prop]);\n  \t\t\t\t} else {\n  \t\t\t\t\tintermediate[prop] = from[prop];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tfor (prop in to) {\n  \t\t\tif (hasOwn.call(to, prop) && !hasOwn.call(from, prop)) {\n  \t\t\t\tintermediate[prop] = to[prop];\n  \t\t\t}\n  \t\t}\n\n  \t\tlen = properties.length;\n\n  \t\treturn function (t) {\n  \t\t\tvar i = len,\n  \t\t\t    prop;\n\n  \t\t\twhile (i--) {\n  \t\t\t\tprop = properties[i];\n\n  \t\t\t\tintermediate[prop] = interpolators[prop](t);\n  \t\t\t}\n\n  \t\t\treturn intermediate;\n  \t\t};\n  \t}\n  };\n\n  var static_interpolators = interpolators;\n\n  // This function takes a keypath such as 'foo.bar.baz', and returns\n  // all the variants of that keypath that include a wildcard in place\n  // of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.\n  // These are then checked against the dependants map (ractive.viewmodel.depsMap)\n  // to see if any pattern observers are downstream of one or more of\n  // these wildcard keypaths (e.g. 'foo.bar.*.status')\n  var utils_getPotentialWildcardMatches = getPotentialWildcardMatches;\n\n  var starMaps = {};\n  function getPotentialWildcardMatches(keypath) {\n  \tvar keys, starMap, mapper, i, result, wildcardKeypath;\n\n  \tkeys = keypath.split(\".\");\n  \tif (!(starMap = starMaps[keys.length])) {\n  \t\tstarMap = getStarMap(keys.length);\n  \t}\n\n  \tresult = [];\n\n  \tmapper = function (star, i) {\n  \t\treturn star ? \"*\" : keys[i];\n  \t};\n\n  \ti = starMap.length;\n  \twhile (i--) {\n  \t\twildcardKeypath = starMap[i].map(mapper).join(\".\");\n\n  \t\tif (!result.hasOwnProperty(wildcardKeypath)) {\n  \t\t\tresult.push(wildcardKeypath);\n  \t\t\tresult[wildcardKeypath] = true;\n  \t\t}\n  \t}\n\n  \treturn result;\n  }\n\n  // This function returns all the possible true/false combinations for\n  // a given number - e.g. for two, the possible combinations are\n  // [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n  // It does so by getting all the binary values between 0 and e.g. 11\n  function getStarMap(num) {\n  \tvar ones = \"\",\n  \t    max,\n  \t    binary,\n  \t    starMap,\n  \t    mapper,\n  \t    i,\n  \t    j,\n  \t    l,\n  \t    map;\n\n  \tif (!starMaps[num]) {\n  \t\tstarMap = [];\n\n  \t\twhile (ones.length < num) {\n  \t\t\tones += 1;\n  \t\t}\n\n  \t\tmax = parseInt(ones, 2);\n\n  \t\tmapper = function (digit) {\n  \t\t\treturn digit === \"1\";\n  \t\t};\n\n  \t\tfor (i = 0; i <= max; i += 1) {\n  \t\t\tbinary = i.toString(2);\n  \t\t\twhile (binary.length < num) {\n  \t\t\t\tbinary = \"0\" + binary;\n  \t\t\t}\n\n  \t\t\tmap = [];\n  \t\t\tl = binary.length;\n  \t\t\tfor (j = 0; j < l; j++) {\n  \t\t\t\tmap.push(mapper(binary[j]));\n  \t\t\t}\n  \t\t\tstarMap[i] = map;\n  \t\t}\n\n  \t\tstarMaps[num] = starMap;\n  \t}\n\n  \treturn starMaps[num];\n  }\n\n  var refPattern = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\n  var patternPattern = /\\*/;\n  var keypathCache = {};\n\n  var Keypath = function (str) {\n  \tvar keys = str.split(\".\");\n\n  \tthis.str = str;\n\n  \tif (str[0] === \"@\") {\n  \t\tthis.isSpecial = true;\n  \t\tthis.value = decodeKeypath(str);\n  \t}\n\n  \tthis.firstKey = keys[0];\n  \tthis.lastKey = keys.pop();\n\n  \tthis.isPattern = patternPattern.test(str);\n\n  \tthis.parent = str === \"\" ? null : getKeypath(keys.join(\".\"));\n  \tthis.isRoot = !str;\n  };\n\n  Keypath.prototype = {\n  \tequalsOrStartsWith: function (keypath) {\n  \t\treturn keypath === this || this.startsWith(keypath);\n  \t},\n\n  \tjoin: function (str) {\n  \t\treturn getKeypath(this.isRoot ? String(str) : this.str + \".\" + str);\n  \t},\n\n  \treplace: function (oldKeypath, newKeypath) {\n  \t\tif (this === oldKeypath) {\n  \t\t\treturn newKeypath;\n  \t\t}\n\n  \t\tif (this.startsWith(oldKeypath)) {\n  \t\t\treturn newKeypath === null ? newKeypath : getKeypath(this.str.replace(oldKeypath.str + \".\", newKeypath.str + \".\"));\n  \t\t}\n  \t},\n\n  \tstartsWith: function (keypath) {\n  \t\tif (!keypath) {\n  \t\t\t// TODO under what circumstances does this happen?\n  \t\t\treturn false;\n  \t\t}\n\n  \t\treturn keypath && this.str.substr(0, keypath.str.length + 1) === keypath.str + \".\";\n  \t},\n\n  \ttoString: function () {\n  \t\tthrow new Error(\"Bad coercion\");\n  \t},\n\n  \tvalueOf: function () {\n  \t\tthrow new Error(\"Bad coercion\");\n  \t},\n\n  \twildcardMatches: function () {\n  \t\treturn this._wildcardMatches || (this._wildcardMatches = utils_getPotentialWildcardMatches(this.str));\n  \t}\n  };\n  function assignNewKeypath(target, property, oldKeypath, newKeypath) {\n  \tvar existingKeypath = target[property];\n\n  \tif (existingKeypath && (existingKeypath.equalsOrStartsWith(newKeypath) || !existingKeypath.equalsOrStartsWith(oldKeypath))) {\n  \t\treturn;\n  \t}\n\n  \ttarget[property] = existingKeypath ? existingKeypath.replace(oldKeypath, newKeypath) : newKeypath;\n  \treturn true;\n  }\n\n  function decodeKeypath(keypath) {\n  \tvar value = keypath.slice(2);\n\n  \tif (keypath[1] === \"i\") {\n  \t\treturn is__isNumeric(value) ? +value : value;\n  \t} else {\n  \t\treturn value;\n  \t}\n  }\n\n  function getKeypath(str) {\n  \tif (str == null) {\n  \t\treturn str;\n  \t}\n\n  \t// TODO it *may* be worth having two versions of this function - one where\n  \t// keypathCache inherits from null, and one for IE8. Depends on how\n  \t// much of an overhead hasOwnProperty is - probably negligible\n  \tif (!keypathCache.hasOwnProperty(str)) {\n  \t\tkeypathCache[str] = new Keypath(str);\n  \t}\n\n  \treturn keypathCache[str];\n  }\n\n  function getMatchingKeypaths(ractive, keypath) {\n  \tvar keys, key, matchingKeypaths;\n\n  \tkeys = keypath.str.split(\".\");\n  \tmatchingKeypaths = [rootKeypath];\n\n  \twhile (key = keys.shift()) {\n  \t\tif (key === \"*\") {\n  \t\t\t// expand to find all valid child keypaths\n  \t\t\tmatchingKeypaths = matchingKeypaths.reduce(expand, []);\n  \t\t} else {\n  \t\t\tif (matchingKeypaths[0] === rootKeypath) {\n  \t\t\t\t// first key\n  \t\t\t\tmatchingKeypaths[0] = getKeypath(key);\n  \t\t\t} else {\n  \t\t\t\tmatchingKeypaths = matchingKeypaths.map(concatenate(key));\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn matchingKeypaths;\n\n  \tfunction expand(matchingKeypaths, keypath) {\n  \t\tvar wrapper, value, keys;\n\n  \t\tif (keypath.isRoot) {\n  \t\t\tkeys = [].concat(Object.keys(ractive.viewmodel.data), Object.keys(ractive.viewmodel.mappings), Object.keys(ractive.viewmodel.computations));\n  \t\t} else {\n  \t\t\twrapper = ractive.viewmodel.wrapped[keypath.str];\n  \t\t\tvalue = wrapper ? wrapper.get() : ractive.viewmodel.get(keypath);\n\n  \t\t\tkeys = value ? Object.keys(value) : null;\n  \t\t}\n\n  \t\tif (keys) {\n  \t\t\tkeys.forEach(function (key) {\n  \t\t\t\tif (key !== \"_ractive\" || !isArray(value)) {\n  \t\t\t\t\tmatchingKeypaths.push(keypath.join(key));\n  \t\t\t\t}\n  \t\t\t});\n  \t\t}\n\n  \t\treturn matchingKeypaths;\n  \t}\n  }\n\n  function concatenate(key) {\n  \treturn function (keypath) {\n  \t\treturn keypath.join(key);\n  \t};\n  }\n  function normalise(ref) {\n  \treturn ref ? ref.replace(refPattern, \".$1\") : \"\";\n  }\n\n  var rootKeypath = getKeypath(\"\");\n\n  var shared_add = add;\n  var shared_add__errorMessage = \"Cannot add to a non-numeric value\";\n  function add(root, keypath, d) {\n  \tif (typeof keypath !== \"string\" || !is__isNumeric(d)) {\n  \t\tthrow new Error(\"Bad arguments\");\n  \t}\n\n  \tvar value = undefined,\n  \t    changes = undefined;\n\n  \tif (/\\*/.test(keypath)) {\n  \t\tchanges = {};\n\n  \t\tgetMatchingKeypaths(root, getKeypath(normalise(keypath))).forEach(function (keypath) {\n  \t\t\tvar value = root.viewmodel.get(keypath);\n\n  \t\t\tif (!is__isNumeric(value)) {\n  \t\t\t\tthrow new Error(shared_add__errorMessage);\n  \t\t\t}\n\n  \t\t\tchanges[keypath.str] = value + d;\n  \t\t});\n\n  \t\treturn root.set(changes);\n  \t}\n\n  \tvalue = root.get(keypath);\n\n  \tif (!is__isNumeric(value)) {\n  \t\tthrow new Error(shared_add__errorMessage);\n  \t}\n\n  \treturn root.set(keypath, +value + d);\n  }\n\n  var prototype_add = Ractive$add;\n  function Ractive$add(keypath, d) {\n  \treturn shared_add(this, keypath, d === undefined ? 1 : +d);\n  }\n\n  var requestAnimationFrame;\n\n  // If window doesn't exist, we don't need requestAnimationFrame\n  if (typeof window === \"undefined\") {\n  \trequestAnimationFrame = null;\n  } else {\n  \t// https://gist.github.com/paulirish/1579671\n  \t(function (vendors, lastTime, window) {\n\n  \t\tvar x, setTimeout;\n\n  \t\tif (window.requestAnimationFrame) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfor (x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n  \t\t\twindow.requestAnimationFrame = window[vendors[x] + \"RequestAnimationFrame\"];\n  \t\t}\n\n  \t\tif (!window.requestAnimationFrame) {\n  \t\t\tsetTimeout = window.setTimeout;\n\n  \t\t\twindow.requestAnimationFrame = function (callback) {\n  \t\t\t\tvar currTime, timeToCall, id;\n\n  \t\t\t\tcurrTime = Date.now();\n  \t\t\t\ttimeToCall = Math.max(0, 16 - (currTime - lastTime));\n  \t\t\t\tid = setTimeout(function () {\n  \t\t\t\t\tcallback(currTime + timeToCall);\n  \t\t\t\t}, timeToCall);\n\n  \t\t\t\tlastTime = currTime + timeToCall;\n  \t\t\t\treturn id;\n  \t\t\t};\n  \t\t}\n  \t})(vendors, 0, window);\n\n  \trequestAnimationFrame = window.requestAnimationFrame;\n  }\n\n  var rAF = requestAnimationFrame;\n\n  var getTime;\n\n  if (typeof window !== \"undefined\" && window.performance && typeof window.performance.now === \"function\") {\n  \tgetTime = function () {\n  \t\treturn window.performance.now();\n  \t};\n  } else {\n  \tgetTime = function () {\n  \t\treturn Date.now();\n  \t};\n  }\n\n  var utils_getTime = getTime;\n\n  var deprecations = {\n  \tconstruct: {\n  \t\tdeprecated: \"beforeInit\",\n  \t\treplacement: \"onconstruct\"\n  \t},\n  \trender: {\n  \t\tdeprecated: \"init\",\n  \t\tmessage: \"The \\\"init\\\" method has been deprecated \" + \"and will likely be removed in a future release. \" + \"You can either use the \\\"oninit\\\" method which will fire \" + \"only once prior to, and regardless of, any eventual ractive \" + \"instance being rendered, or if you need to access the \" + \"rendered DOM, use \\\"onrender\\\" instead. \" + \"See http://docs.ractivejs.org/latest/migrating for more information.\"\n  \t},\n  \tcomplete: {\n  \t\tdeprecated: \"complete\",\n  \t\treplacement: \"oncomplete\"\n  \t}\n  };\n\n  function Hook(event) {\n  \tthis.event = event;\n  \tthis.method = \"on\" + event;\n  \tthis.deprecate = deprecations[event];\n  }\n\n  Hook.prototype.fire = function (ractive, arg) {\n  \tfunction call(method) {\n  \t\tif (ractive[method]) {\n  \t\t\targ ? ractive[method](arg) : ractive[method]();\n  \t\t\treturn true;\n  \t\t}\n  \t}\n\n  \tcall(this.method);\n\n  \tif (!ractive[this.method] && this.deprecate && call(this.deprecate.deprecated)) {\n  \t\tif (this.deprecate.message) {\n  \t\t\twarnIfDebug(this.deprecate.message);\n  \t\t} else {\n  \t\t\twarnIfDebug(\"The method \\\"%s\\\" has been deprecated in favor of \\\"%s\\\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.\", this.deprecate.deprecated, this.deprecate.replacement);\n  \t\t}\n  \t}\n\n  \targ ? ractive.fire(this.event, arg) : ractive.fire(this.event);\n  };\n\n  var hooks_Hook = Hook;\n\n  function addToArray(array, value) {\n  \tvar index = array.indexOf(value);\n\n  \tif (index === -1) {\n  \t\tarray.push(value);\n  \t}\n  }\n\n  function arrayContains(array, value) {\n  \tfor (var i = 0, c = array.length; i < c; i++) {\n  \t\tif (array[i] == value) {\n  \t\t\treturn true;\n  \t\t}\n  \t}\n\n  \treturn false;\n  }\n\n  function arrayContentsMatch(a, b) {\n  \tvar i;\n\n  \tif (!isArray(a) || !isArray(b)) {\n  \t\treturn false;\n  \t}\n\n  \tif (a.length !== b.length) {\n  \t\treturn false;\n  \t}\n\n  \ti = a.length;\n  \twhile (i--) {\n  \t\tif (a[i] !== b[i]) {\n  \t\t\treturn false;\n  \t\t}\n  \t}\n\n  \treturn true;\n  }\n\n  function ensureArray(x) {\n  \tif (typeof x === \"string\") {\n  \t\treturn [x];\n  \t}\n\n  \tif (x === undefined) {\n  \t\treturn [];\n  \t}\n\n  \treturn x;\n  }\n\n  function lastItem(array) {\n  \treturn array[array.length - 1];\n  }\n\n  function removeFromArray(array, member) {\n  \tvar index = array.indexOf(member);\n\n  \tif (index !== -1) {\n  \t\tarray.splice(index, 1);\n  \t}\n  }\n\n  function toArray(arrayLike) {\n  \tvar array = [],\n  \t    i = arrayLike.length;\n  \twhile (i--) {\n  \t\tarray[i] = arrayLike[i];\n  \t}\n\n  \treturn array;\n  }\n\n  var _Promise,\n      PENDING = {},\n      FULFILLED = {},\n      REJECTED = {};\n\n  if (typeof Promise === \"function\") {\n  \t// use native Promise\n  \t_Promise = Promise;\n  } else {\n  \t_Promise = function (callback) {\n  \t\tvar fulfilledHandlers = [],\n  \t\t    rejectedHandlers = [],\n  \t\t    state = PENDING,\n  \t\t    result,\n  \t\t    dispatchHandlers,\n  \t\t    makeResolver,\n  \t\t    fulfil,\n  \t\t    reject,\n  \t\t    promise;\n\n  \t\tmakeResolver = function (newState) {\n  \t\t\treturn function (value) {\n  \t\t\t\tif (state !== PENDING) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tresult = value;\n  \t\t\t\tstate = newState;\n\n  \t\t\t\tdispatchHandlers = makeDispatcher(state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result);\n\n  \t\t\t\t// dispatch onFulfilled and onRejected handlers asynchronously\n  \t\t\t\twait(dispatchHandlers);\n  \t\t\t};\n  \t\t};\n\n  \t\tfulfil = makeResolver(FULFILLED);\n  \t\treject = makeResolver(REJECTED);\n\n  \t\ttry {\n  \t\t\tcallback(fulfil, reject);\n  \t\t} catch (err) {\n  \t\t\treject(err);\n  \t\t}\n\n  \t\tpromise = {\n  \t\t\t// `then()` returns a Promise - 2.2.7\n  \t\t\tthen: function (onFulfilled, onRejected) {\n  \t\t\t\tvar promise2 = new _Promise(function (fulfil, reject) {\n\n  \t\t\t\t\tvar processResolutionHandler = function (handler, handlers, forward) {\n\n  \t\t\t\t\t\t// 2.2.1.1\n  \t\t\t\t\t\tif (typeof handler === \"function\") {\n  \t\t\t\t\t\t\thandlers.push(function (p1result) {\n  \t\t\t\t\t\t\t\tvar x;\n\n  \t\t\t\t\t\t\t\ttry {\n  \t\t\t\t\t\t\t\t\tx = handler(p1result);\n  \t\t\t\t\t\t\t\t\tutils_Promise__resolve(promise2, x, fulfil, reject);\n  \t\t\t\t\t\t\t\t} catch (err) {\n  \t\t\t\t\t\t\t\t\treject(err);\n  \t\t\t\t\t\t\t\t}\n  \t\t\t\t\t\t\t});\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\t// Forward the result of promise1 to promise2, if resolution handlers\n  \t\t\t\t\t\t\t// are not given\n  \t\t\t\t\t\t\thandlers.push(forward);\n  \t\t\t\t\t\t}\n  \t\t\t\t\t};\n\n  \t\t\t\t\t// 2.2\n  \t\t\t\t\tprocessResolutionHandler(onFulfilled, fulfilledHandlers, fulfil);\n  \t\t\t\t\tprocessResolutionHandler(onRejected, rejectedHandlers, reject);\n\n  \t\t\t\t\tif (state !== PENDING) {\n  \t\t\t\t\t\t// If the promise has resolved already, dispatch the appropriate handlers asynchronously\n  \t\t\t\t\t\twait(dispatchHandlers);\n  \t\t\t\t\t}\n  \t\t\t\t});\n\n  \t\t\t\treturn promise2;\n  \t\t\t}\n  \t\t};\n\n  \t\tpromise[\"catch\"] = function (onRejected) {\n  \t\t\treturn this.then(null, onRejected);\n  \t\t};\n\n  \t\treturn promise;\n  \t};\n\n  \t_Promise.all = function (promises) {\n  \t\treturn new _Promise(function (fulfil, reject) {\n  \t\t\tvar result = [],\n  \t\t\t    pending,\n  \t\t\t    i,\n  \t\t\t    processPromise;\n\n  \t\t\tif (!promises.length) {\n  \t\t\t\tfulfil(result);\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tprocessPromise = function (promise, i) {\n  \t\t\t\tif (promise && typeof promise.then === \"function\") {\n  \t\t\t\t\tpromise.then(function (value) {\n  \t\t\t\t\t\tresult[i] = value;\n  \t\t\t\t\t\t--pending || fulfil(result);\n  \t\t\t\t\t}, reject);\n  \t\t\t\t} else {\n  \t\t\t\t\tresult[i] = promise;\n  \t\t\t\t\t--pending || fulfil(result);\n  \t\t\t\t}\n  \t\t\t};\n\n  \t\t\tpending = i = promises.length;\n  \t\t\twhile (i--) {\n  \t\t\t\tprocessPromise(promises[i], i);\n  \t\t\t}\n  \t\t});\n  \t};\n\n  \t_Promise.resolve = function (value) {\n  \t\treturn new _Promise(function (fulfil) {\n  \t\t\tfulfil(value);\n  \t\t});\n  \t};\n\n  \t_Promise.reject = function (reason) {\n  \t\treturn new _Promise(function (fulfil, reject) {\n  \t\t\treject(reason);\n  \t\t});\n  \t};\n  }\n\n  var utils_Promise = _Promise;\n\n  // TODO use MutationObservers or something to simulate setImmediate\n  function wait(callback) {\n  \tsetTimeout(callback, 0);\n  }\n\n  function makeDispatcher(handlers, result) {\n  \treturn function () {\n  \t\tvar handler;\n\n  \t\twhile (handler = handlers.shift()) {\n  \t\t\thandler(result);\n  \t\t}\n  \t};\n  }\n\n  function utils_Promise__resolve(promise, x, fulfil, reject) {\n  \t// Promise Resolution Procedure\n  \tvar then;\n\n  \t// 2.3.1\n  \tif (x === promise) {\n  \t\tthrow new TypeError(\"A promise's fulfillment handler cannot return the same promise\");\n  \t}\n\n  \t// 2.3.2\n  \tif (x instanceof _Promise) {\n  \t\tx.then(fulfil, reject);\n  \t}\n\n  \t// 2.3.3\n  \telse if (x && (typeof x === \"object\" || typeof x === \"function\")) {\n  \t\ttry {\n  \t\t\tthen = x.then; // 2.3.3.1\n  \t\t} catch (e) {\n  \t\t\treject(e); // 2.3.3.2\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// 2.3.3.3\n  \t\tif (typeof then === \"function\") {\n  \t\t\tvar called, resolvePromise, rejectPromise;\n\n  \t\t\tresolvePromise = function (y) {\n  \t\t\t\tif (called) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n  \t\t\t\tcalled = true;\n  \t\t\t\tutils_Promise__resolve(promise, y, fulfil, reject);\n  \t\t\t};\n\n  \t\t\trejectPromise = function (r) {\n  \t\t\t\tif (called) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n  \t\t\t\tcalled = true;\n  \t\t\t\treject(r);\n  \t\t\t};\n\n  \t\t\ttry {\n  \t\t\t\tthen.call(x, resolvePromise, rejectPromise);\n  \t\t\t} catch (e) {\n  \t\t\t\tif (!called) {\n  \t\t\t\t\t// 2.3.3.3.4.1\n  \t\t\t\t\treject(e); // 2.3.3.3.4.2\n  \t\t\t\t\tcalled = true;\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else {\n  \t\t\tfulfil(x);\n  \t\t}\n  \t} else {\n  \t\tfulfil(x);\n  \t}\n  }\n\n  var getInnerContext = function (fragment) {\n  \tdo {\n  \t\tif (fragment.context !== undefined) {\n  \t\t\treturn fragment.context;\n  \t\t}\n  \t} while (fragment = fragment.parent);\n\n  \treturn rootKeypath;\n  };\n\n  var shared_resolveRef = resolveRef;\n\n  function resolveRef(ractive, ref, fragment) {\n  \tvar keypath;\n\n  \tref = normalise(ref);\n\n  \t// If a reference begins '~/', it's a top-level reference\n  \tif (ref.substr(0, 2) === \"~/\") {\n  \t\tkeypath = getKeypath(ref.substring(2));\n  \t\tcreateMappingIfNecessary(ractive, keypath.firstKey, fragment);\n  \t}\n\n  \t// If a reference begins with '.', it's either a restricted reference or\n  \t// an ancestor reference...\n  \telse if (ref[0] === \".\") {\n  \t\tkeypath = resolveAncestorRef(getInnerContext(fragment), ref);\n\n  \t\tif (keypath) {\n  \t\t\tcreateMappingIfNecessary(ractive, keypath.firstKey, fragment);\n  \t\t}\n  \t}\n\n  \t// ...otherwise we need to figure out the keypath based on context\n  \telse {\n  \t\tkeypath = resolveAmbiguousReference(ractive, getKeypath(ref), fragment);\n  \t}\n\n  \treturn keypath;\n  }\n\n  function resolveAncestorRef(baseContext, ref) {\n  \tvar contextKeys;\n\n  \t// TODO...\n  \tif (baseContext != undefined && typeof baseContext !== \"string\") {\n  \t\tbaseContext = baseContext.str;\n  \t}\n\n  \t// {{.}} means 'current context'\n  \tif (ref === \".\") return getKeypath(baseContext);\n\n  \tcontextKeys = baseContext ? baseContext.split(\".\") : [];\n\n  \t// ancestor references (starting \"../\") go up the tree\n  \tif (ref.substr(0, 3) === \"../\") {\n  \t\twhile (ref.substr(0, 3) === \"../\") {\n  \t\t\tif (!contextKeys.length) {\n  \t\t\t\tthrow new Error(\"Could not resolve reference - too many \\\"../\\\" prefixes\");\n  \t\t\t}\n\n  \t\t\tcontextKeys.pop();\n  \t\t\tref = ref.substring(3);\n  \t\t}\n\n  \t\tcontextKeys.push(ref);\n  \t\treturn getKeypath(contextKeys.join(\".\"));\n  \t}\n\n  \t// not an ancestor reference - must be a restricted reference (prepended with \".\" or \"./\")\n  \tif (!baseContext) {\n  \t\treturn getKeypath(ref.replace(/^\\.\\/?/, \"\"));\n  \t}\n\n  \treturn getKeypath(baseContext + ref.replace(/^\\.\\//, \".\"));\n  }\n\n  function resolveAmbiguousReference(ractive, ref, fragment, isParentLookup) {\n  \tvar context, key, parentValue, hasContextChain, parentKeypath;\n\n  \tif (ref.isRoot) {\n  \t\treturn ref;\n  \t}\n\n  \tkey = ref.firstKey;\n\n  \twhile (fragment) {\n  \t\tcontext = fragment.context;\n  \t\tfragment = fragment.parent;\n\n  \t\tif (!context) {\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\thasContextChain = true;\n  \t\tparentValue = ractive.viewmodel.get(context);\n\n  \t\tif (parentValue && (typeof parentValue === \"object\" || typeof parentValue === \"function\") && key in parentValue) {\n  \t\t\treturn context.join(ref.str);\n  \t\t}\n  \t}\n\n  \t// Root/computed/mapped property?\n  \tif (isRootProperty(ractive.viewmodel, key)) {\n  \t\treturn ref;\n  \t}\n\n  \t// If this is an inline component, and it's not isolated, we\n  \t// can try going up the scope chain\n  \tif (ractive.parent && !ractive.isolated) {\n  \t\thasContextChain = true;\n  \t\tfragment = ractive.component.parentFragment;\n\n  \t\tkey = getKeypath(key);\n\n  \t\tif (parentKeypath = resolveAmbiguousReference(ractive.parent, key, fragment, true)) {\n  \t\t\t// We need to create an inter-component binding\n  \t\t\tractive.viewmodel.map(key, {\n  \t\t\t\torigin: ractive.parent.viewmodel,\n  \t\t\t\tkeypath: parentKeypath\n  \t\t\t});\n\n  \t\t\treturn ref;\n  \t\t}\n  \t}\n\n  \t// If there's no context chain, and the instance is either a) isolated or\n  \t// b) an orphan, then we know that the keypath is identical to the reference\n  \tif (!isParentLookup && !hasContextChain) {\n  \t\t// the data object needs to have a property by this name,\n  \t\t// to prevent future failed lookups\n  \t\tractive.viewmodel.set(ref, undefined);\n  \t\treturn ref;\n  \t}\n  }\n\n  function createMappingIfNecessary(ractive, key) {\n  \tvar parentKeypath;\n\n  \tif (!ractive.parent || ractive.isolated || isRootProperty(ractive.viewmodel, key)) {\n  \t\treturn;\n  \t}\n\n  \tkey = getKeypath(key);\n\n  \tif (parentKeypath = resolveAmbiguousReference(ractive.parent, key, ractive.component.parentFragment, true)) {\n  \t\tractive.viewmodel.map(key, {\n  \t\t\torigin: ractive.parent.viewmodel,\n  \t\t\tkeypath: parentKeypath\n  \t\t});\n  \t}\n  }\n\n  function isRootProperty(viewmodel, key) {\n  \t// special case for reference to root\n  \treturn key === \"\" || key in viewmodel.data || key in viewmodel.computations || key in viewmodel.mappings;\n  }\n\n  function teardown(x) {\n    x.teardown();\n  }\n\n  function methodCallers__unbind(x) {\n    x.unbind();\n  }\n\n  function methodCallers__unrender(x) {\n    x.unrender();\n  }\n\n  function cancel(x) {\n    x.cancel();\n  }\n\n  var TransitionManager = function (callback, parent) {\n  \tthis.callback = callback;\n  \tthis.parent = parent;\n\n  \tthis.intros = [];\n  \tthis.outros = [];\n\n  \tthis.children = [];\n  \tthis.totalChildren = this.outroChildren = 0;\n\n  \tthis.detachQueue = [];\n  \tthis.decoratorQueue = [];\n  \tthis.outrosComplete = false;\n\n  \tif (parent) {\n  \t\tparent.addChild(this);\n  \t}\n  };\n\n  TransitionManager.prototype = {\n  \taddChild: function (child) {\n  \t\tthis.children.push(child);\n\n  \t\tthis.totalChildren += 1;\n  \t\tthis.outroChildren += 1;\n  \t},\n\n  \tdecrementOutros: function () {\n  \t\tthis.outroChildren -= 1;\n  \t\tcheck(this);\n  \t},\n\n  \tdecrementTotal: function () {\n  \t\tthis.totalChildren -= 1;\n  \t\tcheck(this);\n  \t},\n\n  \tadd: function (transition) {\n  \t\tvar list = transition.isIntro ? this.intros : this.outros;\n  \t\tlist.push(transition);\n  \t},\n\n  \taddDecorator: function (decorator) {\n  \t\tthis.decoratorQueue.push(decorator);\n  \t},\n\n  \tremove: function (transition) {\n  \t\tvar list = transition.isIntro ? this.intros : this.outros;\n  \t\tremoveFromArray(list, transition);\n  \t\tcheck(this);\n  \t},\n\n  \tinit: function () {\n  \t\tthis.ready = true;\n  \t\tcheck(this);\n  \t},\n\n  \tdetachNodes: function () {\n  \t\tthis.decoratorQueue.forEach(teardown);\n  \t\tthis.detachQueue.forEach(detach);\n  \t\tthis.children.forEach(detachNodes);\n  \t}\n  };\n\n  function detach(element) {\n  \telement.detach();\n  }\n\n  function detachNodes(tm) {\n  \ttm.detachNodes();\n  }\n\n  function check(tm) {\n  \tif (!tm.ready || tm.outros.length || tm.outroChildren) return;\n\n  \t// If all outros are complete, and we haven't already done this,\n  \t// we notify the parent if there is one, otherwise\n  \t// start detaching nodes\n  \tif (!tm.outrosComplete) {\n  \t\tif (tm.parent) {\n  \t\t\ttm.parent.decrementOutros(tm);\n  \t\t} else {\n  \t\t\ttm.detachNodes();\n  \t\t}\n\n  \t\ttm.outrosComplete = true;\n  \t}\n\n  \t// Once everything is done, we can notify parent transition\n  \t// manager and call the callback\n  \tif (!tm.intros.length && !tm.totalChildren) {\n  \t\tif (typeof tm.callback === \"function\") {\n  \t\t\ttm.callback();\n  \t\t}\n\n  \t\tif (tm.parent) {\n  \t\t\ttm.parent.decrementTotal();\n  \t\t}\n  \t}\n  }\n\n  var global_TransitionManager = TransitionManager;\n\n  var batch,\n      runloop,\n      unresolved = [],\n      changeHook = new hooks_Hook(\"change\");\n\n  runloop = {\n  \tstart: function (instance, returnPromise) {\n  \t\tvar promise, fulfilPromise;\n\n  \t\tif (returnPromise) {\n  \t\t\tpromise = new utils_Promise(function (f) {\n  \t\t\t\treturn fulfilPromise = f;\n  \t\t\t});\n  \t\t}\n\n  \t\tbatch = {\n  \t\t\tpreviousBatch: batch,\n  \t\t\ttransitionManager: new global_TransitionManager(fulfilPromise, batch && batch.transitionManager),\n  \t\t\tviews: [],\n  \t\t\ttasks: [],\n  \t\t\tractives: [],\n  \t\t\tinstance: instance\n  \t\t};\n\n  \t\tif (instance) {\n  \t\t\tbatch.ractives.push(instance);\n  \t\t}\n\n  \t\treturn promise;\n  \t},\n\n  \tend: function () {\n  \t\tflushChanges();\n\n  \t\tbatch.transitionManager.init();\n  \t\tif (!batch.previousBatch && !!batch.instance) batch.instance.viewmodel.changes = [];\n  \t\tbatch = batch.previousBatch;\n  \t},\n\n  \taddRactive: function (ractive) {\n  \t\tif (batch) {\n  \t\t\taddToArray(batch.ractives, ractive);\n  \t\t}\n  \t},\n\n  \tregisterTransition: function (transition) {\n  \t\ttransition._manager = batch.transitionManager;\n  \t\tbatch.transitionManager.add(transition);\n  \t},\n\n  \tregisterDecorator: function (decorator) {\n  \t\tbatch.transitionManager.addDecorator(decorator);\n  \t},\n\n  \taddView: function (view) {\n  \t\tbatch.views.push(view);\n  \t},\n\n  \taddUnresolved: function (thing) {\n  \t\tunresolved.push(thing);\n  \t},\n\n  \tremoveUnresolved: function (thing) {\n  \t\tremoveFromArray(unresolved, thing);\n  \t},\n\n  \t// synchronise node detachments with transition ends\n  \tdetachWhenReady: function (thing) {\n  \t\tbatch.transitionManager.detachQueue.push(thing);\n  \t},\n\n  \tscheduleTask: function (task, postRender) {\n  \t\tvar _batch;\n\n  \t\tif (!batch) {\n  \t\t\ttask();\n  \t\t} else {\n  \t\t\t_batch = batch;\n  \t\t\twhile (postRender && _batch.previousBatch) {\n  \t\t\t\t// this can't happen until the DOM has been fully updated\n  \t\t\t\t// otherwise in some situations (with components inside elements)\n  \t\t\t\t// transitions and decorators will initialise prematurely\n  \t\t\t\t_batch = _batch.previousBatch;\n  \t\t\t}\n\n  \t\t\t_batch.tasks.push(task);\n  \t\t}\n  \t}\n  };\n\n  var global_runloop = runloop;\n\n  function flushChanges() {\n  \tvar i, thing, changeHash;\n\n  \twhile (batch.ractives.length) {\n  \t\tthing = batch.ractives.pop();\n  \t\tchangeHash = thing.viewmodel.applyChanges();\n\n  \t\tif (changeHash) {\n  \t\t\tchangeHook.fire(thing, changeHash);\n  \t\t}\n  \t}\n\n  \tattemptKeypathResolution();\n\n  \t// Now that changes have been fully propagated, we can update the DOM\n  \t// and complete other tasks\n  \tfor (i = 0; i < batch.views.length; i += 1) {\n  \t\tbatch.views[i].update();\n  \t}\n  \tbatch.views.length = 0;\n\n  \tfor (i = 0; i < batch.tasks.length; i += 1) {\n  \t\tbatch.tasks[i]();\n  \t}\n  \tbatch.tasks.length = 0;\n\n  \t// If updating the view caused some model blowback - e.g. a triple\n  \t// containing <option> elements caused the binding on the <select>\n  \t// to update - then we start over\n  \tif (batch.ractives.length) return flushChanges();\n  }\n\n  function attemptKeypathResolution() {\n  \tvar i, item, keypath, resolved;\n\n  \ti = unresolved.length;\n\n  \t// see if we can resolve any unresolved references\n  \twhile (i--) {\n  \t\titem = unresolved[i];\n\n  \t\tif (item.keypath) {\n  \t\t\t// it resolved some other way. TODO how? two-way binding? Seems\n  \t\t\t// weird that we'd still end up here\n  \t\t\tunresolved.splice(i, 1);\n  \t\t\tcontinue; // avoid removing the wrong thing should the next condition be true\n  \t\t}\n\n  \t\tif (keypath = shared_resolveRef(item.root, item.ref, item.parentFragment)) {\n  \t\t\t(resolved || (resolved = [])).push({\n  \t\t\t\titem: item,\n  \t\t\t\tkeypath: keypath\n  \t\t\t});\n\n  \t\t\tunresolved.splice(i, 1);\n  \t\t}\n  \t}\n\n  \tif (resolved) {\n  \t\tresolved.forEach(global_runloop__resolve);\n  \t}\n  }\n\n  function global_runloop__resolve(resolved) {\n  \tresolved.item.resolve(resolved.keypath);\n  }\n\n  var queue = [];\n\n  var animations = {\n  \ttick: function () {\n  \t\tvar i, animation, now;\n\n  \t\tnow = utils_getTime();\n\n  \t\tglobal_runloop.start();\n\n  \t\tfor (i = 0; i < queue.length; i += 1) {\n  \t\t\tanimation = queue[i];\n\n  \t\t\tif (!animation.tick(now)) {\n  \t\t\t\t// animation is complete, remove it from the stack, and decrement i so we don't miss one\n  \t\t\t\tqueue.splice(i--, 1);\n  \t\t\t}\n  \t\t}\n\n  \t\tglobal_runloop.end();\n\n  \t\tif (queue.length) {\n  \t\t\trAF(animations.tick);\n  \t\t} else {\n  \t\t\tanimations.running = false;\n  \t\t}\n  \t},\n\n  \tadd: function (animation) {\n  \t\tqueue.push(animation);\n\n  \t\tif (!animations.running) {\n  \t\t\tanimations.running = true;\n  \t\t\trAF(animations.tick);\n  \t\t}\n  \t},\n\n  \t// TODO optimise this\n  \tabort: function (keypath, root) {\n  \t\tvar i = queue.length,\n  \t\t    animation;\n\n  \t\twhile (i--) {\n  \t\t\tanimation = queue[i];\n\n  \t\t\tif (animation.root === root && animation.keypath === keypath) {\n  \t\t\t\tanimation.stop();\n  \t\t\t}\n  \t\t}\n  \t}\n  };\n\n  var shared_animations = animations;\n\n  var Animation = function (options) {\n  \tvar key;\n\n  \tthis.startTime = Date.now();\n\n  \t// from and to\n  \tfor (key in options) {\n  \t\tif (options.hasOwnProperty(key)) {\n  \t\t\tthis[key] = options[key];\n  \t\t}\n  \t}\n\n  \tthis.interpolator = shared_interpolate(this.from, this.to, this.root, this.interpolator);\n  \tthis.running = true;\n\n  \tthis.tick();\n  };\n\n  Animation.prototype = {\n  \ttick: function () {\n  \t\tvar elapsed, t, value, timeNow, index, keypath;\n\n  \t\tkeypath = this.keypath;\n\n  \t\tif (this.running) {\n  \t\t\ttimeNow = Date.now();\n  \t\t\telapsed = timeNow - this.startTime;\n\n  \t\t\tif (elapsed >= this.duration) {\n  \t\t\t\tif (keypath !== null) {\n  \t\t\t\t\tglobal_runloop.start(this.root);\n  \t\t\t\t\tthis.root.viewmodel.set(keypath, this.to);\n  \t\t\t\t\tglobal_runloop.end();\n  \t\t\t\t}\n\n  \t\t\t\tif (this.step) {\n  \t\t\t\t\tthis.step(1, this.to);\n  \t\t\t\t}\n\n  \t\t\t\tthis.complete(this.to);\n\n  \t\t\t\tindex = this.root._animations.indexOf(this);\n\n  \t\t\t\t// TODO investigate why this happens\n  \t\t\t\tif (index === -1) {\n  \t\t\t\t\twarnIfDebug(\"Animation was not found\");\n  \t\t\t\t}\n\n  \t\t\t\tthis.root._animations.splice(index, 1);\n\n  \t\t\t\tthis.running = false;\n  \t\t\t\treturn false; // remove from the stack\n  \t\t\t}\n\n  \t\t\tt = this.easing ? this.easing(elapsed / this.duration) : elapsed / this.duration;\n\n  \t\t\tif (keypath !== null) {\n  \t\t\t\tvalue = this.interpolator(t);\n  \t\t\t\tglobal_runloop.start(this.root);\n  \t\t\t\tthis.root.viewmodel.set(keypath, value);\n  \t\t\t\tglobal_runloop.end();\n  \t\t\t}\n\n  \t\t\tif (this.step) {\n  \t\t\t\tthis.step(t, value);\n  \t\t\t}\n\n  \t\t\treturn true; // keep in the stack\n  \t\t}\n\n  \t\treturn false; // remove from the stack\n  \t},\n\n  \tstop: function () {\n  \t\tvar index;\n\n  \t\tthis.running = false;\n\n  \t\tindex = this.root._animations.indexOf(this);\n\n  \t\t// TODO investigate why this happens\n  \t\tif (index === -1) {\n  \t\t\twarnIfDebug(\"Animation was not found\");\n  \t\t}\n\n  \t\tthis.root._animations.splice(index, 1);\n  \t}\n  };\n\n  var animate_Animation = Animation;\n\n  var prototype_animate = Ractive$animate;\n\n  var noAnimation = { stop: noop };\n  function Ractive$animate(keypath, to, options) {\n  \tvar promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;\n\n  \tpromise = new utils_Promise(function (fulfil) {\n  \t\treturn fulfilPromise = fulfil;\n  \t});\n\n  \t// animate multiple keypaths\n  \tif (typeof keypath === \"object\") {\n  \t\toptions = to || {};\n  \t\teasing = options.easing;\n  \t\tduration = options.duration;\n\n  \t\tanimations = [];\n\n  \t\t// we don't want to pass the `step` and `complete` handlers, as they will\n  \t\t// run for each animation! So instead we'll store the handlers and create\n  \t\t// our own...\n  \t\tstep = options.step;\n  \t\tcomplete = options.complete;\n\n  \t\tif (step || complete) {\n  \t\t\tcurrentValues = {};\n\n  \t\t\toptions.step = null;\n  \t\t\toptions.complete = null;\n\n  \t\t\tmakeValueCollector = function (keypath) {\n  \t\t\t\treturn function (t, value) {\n  \t\t\t\t\tcurrentValues[keypath] = value;\n  \t\t\t\t};\n  \t\t\t};\n  \t\t}\n\n  \t\tfor (k in keypath) {\n  \t\t\tif (keypath.hasOwnProperty(k)) {\n  \t\t\t\tif (step || complete) {\n  \t\t\t\t\tcollectValue = makeValueCollector(k);\n  \t\t\t\t\toptions = { easing: easing, duration: duration };\n\n  \t\t\t\t\tif (step) {\n  \t\t\t\t\t\toptions.step = collectValue;\n  \t\t\t\t\t}\n  \t\t\t\t}\n\n  \t\t\t\toptions.complete = complete ? collectValue : noop;\n  \t\t\t\tanimations.push(animate(this, k, keypath[k], options));\n  \t\t\t}\n  \t\t}\n\n  \t\t// Create a dummy animation, to facilitate step/complete\n  \t\t// callbacks, and Promise fulfilment\n  \t\tdummyOptions = { easing: easing, duration: duration };\n\n  \t\tif (step) {\n  \t\t\tdummyOptions.step = function (t) {\n  \t\t\t\treturn step(t, currentValues);\n  \t\t\t};\n  \t\t}\n\n  \t\tif (complete) {\n  \t\t\tpromise.then(function (t) {\n  \t\t\t\treturn complete(t, currentValues);\n  \t\t\t});\n  \t\t}\n\n  \t\tdummyOptions.complete = fulfilPromise;\n\n  \t\tdummy = animate(this, null, null, dummyOptions);\n  \t\tanimations.push(dummy);\n\n  \t\tpromise.stop = function () {\n  \t\t\tvar animation;\n\n  \t\t\twhile (animation = animations.pop()) {\n  \t\t\t\tanimation.stop();\n  \t\t\t}\n\n  \t\t\tif (dummy) {\n  \t\t\t\tdummy.stop();\n  \t\t\t}\n  \t\t};\n\n  \t\treturn promise;\n  \t}\n\n  \t// animate a single keypath\n  \toptions = options || {};\n\n  \tif (options.complete) {\n  \t\tpromise.then(options.complete);\n  \t}\n\n  \toptions.complete = fulfilPromise;\n  \tanimation = animate(this, keypath, to, options);\n\n  \tpromise.stop = function () {\n  \t\treturn animation.stop();\n  \t};\n  \treturn promise;\n  }\n\n  function animate(root, keypath, to, options) {\n  \tvar easing, duration, animation, from;\n\n  \tif (keypath) {\n  \t\tkeypath = getKeypath(normalise(keypath));\n  \t}\n\n  \tif (keypath !== null) {\n  \t\tfrom = root.viewmodel.get(keypath);\n  \t}\n\n  \t// cancel any existing animation\n  \t// TODO what about upstream/downstream keypaths?\n  \tshared_animations.abort(keypath, root);\n\n  \t// don't bother animating values that stay the same\n  \tif (isEqual(from, to)) {\n  \t\tif (options.complete) {\n  \t\t\toptions.complete(options.to);\n  \t\t}\n\n  \t\treturn noAnimation;\n  \t}\n\n  \t// easing function\n  \tif (options.easing) {\n  \t\tif (typeof options.easing === \"function\") {\n  \t\t\teasing = options.easing;\n  \t\t} else {\n  \t\t\teasing = root.easing[options.easing];\n  \t\t}\n\n  \t\tif (typeof easing !== \"function\") {\n  \t\t\teasing = null;\n  \t\t}\n  \t}\n\n  \t// duration\n  \tduration = options.duration === undefined ? 400 : options.duration;\n\n  \t// TODO store keys, use an internal set method\n  \tanimation = new animate_Animation({\n  \t\tkeypath: keypath,\n  \t\tfrom: from,\n  \t\tto: to,\n  \t\troot: root,\n  \t\tduration: duration,\n  \t\teasing: easing,\n  \t\tinterpolator: options.interpolator,\n\n  \t\t// TODO wrap callbacks if necessary, to use instance as context\n  \t\tstep: options.step,\n  \t\tcomplete: options.complete\n  \t});\n\n  \tshared_animations.add(animation);\n  \troot._animations.push(animation);\n\n  \treturn animation;\n  }\n\n  var prototype_detach = Ractive$detach;\n  var prototype_detach__detachHook = new hooks_Hook(\"detach\");\n  function Ractive$detach() {\n  \tif (this.detached) {\n  \t\treturn this.detached;\n  \t}\n\n  \tif (this.el) {\n  \t\tremoveFromArray(this.el.__ractive_instances__, this);\n  \t}\n  \tthis.detached = this.fragment.detach();\n  \tprototype_detach__detachHook.fire(this);\n  \treturn this.detached;\n  }\n\n  var prototype_find = Ractive$find;\n\n  function Ractive$find(selector) {\n  \tif (!this.el) {\n  \t\treturn null;\n  \t}\n\n  \treturn this.fragment.find(selector);\n  }\n\n  var test = Query$test;\n  function Query$test(item, noDirty) {\n  \tvar itemMatches;\n\n  \tif (this._isComponentQuery) {\n  \t\titemMatches = !this.selector || item.name === this.selector;\n  \t} else {\n  \t\titemMatches = item.node ? matches(item.node, this.selector) : null;\n  \t}\n\n  \tif (itemMatches) {\n  \t\tthis.push(item.node || item.instance);\n\n  \t\tif (!noDirty) {\n  \t\t\tthis._makeDirty();\n  \t\t}\n\n  \t\treturn true;\n  \t}\n  }\n\n  var makeQuery_cancel = function () {\n  \tvar liveQueries, selector, index;\n\n  \tliveQueries = this._root[this._isComponentQuery ? \"liveComponentQueries\" : \"liveQueries\"];\n  \tselector = this.selector;\n\n  \tindex = liveQueries.indexOf(selector);\n\n  \tif (index !== -1) {\n  \t\tliveQueries.splice(index, 1);\n  \t\tliveQueries[selector] = null;\n  \t}\n  };\n\n  var sortByItemPosition = function (a, b) {\n  \tvar ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;\n\n  \tancestryA = getAncestry(a.component || a._ractive.proxy);\n  \tancestryB = getAncestry(b.component || b._ractive.proxy);\n\n  \toldestA = lastItem(ancestryA);\n  \toldestB = lastItem(ancestryB);\n\n  \t// remove items from the end of both ancestries as long as they are identical\n  \t// - the final one removed is the closest mutual ancestor\n  \twhile (oldestA && oldestA === oldestB) {\n  \t\tancestryA.pop();\n  \t\tancestryB.pop();\n\n  \t\tmutualAncestor = oldestA;\n\n  \t\toldestA = lastItem(ancestryA);\n  \t\toldestB = lastItem(ancestryB);\n  \t}\n\n  \t// now that we have the mutual ancestor, we can find which is earliest\n  \toldestA = oldestA.component || oldestA;\n  \toldestB = oldestB.component || oldestB;\n\n  \tfragmentA = oldestA.parentFragment;\n  \tfragmentB = oldestB.parentFragment;\n\n  \t// if both items share a parent fragment, our job is easy\n  \tif (fragmentA === fragmentB) {\n  \t\tindexA = fragmentA.items.indexOf(oldestA);\n  \t\tindexB = fragmentB.items.indexOf(oldestB);\n\n  \t\t// if it's the same index, it means one contains the other,\n  \t\t// so we see which has the longest ancestry\n  \t\treturn indexA - indexB || ancestryA.length - ancestryB.length;\n  \t}\n\n  \t// if mutual ancestor is a section, we first test to see which section\n  \t// fragment comes first\n  \tif (fragments = mutualAncestor.fragments) {\n  \t\tindexA = fragments.indexOf(fragmentA);\n  \t\tindexB = fragments.indexOf(fragmentB);\n\n  \t\treturn indexA - indexB || ancestryA.length - ancestryB.length;\n  \t}\n\n  \tthrow new Error(\"An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!\");\n  };\n\n  function getParent(item) {\n  \tvar parentFragment;\n\n  \tif (parentFragment = item.parentFragment) {\n  \t\treturn parentFragment.owner;\n  \t}\n\n  \tif (item.component && (parentFragment = item.component.parentFragment)) {\n  \t\treturn parentFragment.owner;\n  \t}\n  }\n\n  function getAncestry(item) {\n  \tvar ancestry, ancestor;\n\n  \tancestry = [item];\n\n  \tancestor = getParent(item);\n\n  \twhile (ancestor) {\n  \t\tancestry.push(ancestor);\n  \t\tancestor = getParent(ancestor);\n  \t}\n\n  \treturn ancestry;\n  }\n\n  var sortByDocumentPosition = function (node, otherNode) {\n  \tvar bitmask;\n\n  \tif (node.compareDocumentPosition) {\n  \t\tbitmask = node.compareDocumentPosition(otherNode);\n  \t\treturn bitmask & 2 ? 1 : -1;\n  \t}\n\n  \t// In old IE, we can piggy back on the mechanism for\n  \t// comparing component positions\n  \treturn sortByItemPosition(node, otherNode);\n  };\n\n  var sort = function () {\n  \tthis.sort(this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition);\n  \tthis._dirty = false;\n  };\n\n  var makeQuery_dirty = function () {\n  \tvar _this = this;\n\n  \tif (!this._dirty) {\n  \t\tthis._dirty = true;\n\n  \t\t// Once the DOM has been updated, ensure the query\n  \t\t// is correctly ordered\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\t_this._sort();\n  \t\t});\n  \t}\n  };\n\n  var remove = function (nodeOrComponent) {\n  \tvar index = this.indexOf(this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent);\n\n  \tif (index !== -1) {\n  \t\tthis.splice(index, 1);\n  \t}\n  };\n\n  var _makeQuery = makeQuery;\n  function makeQuery(ractive, selector, live, isComponentQuery) {\n  \tvar query = [];\n\n  \tdefineProperties(query, {\n  \t\tselector: { value: selector },\n  \t\tlive: { value: live },\n\n  \t\t_isComponentQuery: { value: isComponentQuery },\n  \t\t_test: { value: test }\n  \t});\n\n  \tif (!live) {\n  \t\treturn query;\n  \t}\n\n  \tdefineProperties(query, {\n  \t\tcancel: { value: makeQuery_cancel },\n\n  \t\t_root: { value: ractive },\n  \t\t_sort: { value: sort },\n  \t\t_makeDirty: { value: makeQuery_dirty },\n  \t\t_remove: { value: remove },\n\n  \t\t_dirty: { value: false, writable: true }\n  \t});\n\n  \treturn query;\n  }\n\n  var prototype_findAll = Ractive$findAll;\n  function Ractive$findAll(selector, options) {\n  \tvar liveQueries, query;\n\n  \tif (!this.el) {\n  \t\treturn [];\n  \t}\n\n  \toptions = options || {};\n  \tliveQueries = this._liveQueries;\n\n  \t// Shortcut: if we're maintaining a live query with this\n  \t// selector, we don't need to traverse the parallel DOM\n  \tif (query = liveQueries[selector]) {\n\n  \t\t// Either return the exact same query, or (if not live) a snapshot\n  \t\treturn options && options.live ? query : query.slice();\n  \t}\n\n  \tquery = _makeQuery(this, selector, !!options.live, false);\n\n  \t// Add this to the list of live queries Ractive needs to maintain,\n  \t// if applicable\n  \tif (query.live) {\n  \t\tliveQueries.push(selector);\n  \t\tliveQueries[\"_\" + selector] = query;\n  \t}\n\n  \tthis.fragment.findAll(selector, query);\n  \treturn query;\n  }\n\n  var prototype_findAllComponents = Ractive$findAllComponents;\n  function Ractive$findAllComponents(selector, options) {\n  \tvar liveQueries, query;\n\n  \toptions = options || {};\n  \tliveQueries = this._liveComponentQueries;\n\n  \t// Shortcut: if we're maintaining a live query with this\n  \t// selector, we don't need to traverse the parallel DOM\n  \tif (query = liveQueries[selector]) {\n\n  \t\t// Either return the exact same query, or (if not live) a snapshot\n  \t\treturn options && options.live ? query : query.slice();\n  \t}\n\n  \tquery = _makeQuery(this, selector, !!options.live, true);\n\n  \t// Add this to the list of live queries Ractive needs to maintain,\n  \t// if applicable\n  \tif (query.live) {\n  \t\tliveQueries.push(selector);\n  \t\tliveQueries[\"_\" + selector] = query;\n  \t}\n\n  \tthis.fragment.findAllComponents(selector, query);\n  \treturn query;\n  }\n\n  var prototype_findComponent = Ractive$findComponent;\n\n  function Ractive$findComponent(selector) {\n  \treturn this.fragment.findComponent(selector);\n  }\n\n  var findContainer = Ractive$findContainer;\n\n  function Ractive$findContainer(selector) {\n  \tif (this.container) {\n  \t\tif (this.container.component && this.container.component.name === selector) {\n  \t\t\treturn this.container;\n  \t\t} else {\n  \t\t\treturn this.container.findContainer(selector);\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  var findParent = Ractive$findParent;\n\n  function Ractive$findParent(selector) {\n\n  \tif (this.parent) {\n  \t\tif (this.parent.component && this.parent.component.name === selector) {\n  \t\t\treturn this.parent;\n  \t\t} else {\n  \t\t\treturn this.parent.findParent(selector);\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  var eventStack = {\n  \tenqueue: function (ractive, event) {\n  \t\tif (ractive.event) {\n  \t\t\tractive._eventQueue = ractive._eventQueue || [];\n  \t\t\tractive._eventQueue.push(ractive.event);\n  \t\t}\n  \t\tractive.event = event;\n  \t},\n  \tdequeue: function (ractive) {\n  \t\tif (ractive._eventQueue && ractive._eventQueue.length) {\n  \t\t\tractive.event = ractive._eventQueue.pop();\n  \t\t} else {\n  \t\t\tdelete ractive.event;\n  \t\t}\n  \t}\n  };\n\n  var shared_eventStack = eventStack;\n\n  var shared_fireEvent = fireEvent;\n\n  function fireEvent(ractive, eventName) {\n  \tvar options = arguments[2] === undefined ? {} : arguments[2];\n\n  \tif (!eventName) {\n  \t\treturn;\n  \t}\n\n  \tif (!options.event) {\n  \t\toptions.event = {\n  \t\t\tname: eventName,\n  \t\t\t// until event not included as argument default\n  \t\t\t_noArg: true\n  \t\t};\n  \t} else {\n  \t\toptions.event.name = eventName;\n  \t}\n\n  \tvar eventNames = getKeypath(eventName).wildcardMatches();\n  \tfireEventAs(ractive, eventNames, options.event, options.args, true);\n  }\n\n  function fireEventAs(ractive, eventNames, event, args) {\n  \tvar initialFire = arguments[4] === undefined ? false : arguments[4];\n\n  \tvar subscribers,\n  \t    i,\n  \t    bubble = true;\n\n  \tshared_eventStack.enqueue(ractive, event);\n\n  \tfor (i = eventNames.length; i >= 0; i--) {\n  \t\tsubscribers = ractive._subs[eventNames[i]];\n\n  \t\tif (subscribers) {\n  \t\t\tbubble = notifySubscribers(ractive, subscribers, event, args) && bubble;\n  \t\t}\n  \t}\n\n  \tshared_eventStack.dequeue(ractive);\n\n  \tif (ractive.parent && bubble) {\n\n  \t\tif (initialFire && ractive.component) {\n  \t\t\tvar fullName = ractive.component.name + \".\" + eventNames[eventNames.length - 1];\n  \t\t\teventNames = getKeypath(fullName).wildcardMatches();\n\n  \t\t\tif (event) {\n  \t\t\t\tevent.component = ractive;\n  \t\t\t}\n  \t\t}\n\n  \t\tfireEventAs(ractive.parent, eventNames, event, args);\n  \t}\n  }\n\n  function notifySubscribers(ractive, subscribers, event, args) {\n  \tvar originalEvent = null,\n  \t    stopEvent = false;\n\n  \tif (event && !event._noArg) {\n  \t\targs = [event].concat(args);\n  \t}\n\n  \t// subscribers can be modified inflight, e.g. \"once\" functionality\n  \t// so we need to copy to make sure everyone gets called\n  \tsubscribers = subscribers.slice();\n\n  \tfor (var i = 0, len = subscribers.length; i < len; i += 1) {\n  \t\tif (subscribers[i].apply(ractive, args) === false) {\n  \t\t\tstopEvent = true;\n  \t\t}\n  \t}\n\n  \tif (event && !event._noArg && stopEvent && (originalEvent = event.original)) {\n  \t\toriginalEvent.preventDefault && originalEvent.preventDefault();\n  \t\toriginalEvent.stopPropagation && originalEvent.stopPropagation();\n  \t}\n\n  \treturn !stopEvent;\n  }\n\n  var prototype_fire = Ractive$fire;\n  function Ractive$fire(eventName) {\n\n  \tvar options = {\n  \t\targs: Array.prototype.slice.call(arguments, 1)\n  \t};\n\n  \tshared_fireEvent(this, eventName, options);\n  }\n\n  var prototype_get = Ractive$get;\n  var options = {\n  \tcapture: true, // top-level calls should be intercepted\n  \tnoUnwrap: true, // wrapped values should NOT be unwrapped\n  \tfullRootGet: true // root get should return mappings\n  };\n  function Ractive$get(keypath) {\n  \tvar value;\n\n  \tkeypath = getKeypath(normalise(keypath));\n  \tvalue = this.viewmodel.get(keypath, options);\n\n  \t// Create inter-component binding, if necessary\n  \tif (value === undefined && this.parent && !this.isolated) {\n  \t\tif (shared_resolveRef(this, keypath.str, this.component.parentFragment)) {\n  \t\t\t// creates binding as side-effect, if appropriate\n  \t\t\tvalue = this.viewmodel.get(keypath);\n  \t\t}\n  \t}\n\n  \treturn value;\n  }\n\n  var insert = Ractive$insert;\n\n  var insertHook = new hooks_Hook(\"insert\");\n  function Ractive$insert(target, anchor) {\n  \tif (!this.fragment.rendered) {\n  \t\t// TODO create, and link to, documentation explaining this\n  \t\tthrow new Error(\"The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.\");\n  \t}\n\n  \ttarget = getElement(target);\n  \tanchor = getElement(anchor) || null;\n\n  \tif (!target) {\n  \t\tthrow new Error(\"You must specify a valid target to insert into\");\n  \t}\n\n  \ttarget.insertBefore(this.detach(), anchor);\n  \tthis.el = target;\n\n  \t(target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);\n  \tthis.detached = null;\n\n  \tfireInsertHook(this);\n  }\n\n  function fireInsertHook(ractive) {\n  \tinsertHook.fire(ractive);\n\n  \tractive.findAllComponents(\"*\").forEach(function (child) {\n  \t\tfireInsertHook(child.instance);\n  \t});\n  }\n\n  var prototype_merge = Ractive$merge;\n  function Ractive$merge(keypath, array, options) {\n  \tvar currentArray, promise;\n\n  \tkeypath = getKeypath(normalise(keypath));\n  \tcurrentArray = this.viewmodel.get(keypath);\n\n  \t// If either the existing value or the new value isn't an\n  \t// array, just do a regular set\n  \tif (!isArray(currentArray) || !isArray(array)) {\n  \t\treturn this.set(keypath, array, options && options.complete);\n  \t}\n\n  \t// Manage transitions\n  \tpromise = global_runloop.start(this, true);\n  \tthis.viewmodel.merge(keypath, currentArray, array, options);\n  \tglobal_runloop.end();\n\n  \treturn promise;\n  }\n\n  var Observer = function (ractive, keypath, callback, options) {\n  \tthis.root = ractive;\n  \tthis.keypath = keypath;\n  \tthis.callback = callback;\n  \tthis.defer = options.defer;\n\n  \t// default to root as context, but allow it to be overridden\n  \tthis.context = options && options.context ? options.context : ractive;\n  };\n\n  Observer.prototype = {\n  \tinit: function (immediate) {\n  \t\tthis.value = this.root.get(this.keypath.str);\n\n  \t\tif (immediate !== false) {\n  \t\t\tthis.update();\n  \t\t} else {\n  \t\t\tthis.oldValue = this.value;\n  \t\t}\n  \t},\n\n  \tsetValue: function (value) {\n  \t\tvar _this = this;\n\n  \t\tif (!isEqual(value, this.value)) {\n  \t\t\tthis.value = value;\n\n  \t\t\tif (this.defer && this.ready) {\n  \t\t\t\tglobal_runloop.scheduleTask(function () {\n  \t\t\t\t\treturn _this.update();\n  \t\t\t\t});\n  \t\t\t} else {\n  \t\t\t\tthis.update();\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tupdate: function () {\n  \t\t// Prevent infinite loops\n  \t\tif (this.updating) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.updating = true;\n\n  \t\tthis.callback.call(this.context, this.value, this.oldValue, this.keypath.str);\n  \t\tthis.oldValue = this.value;\n\n  \t\tthis.updating = false;\n  \t}\n  };\n\n  var observe_Observer = Observer;\n\n  var observe_getPattern = getPattern;\n  function getPattern(ractive, pattern) {\n  \tvar matchingKeypaths, values;\n\n  \tmatchingKeypaths = getMatchingKeypaths(ractive, pattern);\n\n  \tvalues = {};\n  \tmatchingKeypaths.forEach(function (keypath) {\n  \t\tvalues[keypath.str] = ractive.get(keypath.str);\n  \t});\n\n  \treturn values;\n  }\n\n  var PatternObserver,\n      slice = Array.prototype.slice;\n\n  PatternObserver = function (ractive, keypath, callback, options) {\n  \tthis.root = ractive;\n\n  \tthis.callback = callback;\n  \tthis.defer = options.defer;\n\n  \tthis.keypath = keypath;\n  \tthis.regex = new RegExp(\"^\" + keypath.str.replace(/\\./g, \"\\\\.\").replace(/\\*/g, \"([^\\\\.]+)\") + \"$\");\n  \tthis.values = {};\n\n  \tif (this.defer) {\n  \t\tthis.proxies = [];\n  \t}\n\n  \t// default to root as context, but allow it to be overridden\n  \tthis.context = options && options.context ? options.context : ractive;\n  };\n\n  PatternObserver.prototype = {\n  \tinit: function (immediate) {\n  \t\tvar values, keypath;\n\n  \t\tvalues = observe_getPattern(this.root, this.keypath);\n\n  \t\tif (immediate !== false) {\n  \t\t\tfor (keypath in values) {\n  \t\t\t\tif (values.hasOwnProperty(keypath)) {\n  \t\t\t\t\tthis.update(getKeypath(keypath));\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else {\n  \t\t\tthis.values = values;\n  \t\t}\n  \t},\n\n  \tupdate: function (keypath) {\n  \t\tvar _this = this;\n\n  \t\tvar values;\n\n  \t\tif (keypath.isPattern) {\n  \t\t\tvalues = observe_getPattern(this.root, keypath);\n\n  \t\t\tfor (keypath in values) {\n  \t\t\t\tif (values.hasOwnProperty(keypath)) {\n  \t\t\t\t\tthis.update(getKeypath(keypath));\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// special case - array mutation should not trigger `array.*`\n  \t\t// pattern observer with `array.length`\n  \t\tif (this.root.viewmodel.implicitChanges[keypath.str]) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (this.defer && this.ready) {\n  \t\t\tglobal_runloop.scheduleTask(function () {\n  \t\t\t\treturn _this.getProxy(keypath).update();\n  \t\t\t});\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.reallyUpdate(keypath);\n  \t},\n\n  \treallyUpdate: function (keypath) {\n  \t\tvar keypathStr, value, keys, args;\n\n  \t\tkeypathStr = keypath.str;\n  \t\tvalue = this.root.viewmodel.get(keypath);\n\n  \t\t// Prevent infinite loops\n  \t\tif (this.updating) {\n  \t\t\tthis.values[keypathStr] = value;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.updating = true;\n\n  \t\tif (!isEqual(value, this.values[keypathStr]) || !this.ready) {\n  \t\t\tkeys = slice.call(this.regex.exec(keypathStr), 1);\n  \t\t\targs = [value, this.values[keypathStr], keypathStr].concat(keys);\n\n  \t\t\tthis.values[keypathStr] = value;\n  \t\t\tthis.callback.apply(this.context, args);\n  \t\t}\n\n  \t\tthis.updating = false;\n  \t},\n\n  \tgetProxy: function (keypath) {\n  \t\tvar _this = this;\n\n  \t\tif (!this.proxies[keypath.str]) {\n  \t\t\tthis.proxies[keypath.str] = {\n  \t\t\t\tupdate: function () {\n  \t\t\t\t\treturn _this.reallyUpdate(keypath);\n  \t\t\t\t}\n  \t\t\t};\n  \t\t}\n\n  \t\treturn this.proxies[keypath.str];\n  \t}\n  };\n\n  var observe_PatternObserver = PatternObserver;\n\n  var observe_getObserverFacade = getObserverFacade;\n  var emptyObject = {};\n  function getObserverFacade(ractive, keypath, callback, options) {\n  \tvar observer, isPatternObserver, cancelled;\n\n  \tkeypath = getKeypath(normalise(keypath));\n  \toptions = options || emptyObject;\n\n  \t// pattern observers are treated differently\n  \tif (keypath.isPattern) {\n  \t\tobserver = new observe_PatternObserver(ractive, keypath, callback, options);\n  \t\tractive.viewmodel.patternObservers.push(observer);\n  \t\tisPatternObserver = true;\n  \t} else {\n  \t\tobserver = new observe_Observer(ractive, keypath, callback, options);\n  \t}\n\n  \tobserver.init(options.init);\n  \tractive.viewmodel.register(keypath, observer, isPatternObserver ? \"patternObservers\" : \"observers\");\n\n  \t// This flag allows observers to initialise even with undefined values\n  \tobserver.ready = true;\n\n  \tvar facade = {\n  \t\tcancel: function () {\n  \t\t\tvar index;\n\n  \t\t\tif (cancelled) {\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tif (isPatternObserver) {\n  \t\t\t\tindex = ractive.viewmodel.patternObservers.indexOf(observer);\n\n  \t\t\t\tractive.viewmodel.patternObservers.splice(index, 1);\n  \t\t\t\tractive.viewmodel.unregister(keypath, observer, \"patternObservers\");\n  \t\t\t} else {\n  \t\t\t\tractive.viewmodel.unregister(keypath, observer, \"observers\");\n  \t\t\t}\n  \t\t\tcancelled = true;\n  \t\t}\n  \t};\n\n  \tractive._observers.push(facade);\n  \treturn facade;\n  }\n\n  var observe = Ractive$observe;\n  function Ractive$observe(keypath, callback, options) {\n\n  \tvar observers, map, keypaths, i;\n\n  \t// Allow a map of keypaths to handlers\n  \tif (isObject(keypath)) {\n  \t\toptions = callback;\n  \t\tmap = keypath;\n\n  \t\tobservers = [];\n\n  \t\tfor (keypath in map) {\n  \t\t\tif (map.hasOwnProperty(keypath)) {\n  \t\t\t\tcallback = map[keypath];\n  \t\t\t\tobservers.push(this.observe(keypath, callback, options));\n  \t\t\t}\n  \t\t}\n\n  \t\treturn {\n  \t\t\tcancel: function () {\n  \t\t\t\twhile (observers.length) {\n  \t\t\t\t\tobservers.pop().cancel();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t};\n  \t}\n\n  \t// Allow `ractive.observe( callback )` - i.e. observe entire model\n  \tif (typeof keypath === \"function\") {\n  \t\toptions = callback;\n  \t\tcallback = keypath;\n  \t\tkeypath = \"\";\n\n  \t\treturn observe_getObserverFacade(this, keypath, callback, options);\n  \t}\n\n  \tkeypaths = keypath.split(\" \");\n\n  \t// Single keypath\n  \tif (keypaths.length === 1) {\n  \t\treturn observe_getObserverFacade(this, keypath, callback, options);\n  \t}\n\n  \t// Multiple space-separated keypaths\n  \tobservers = [];\n\n  \ti = keypaths.length;\n  \twhile (i--) {\n  \t\tkeypath = keypaths[i];\n\n  \t\tif (keypath) {\n  \t\t\tobservers.push(observe_getObserverFacade(this, keypath, callback, options));\n  \t\t}\n  \t}\n\n  \treturn {\n  \t\tcancel: function () {\n  \t\t\twhile (observers.length) {\n  \t\t\t\tobservers.pop().cancel();\n  \t\t\t}\n  \t\t}\n  \t};\n  }\n\n  var observeOnce = Ractive$observeOnce;\n\n  function Ractive$observeOnce(property, callback, options) {\n\n  \tvar observer = this.observe(property, function () {\n  \t\tcallback.apply(this, arguments);\n  \t\tobserver.cancel();\n  \t}, { init: false, defer: options && options.defer });\n\n  \treturn observer;\n  }\n\n  var shared_trim = function (str) {\n    return str.trim();\n  };\n\n  var notEmptyString = function (str) {\n    return str !== \"\";\n  };\n\n  var off = Ractive$off;\n  function Ractive$off(eventName, callback) {\n  \tvar _this = this;\n\n  \tvar eventNames;\n\n  \t// if no arguments specified, remove all callbacks\n  \tif (!eventName) {\n  \t\t// TODO use this code instead, once the following issue has been resolved\n  \t\t// in PhantomJS (tests are unpassable otherwise!)\n  \t\t// https://github.com/ariya/phantomjs/issues/11856\n  \t\t// defineProperty( this, '_subs', { value: create( null ), configurable: true });\n  \t\tfor (eventName in this._subs) {\n  \t\t\tdelete this._subs[eventName];\n  \t\t}\n  \t} else {\n  \t\t// Handle multiple space-separated event names\n  \t\teventNames = eventName.split(\" \").map(shared_trim).filter(notEmptyString);\n\n  \t\teventNames.forEach(function (eventName) {\n  \t\t\tvar subscribers, index;\n\n  \t\t\t// If we have subscribers for this event...\n  \t\t\tif (subscribers = _this._subs[eventName]) {\n  \t\t\t\t// ...if a callback was specified, only remove that\n  \t\t\t\tif (callback) {\n  \t\t\t\t\tindex = subscribers.indexOf(callback);\n  \t\t\t\t\tif (index !== -1) {\n  \t\t\t\t\t\tsubscribers.splice(index, 1);\n  \t\t\t\t\t}\n  \t\t\t\t}\n\n  \t\t\t\t// ...otherwise remove all callbacks\n  \t\t\t\telse {\n  \t\t\t\t\t_this._subs[eventName] = [];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t});\n  \t}\n\n  \treturn this;\n  }\n\n  var on = Ractive$on;\n  function Ractive$on(eventName, callback) {\n  \tvar _this = this;\n\n  \tvar listeners, n, eventNames;\n\n  \t// allow mutliple listeners to be bound in one go\n  \tif (typeof eventName === \"object\") {\n  \t\tlisteners = [];\n\n  \t\tfor (n in eventName) {\n  \t\t\tif (eventName.hasOwnProperty(n)) {\n  \t\t\t\tlisteners.push(this.on(n, eventName[n]));\n  \t\t\t}\n  \t\t}\n\n  \t\treturn {\n  \t\t\tcancel: function () {\n  \t\t\t\tvar listener;\n\n  \t\t\t\twhile (listener = listeners.pop()) {\n  \t\t\t\t\tlistener.cancel();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t};\n  \t}\n\n  \t// Handle multiple space-separated event names\n  \teventNames = eventName.split(\" \").map(shared_trim).filter(notEmptyString);\n\n  \teventNames.forEach(function (eventName) {\n  \t\t(_this._subs[eventName] || (_this._subs[eventName] = [])).push(callback);\n  \t});\n\n  \treturn {\n  \t\tcancel: function () {\n  \t\t\treturn _this.off(eventName, callback);\n  \t\t}\n  \t};\n  }\n\n  var once = Ractive$once;\n\n  function Ractive$once(eventName, handler) {\n\n  \tvar listener = this.on(eventName, function () {\n  \t\thandler.apply(this, arguments);\n  \t\tlistener.cancel();\n  \t});\n\n  \t// so we can still do listener.cancel() manually\n  \treturn listener;\n  }\n\n  // This function takes an array, the name of a mutator method, and the\n  // arguments to call that mutator method with, and returns an array that\n  // maps the old indices to their new indices.\n\n  // So if you had something like this...\n  //\n  //     array = [ 'a', 'b', 'c', 'd' ];\n  //     array.push( 'e' );\n  //\n  // ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n  // have changed. If you then did this...\n  //\n  //     array.unshift( 'z' );\n  //\n  // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n  // one higher to make room for the 'z'. If you removed an item, the new index\n  // would be -1...\n  //\n  //     array.splice( 2, 2 );\n  //\n  // ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n  //\n  // This information is used to enable fast, non-destructive shuffling of list\n  // sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\n  var shared_getNewIndices = getNewIndices;\n\n  function getNewIndices(array, methodName, args) {\n  \tvar spliceArguments,\n  \t    len,\n  \t    newIndices = [],\n  \t    removeStart,\n  \t    removeEnd,\n  \t    balance,\n  \t    i;\n\n  \tspliceArguments = getSpliceEquivalent(array, methodName, args);\n\n  \tif (!spliceArguments) {\n  \t\treturn null; // TODO support reverse and sort?\n  \t}\n\n  \tlen = array.length;\n  \tbalance = spliceArguments.length - 2 - spliceArguments[1];\n\n  \tremoveStart = Math.min(len, spliceArguments[0]);\n  \tremoveEnd = removeStart + spliceArguments[1];\n\n  \tfor (i = 0; i < removeStart; i += 1) {\n  \t\tnewIndices.push(i);\n  \t}\n\n  \tfor (; i < removeEnd; i += 1) {\n  \t\tnewIndices.push(-1);\n  \t}\n\n  \tfor (; i < len; i += 1) {\n  \t\tnewIndices.push(i + balance);\n  \t}\n\n  \t// there is a net shift for the rest of the array starting with index + balance\n  \tif (balance !== 0) {\n  \t\tnewIndices.touchedFrom = spliceArguments[0];\n  \t} else {\n  \t\tnewIndices.touchedFrom = array.length;\n  \t}\n\n  \treturn newIndices;\n  }\n\n  // The pop, push, shift an unshift methods can all be represented\n  // as an equivalent splice\n  function getSpliceEquivalent(array, methodName, args) {\n  \tswitch (methodName) {\n  \t\tcase \"splice\":\n  \t\t\tif (args[0] !== undefined && args[0] < 0) {\n  \t\t\t\targs[0] = array.length + Math.max(args[0], -array.length);\n  \t\t\t}\n\n  \t\t\twhile (args.length < 2) {\n  \t\t\t\targs.push(0);\n  \t\t\t}\n\n  \t\t\t// ensure we only remove elements that exist\n  \t\t\targs[1] = Math.min(args[1], array.length - args[0]);\n\n  \t\t\treturn args;\n\n  \t\tcase \"sort\":\n  \t\tcase \"reverse\":\n  \t\t\treturn null;\n\n  \t\tcase \"pop\":\n  \t\t\tif (array.length) {\n  \t\t\t\treturn [array.length - 1, 1];\n  \t\t\t}\n  \t\t\treturn [0, 0];\n\n  \t\tcase \"push\":\n  \t\t\treturn [array.length, 0].concat(args);\n\n  \t\tcase \"shift\":\n  \t\t\treturn [0, array.length ? 1 : 0];\n\n  \t\tcase \"unshift\":\n  \t\t\treturn [0, 0].concat(args);\n  \t}\n  }\n\n  var arrayProto = Array.prototype;\n\n  var makeArrayMethod = function (methodName) {\n  \treturn function (keypath) {\n  \t\tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\t\targs[_key - 1] = arguments[_key];\n  \t\t}\n\n  \t\tvar array,\n  \t\t    newIndices = [],\n  \t\t    len,\n  \t\t    promise,\n  \t\t    result;\n\n  \t\tkeypath = getKeypath(normalise(keypath));\n\n  \t\tarray = this.viewmodel.get(keypath);\n  \t\tlen = array.length;\n\n  \t\tif (!isArray(array)) {\n  \t\t\tthrow new Error(\"Called ractive.\" + methodName + \"('\" + keypath.str + \"'), but '\" + keypath.str + \"' does not refer to an array\");\n  \t\t}\n\n  \t\tnewIndices = shared_getNewIndices(array, methodName, args);\n\n  \t\tresult = arrayProto[methodName].apply(array, args);\n  \t\tpromise = global_runloop.start(this, true).then(function () {\n  \t\t\treturn result;\n  \t\t});\n\n  \t\tif (!!newIndices) {\n  \t\t\tthis.viewmodel.smartUpdate(keypath, array, newIndices);\n  \t\t} else {\n  \t\t\tthis.viewmodel.mark(keypath);\n  \t\t}\n\n  \t\tglobal_runloop.end();\n\n  \t\treturn promise;\n  \t};\n  };\n\n  var pop = makeArrayMethod(\"pop\");\n\n  var push = makeArrayMethod(\"push\");\n\n  var css,\n      update,\n      styleElement,\n      head,\n      styleSheet,\n      inDom,\n      global_css__prefix = \"/* Ractive.js component styles */\\n\",\n      styles = [],\n      dirty = false;\n\n  if (!isClient) {\n  \t// TODO handle encapsulated CSS in server-rendered HTML!\n  \tcss = {\n  \t\tadd: noop,\n  \t\tapply: noop\n  \t};\n  } else {\n  \tstyleElement = document.createElement(\"style\");\n  \tstyleElement.type = \"text/css\";\n\n  \thead = document.getElementsByTagName(\"head\")[0];\n\n  \tinDom = false;\n\n  \t// Internet Exploder won't let you use styleSheet.innerHTML - we have to\n  \t// use styleSheet.cssText instead\n  \tstyleSheet = styleElement.styleSheet;\n\n  \tupdate = function () {\n  \t\tvar css = global_css__prefix + styles.map(function (s) {\n  \t\t\treturn \"\\n/* {\" + s.id + \"} */\\n\" + s.styles;\n  \t\t}).join(\"\\n\");\n\n  \t\tif (styleSheet) {\n  \t\t\tstyleSheet.cssText = css;\n  \t\t} else {\n  \t\t\tstyleElement.innerHTML = css;\n  \t\t}\n\n  \t\tif (!inDom) {\n  \t\t\thead.appendChild(styleElement);\n  \t\t\tinDom = true;\n  \t\t}\n  \t};\n\n  \tcss = {\n  \t\tadd: function (s) {\n  \t\t\tstyles.push(s);\n  \t\t\tdirty = true;\n  \t\t},\n\n  \t\tapply: function () {\n  \t\t\tif (dirty) {\n  \t\t\t\tupdate();\n  \t\t\t\tdirty = false;\n  \t\t\t}\n  \t\t}\n  \t};\n  }\n\n  var global_css = css;\n\n  var prototype_render = Ractive$render;\n\n  var renderHook = new hooks_Hook(\"render\"),\n      completeHook = new hooks_Hook(\"complete\");\n  function Ractive$render(target, anchor) {\n  \tvar _this = this;\n\n  \tvar promise, instances, transitionsEnabled;\n\n  \t// if `noIntro` is `true`, temporarily disable transitions\n  \ttransitionsEnabled = this.transitionsEnabled;\n  \tif (this.noIntro) {\n  \t\tthis.transitionsEnabled = false;\n  \t}\n\n  \tpromise = global_runloop.start(this, true);\n  \tglobal_runloop.scheduleTask(function () {\n  \t\treturn renderHook.fire(_this);\n  \t}, true);\n\n  \tif (this.fragment.rendered) {\n  \t\tthrow new Error(\"You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first\");\n  \t}\n\n  \ttarget = getElement(target) || this.el;\n  \tanchor = getElement(anchor) || this.anchor;\n\n  \tthis.el = target;\n  \tthis.anchor = anchor;\n\n  \tif (!this.append && target) {\n  \t\t// Teardown any existing instances *before* trying to set up the new one -\n  \t\t// avoids certain weird bugs\n  \t\tvar others = target.__ractive_instances__;\n  \t\tif (others && others.length) {\n  \t\t\tremoveOtherInstances(others);\n  \t\t}\n\n  \t\t// make sure we are the only occupants\n  \t\ttarget.innerHTML = \"\"; // TODO is this quicker than removeChild? Initial research inconclusive\n  \t}\n\n  \tif (this.cssId) {\n  \t\t// ensure encapsulated CSS is up-to-date\n  \t\tglobal_css.apply();\n  \t}\n\n  \tif (target) {\n  \t\tif (!(instances = target.__ractive_instances__)) {\n  \t\t\ttarget.__ractive_instances__ = [this];\n  \t\t} else {\n  \t\t\tinstances.push(this);\n  \t\t}\n\n  \t\tif (anchor) {\n  \t\t\ttarget.insertBefore(this.fragment.render(), anchor);\n  \t\t} else {\n  \t\t\ttarget.appendChild(this.fragment.render());\n  \t\t}\n  \t}\n\n  \tglobal_runloop.end();\n\n  \tthis.transitionsEnabled = transitionsEnabled;\n\n  \treturn promise.then(function () {\n  \t\treturn completeHook.fire(_this);\n  \t});\n  }\n\n  function removeOtherInstances(others) {\n  \tothers.splice(0, others.length).forEach(teardown);\n  }\n\n  var adaptConfigurator = {\n  \textend: function (Parent, proto, options) {\n  \t\tproto.adapt = custom_adapt__combine(proto.adapt, ensureArray(options.adapt));\n  \t},\n\n  \tinit: function () {}\n  };\n\n  var custom_adapt = adaptConfigurator;\n\n  function custom_adapt__combine(a, b) {\n  \tvar c = a.slice(),\n  \t    i = b.length;\n\n  \twhile (i--) {\n  \t\tif (! ~c.indexOf(b[i])) {\n  \t\t\tc.push(b[i]);\n  \t\t}\n  \t}\n\n  \treturn c;\n  }\n\n  var transform = transformCss;\n\n  var selectorsPattern = /(?:^|\\})?\\s*([^\\{\\}]+)\\s*\\{/g,\n      commentsPattern = /\\/\\*.*?\\*\\//g,\n      selectorUnitPattern = /((?:(?:\\[[^\\]+]\\])|(?:[^\\s\\+\\>\\~:]))+)((?::[^\\s\\+\\>\\~\\(]+(?:\\([^\\)]+\\))?)?\\s*[\\s\\+\\>\\~]?)\\s*/g,\n      mediaQueryPattern = /^@media/,\n      dataRvcGuidPattern = /\\[data-ractive-css~=\"\\{[a-z0-9-]+\\}\"]/g;\n  function transformCss(css, id) {\n  \tvar transformed, dataAttr, addGuid;\n\n  \tdataAttr = \"[data-ractive-css~=\\\"{\" + id + \"}\\\"]\";\n\n  \taddGuid = function (selector) {\n  \t\tvar selectorUnits,\n  \t\t    match,\n  \t\t    unit,\n  \t\t    base,\n  \t\t    prepended,\n  \t\t    appended,\n  \t\t    i,\n  \t\t    transformed = [];\n\n  \t\tselectorUnits = [];\n\n  \t\twhile (match = selectorUnitPattern.exec(selector)) {\n  \t\t\tselectorUnits.push({\n  \t\t\t\tstr: match[0],\n  \t\t\t\tbase: match[1],\n  \t\t\t\tmodifiers: match[2]\n  \t\t\t});\n  \t\t}\n\n  \t\t// For each simple selector within the selector, we need to create a version\n  \t\t// that a) combines with the id, and b) is inside the id\n  \t\tbase = selectorUnits.map(extractString);\n\n  \t\ti = selectorUnits.length;\n  \t\twhile (i--) {\n  \t\t\tappended = base.slice();\n\n  \t\t\t// Pseudo-selectors should go after the attribute selector\n  \t\t\tunit = selectorUnits[i];\n  \t\t\tappended[i] = unit.base + dataAttr + unit.modifiers || \"\";\n\n  \t\t\tprepended = base.slice();\n  \t\t\tprepended[i] = dataAttr + \" \" + prepended[i];\n\n  \t\t\ttransformed.push(appended.join(\" \"), prepended.join(\" \"));\n  \t\t}\n\n  \t\treturn transformed.join(\", \");\n  \t};\n\n  \tif (dataRvcGuidPattern.test(css)) {\n  \t\ttransformed = css.replace(dataRvcGuidPattern, dataAttr);\n  \t} else {\n  \t\ttransformed = css.replace(commentsPattern, \"\").replace(selectorsPattern, function (match, $1) {\n  \t\t\tvar selectors, transformed;\n\n  \t\t\t// don't transform media queries!\n  \t\t\tif (mediaQueryPattern.test($1)) return match;\n\n  \t\t\tselectors = $1.split(\",\").map(trim);\n  \t\t\ttransformed = selectors.map(addGuid).join(\", \") + \" \";\n\n  \t\t\treturn match.replace($1, transformed);\n  \t\t});\n  \t}\n\n  \treturn transformed;\n  }\n\n  function trim(str) {\n  \tif (str.trim) {\n  \t\treturn str.trim();\n  \t}\n\n  \treturn str.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");\n  }\n\n  function extractString(unit) {\n  \treturn unit.str;\n  }\n\n  var css_css__uid = 1;\n\n  var cssConfigurator = {\n  \tname: \"css\",\n\n  \textend: function (Parent, proto, options) {\n  \t\tif (options.css) {\n  \t\t\tvar id = css_css__uid++;\n  \t\t\tvar styles = options.noCssTransform ? options.css : transform(options.css, id);\n\n  \t\t\tproto.cssId = id;\n  \t\t\tglobal_css.add({ id: id, styles: styles });\n  \t\t}\n  \t},\n\n  \tinit: function () {}\n  };\n\n  var css_css = cssConfigurator;\n\n  function validate(data) {\n  \t// Warn if userOptions.data is a non-POJO\n  \tif (data && data.constructor !== Object) {\n  \t\tif (typeof data === \"function\") {} else if (typeof data !== \"object\") {\n  \t\t\tfatal(\"data option must be an object or a function, `\" + data + \"` is not valid\");\n  \t\t} else {\n  \t\t\twarnIfDebug(\"If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged\");\n  \t\t}\n  \t}\n  }\n\n  var dataConfigurator = {\n  \tname: \"data\",\n\n  \textend: function (Parent, proto, options) {\n  \t\tvar key = undefined,\n  \t\t    value = undefined;\n\n  \t\t// check for non-primitives, which could cause mutation-related bugs\n  \t\tif (options.data && isObject(options.data)) {\n  \t\t\tfor (key in options.data) {\n  \t\t\t\tvalue = options.data[key];\n\n  \t\t\t\tif (value && typeof value === \"object\") {\n  \t\t\t\t\tif (isObject(value) || isArray(value)) {\n  \t\t\t\t\t\twarnIfDebug(\"Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\\n\\n  // this...\\n  data: function () {\\n    return {\\n      myObject: {}\\n    };\\n  })\\n\\n  // instead of this:\\n  data: {\\n    myObject: {}\\n  }\");\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tproto.data = custom_data__combine(proto.data, options.data);\n  \t},\n\n  \tinit: function (Parent, ractive, options) {\n  \t\tvar result = custom_data__combine(Parent.prototype.data, options.data);\n\n  \t\tif (typeof result === \"function\") {\n  \t\t\tresult = result.call(ractive);\n  \t\t}\n\n  \t\treturn result || {};\n  \t},\n\n  \treset: function (ractive) {\n  \t\tvar result = this.init(ractive.constructor, ractive, ractive.viewmodel);\n\n  \t\tractive.viewmodel.reset(result);\n  \t\treturn true;\n  \t}\n  };\n\n  var custom_data = dataConfigurator;\n\n  function custom_data__combine(parentValue, childValue) {\n  \tvalidate(childValue);\n\n  \tvar parentIsFn = typeof parentValue === \"function\";\n  \tvar childIsFn = typeof childValue === \"function\";\n\n  \t// Very important, otherwise child instance can become\n  \t// the default data object on Ractive or a component.\n  \t// then ractive.set() ends up setting on the prototype!\n  \tif (!childValue && !parentIsFn) {\n  \t\tchildValue = {};\n  \t}\n\n  \t// Fast path, where we just need to copy properties from\n  \t// parent to child\n  \tif (!parentIsFn && !childIsFn) {\n  \t\treturn fromProperties(childValue, parentValue);\n  \t}\n\n  \treturn function () {\n  \t\tvar child = childIsFn ? callDataFunction(childValue, this) : childValue;\n  \t\tvar parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;\n\n  \t\treturn fromProperties(child, parent);\n  \t};\n  }\n\n  function callDataFunction(fn, context) {\n  \tvar data = fn.call(context);\n\n  \tif (!data) return;\n\n  \tif (typeof data !== \"object\") {\n  \t\tfatal(\"Data function must return an object\");\n  \t}\n\n  \tif (data.constructor !== Object) {\n  \t\twarnOnceIfDebug(\"Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged\");\n  \t}\n\n  \treturn data;\n  }\n\n  function fromProperties(primary, secondary) {\n  \tif (primary && secondary) {\n  \t\tfor (var key in secondary) {\n  \t\t\tif (!(key in primary)) {\n  \t\t\t\tprimary[key] = secondary[key];\n  \t\t\t}\n  \t\t}\n\n  \t\treturn primary;\n  \t}\n\n  \treturn primary || secondary;\n  }\n\n  // TODO do we need to support this in the new Ractive() case?\n\n  var Parser,\n      ParseError,\n      parse_Parser__leadingWhitespace = /^\\s+/;\n\n  ParseError = function (message) {\n  \tthis.name = \"ParseError\";\n  \tthis.message = message;\n  \ttry {\n  \t\tthrow new Error(message);\n  \t} catch (e) {\n  \t\tthis.stack = e.stack;\n  \t}\n  };\n\n  ParseError.prototype = Error.prototype;\n\n  Parser = function (str, options) {\n  \tvar items,\n  \t    item,\n  \t    lineStart = 0;\n\n  \tthis.str = str;\n  \tthis.options = options || {};\n  \tthis.pos = 0;\n\n  \tthis.lines = this.str.split(\"\\n\");\n  \tthis.lineEnds = this.lines.map(function (line) {\n  \t\tvar lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n  \t\tlineStart = lineEnd;\n  \t\treturn lineEnd;\n  \t}, 0);\n\n  \t// Custom init logic\n  \tif (this.init) this.init(str, options);\n\n  \titems = [];\n\n  \twhile (this.pos < this.str.length && (item = this.read())) {\n  \t\titems.push(item);\n  \t}\n\n  \tthis.leftover = this.remaining();\n  \tthis.result = this.postProcess ? this.postProcess(items, options) : items;\n  };\n\n  Parser.prototype = {\n  \tread: function (converters) {\n  \t\tvar pos, i, len, item;\n\n  \t\tif (!converters) converters = this.converters;\n\n  \t\tpos = this.pos;\n\n  \t\tlen = converters.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\tthis.pos = pos; // reset for each attempt\n\n  \t\t\tif (item = converters[i](this)) {\n  \t\t\t\treturn item;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn null;\n  \t},\n\n  \tgetLinePos: function (char) {\n  \t\tvar lineNum = 0,\n  \t\t    lineStart = 0,\n  \t\t    columnNum;\n\n  \t\twhile (char >= this.lineEnds[lineNum]) {\n  \t\t\tlineStart = this.lineEnds[lineNum];\n  \t\t\tlineNum += 1;\n  \t\t}\n\n  \t\tcolumnNum = char - lineStart;\n  \t\treturn [lineNum + 1, columnNum + 1, char]; // line/col should be one-based, not zero-based!\n  \t},\n\n  \terror: function (message) {\n  \t\tvar pos = this.getLinePos(this.pos);\n  \t\tvar lineNum = pos[0];\n  \t\tvar columnNum = pos[1];\n\n  \t\tvar line = this.lines[pos[0] - 1];\n  \t\tvar numTabs = 0;\n  \t\tvar annotation = line.replace(/\\t/g, function (match, char) {\n  \t\t\tif (char < pos[1]) {\n  \t\t\t\tnumTabs += 1;\n  \t\t\t}\n\n  \t\t\treturn \"  \";\n  \t\t}) + \"\\n\" + new Array(pos[1] + numTabs).join(\" \") + \"^----\";\n\n  \t\tvar error = new ParseError(\"\" + message + \" at line \" + lineNum + \" character \" + columnNum + \":\\n\" + annotation);\n\n  \t\terror.line = pos[0];\n  \t\terror.character = pos[1];\n  \t\terror.shortMessage = message;\n\n  \t\tthrow error;\n  \t},\n\n  \tmatchString: function (string) {\n  \t\tif (this.str.substr(this.pos, string.length) === string) {\n  \t\t\tthis.pos += string.length;\n  \t\t\treturn string;\n  \t\t}\n  \t},\n\n  \tmatchPattern: function (pattern) {\n  \t\tvar match;\n\n  \t\tif (match = pattern.exec(this.remaining())) {\n  \t\t\tthis.pos += match[0].length;\n  \t\t\treturn match[1] || match[0];\n  \t\t}\n  \t},\n\n  \tallowWhitespace: function () {\n  \t\tthis.matchPattern(parse_Parser__leadingWhitespace);\n  \t},\n\n  \tremaining: function () {\n  \t\treturn this.str.substring(this.pos);\n  \t},\n\n  \tnextChar: function () {\n  \t\treturn this.str.charAt(this.pos);\n  \t}\n  };\n\n  Parser.extend = function (proto) {\n  \tvar Parent = this,\n  \t    Child,\n  \t    key;\n\n  \tChild = function (str, options) {\n  \t\tParser.call(this, str, options);\n  \t};\n\n  \tChild.prototype = create(Parent.prototype);\n\n  \tfor (key in proto) {\n  \t\tif (hasOwn.call(proto, key)) {\n  \t\t\tChild.prototype[key] = proto[key];\n  \t\t}\n  \t}\n\n  \tChild.extend = Parser.extend;\n  \treturn Child;\n  };\n\n  var parse_Parser = Parser;\n\n  var TEXT = 1;\n  var INTERPOLATOR = 2;\n  var TRIPLE = 3;\n  var SECTION = 4;\n  var INVERTED = 5;\n  var CLOSING = 6;\n  var ELEMENT = 7;\n  var PARTIAL = 8;\n  var COMMENT = 9;\n  var DELIMCHANGE = 10;\n  var ATTRIBUTE = 13;\n  var CLOSING_TAG = 14;\n  var COMPONENT = 15;\n  var YIELDER = 16;\n  var INLINE_PARTIAL = 17;\n  var DOCTYPE = 18;\n\n  var NUMBER_LITERAL = 20;\n  var STRING_LITERAL = 21;\n  var ARRAY_LITERAL = 22;\n  var OBJECT_LITERAL = 23;\n  var BOOLEAN_LITERAL = 24;\n  var REGEXP_LITERAL = 25;\n\n  var GLOBAL = 26;\n  var KEY_VALUE_PAIR = 27;\n\n  var REFERENCE = 30;\n  var REFINEMENT = 31;\n  var MEMBER = 32;\n  var PREFIX_OPERATOR = 33;\n  var BRACKETED = 34;\n  var CONDITIONAL = 35;\n  var INFIX_OPERATOR = 36;\n\n  var INVOCATION = 40;\n\n  var SECTION_IF = 50;\n  var SECTION_UNLESS = 51;\n  var SECTION_EACH = 52;\n  var SECTION_WITH = 53;\n  var SECTION_IF_WITH = 54;\n\n  var ELSE = 60;\n  var ELSEIF = 61;\n\n  var mustache_readDelimiterChange = readDelimiterChange;\n  var delimiterChangePattern = /^[^\\s=]+/,\n      whitespacePattern = /^\\s+/;\n  function readDelimiterChange(parser) {\n  \tvar start, opening, closing;\n\n  \tif (!parser.matchString(\"=\")) {\n  \t\treturn null;\n  \t}\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace before new opening delimiter\n  \tparser.allowWhitespace();\n\n  \topening = parser.matchPattern(delimiterChangePattern);\n  \tif (!opening) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace (in fact, it's necessary...)\n  \tif (!parser.matchPattern(whitespacePattern)) {\n  \t\treturn null;\n  \t}\n\n  \tclosing = parser.matchPattern(delimiterChangePattern);\n  \tif (!closing) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace before closing '='\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"=\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn [opening, closing];\n  }\n\n  var readRegexpLiteral = readRegexpLiteral__readNumberLiteral;\n  var regexpPattern = /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/;\n  function readRegexpLiteral__readNumberLiteral(parser) {\n  \tvar result;\n\n  \tif (result = parser.matchPattern(regexpPattern)) {\n  \t\treturn {\n  \t\t\tt: REGEXP_LITERAL,\n  \t\t\tv: result\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  var converters_readMustache = readMustache;\n\n  var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };\n  function readMustache(parser) {\n  \tvar mustache, i;\n\n  \t// If we're inside a <script> or <style> tag, and we're not\n  \t// interpolating, bug out\n  \tif (parser.interpolate[parser.inside] === false) {\n  \t\treturn null;\n  \t}\n\n  \tfor (i = 0; i < parser.tags.length; i += 1) {\n  \t\tif (mustache = readMustacheOfType(parser, parser.tags[i])) {\n  \t\t\treturn mustache;\n  \t\t}\n  \t}\n  }\n\n  function readMustacheOfType(parser, tag) {\n  \tvar start, mustache, reader, i;\n\n  \tstart = parser.pos;\n\n  \tif (parser.matchString(\"\\\\\" + tag.open)) {\n  \t\tif (start === 0 || parser.str[start - 1] !== \"\\\\\") {\n  \t\t\treturn tag.open;\n  \t\t}\n  \t} else if (!parser.matchString(tag.open)) {\n  \t\treturn null;\n  \t}\n\n  \t// delimiter change?\n  \tif (mustache = mustache_readDelimiterChange(parser)) {\n  \t\t// find closing delimiter or abort...\n  \t\tif (!parser.matchString(tag.close)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\t// ...then make the switch\n  \t\ttag.open = mustache[0];\n  \t\ttag.close = mustache[1];\n  \t\tparser.sortMustacheTags();\n\n  \t\treturn delimiterChangeToken;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \t// illegal section closer\n  \tif (parser.matchString(\"/\")) {\n  \t\tparser.pos -= 1;\n  \t\tvar rewind = parser.pos;\n  \t\tif (!readRegexpLiteral(parser)) {\n  \t\t\tparser.pos = rewind - tag.close.length;\n  \t\t\tparser.error(\"Attempted to close a section that wasn't open\");\n  \t\t} else {\n  \t\t\tparser.pos = rewind;\n  \t\t}\n  \t}\n\n  \tfor (i = 0; i < tag.readers.length; i += 1) {\n  \t\treader = tag.readers[i];\n\n  \t\tif (mustache = reader(parser, tag)) {\n  \t\t\tif (tag.isStatic) {\n  \t\t\t\tmustache.s = true; // TODO make this `1` instead - more compact\n  \t\t\t}\n\n  \t\t\tif (parser.includeLinePositions) {\n  \t\t\t\tmustache.p = parser.getLinePos(start);\n  \t\t\t}\n\n  \t\t\treturn mustache;\n  \t\t}\n  \t}\n\n  \tparser.pos = start;\n  \treturn null;\n  }\n\n  var expectedExpression = \"Expected a JavaScript expression\";\n  var expectedParen = \"Expected closing paren\";\n\n  var literal_readNumberLiteral = literal_readNumberLiteral__readNumberLiteral;\n  var literal_readNumberLiteral__numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n  function literal_readNumberLiteral__readNumberLiteral(parser) {\n  \tvar result;\n\n  \tif (result = parser.matchPattern(literal_readNumberLiteral__numberPattern)) {\n  \t\treturn {\n  \t\t\tt: NUMBER_LITERAL,\n  \t\t\tv: result\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  var literal_readBooleanLiteral = readBooleanLiteral;\n  function readBooleanLiteral(parser) {\n  \tvar remaining = parser.remaining();\n\n  \tif (remaining.substr(0, 4) === \"true\") {\n  \t\tparser.pos += 4;\n  \t\treturn {\n  \t\t\tt: BOOLEAN_LITERAL,\n  \t\t\tv: \"true\"\n  \t\t};\n  \t}\n\n  \tif (remaining.substr(0, 5) === \"false\") {\n  \t\tparser.pos += 5;\n  \t\treturn {\n  \t\t\tt: BOOLEAN_LITERAL,\n  \t\t\tv: \"false\"\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;\n\n  // Match one or more characters until: \", ', \\, or EOL/EOF.\n  // EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\n  stringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/;\n\n  // Match one escape sequence, including the backslash.\n  escapeSequencePattern = /^\\\\(?:['\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\n  // Match one ES5 line continuation (backslash + line terminator).\n  lineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\n  // Helper for defining getDoubleQuotedString and getSingleQuotedString.\n  var makeQuotedStringMatcher = function (okQuote) {\n  \treturn function (parser) {\n  \t\tvar start, literal, done, next;\n\n  \t\tstart = parser.pos;\n  \t\tliteral = \"\\\"\";\n  \t\tdone = false;\n\n  \t\twhile (!done) {\n  \t\t\tnext = parser.matchPattern(stringMiddlePattern) || parser.matchPattern(escapeSequencePattern) || parser.matchString(okQuote);\n  \t\t\tif (next) {\n  \t\t\t\tif (next === \"\\\"\") {\n  \t\t\t\t\tliteral += \"\\\\\\\"\";\n  \t\t\t\t} else if (next === \"\\\\'\") {\n  \t\t\t\t\tliteral += \"'\";\n  \t\t\t\t} else {\n  \t\t\t\t\tliteral += next;\n  \t\t\t\t}\n  \t\t\t} else {\n  \t\t\t\tnext = parser.matchPattern(lineContinuationPattern);\n  \t\t\t\tif (next) {\n  \t\t\t\t\t// convert \\(newline-like) into a \\u escape, which is allowed in JSON\n  \t\t\t\t\tliteral += \"\\\\u\" + (\"000\" + next.charCodeAt(1).toString(16)).slice(-4);\n  \t\t\t\t} else {\n  \t\t\t\t\tdone = true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tliteral += \"\\\"\";\n\n  \t\t// use JSON.parse to interpret escapes\n  \t\treturn JSON.parse(literal);\n  \t};\n  };\n\n  var getSingleQuotedString = makeQuotedStringMatcher(\"\\\"\");\n  var getDoubleQuotedString = makeQuotedStringMatcher(\"'\");\n\n  var readStringLiteral = function (parser) {\n  \tvar start, string;\n\n  \tstart = parser.pos;\n\n  \tif (parser.matchString(\"\\\"\")) {\n  \t\tstring = getDoubleQuotedString(parser);\n\n  \t\tif (!parser.matchString(\"\\\"\")) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: STRING_LITERAL,\n  \t\t\tv: string\n  \t\t};\n  \t}\n\n  \tif (parser.matchString(\"'\")) {\n  \t\tstring = getSingleQuotedString(parser);\n\n  \t\tif (!parser.matchString(\"'\")) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: STRING_LITERAL,\n  \t\t\tv: string\n  \t\t};\n  \t}\n\n  \treturn null;\n  };\n\n  var patterns__name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;\n\n  // http://mathiasbynens.be/notes/javascript-properties\n  // can be any name, string literal, or number literal\n  var shared_readKey = readKey;\n  var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n  function readKey(parser) {\n  \tvar token;\n\n  \tif (token = readStringLiteral(parser)) {\n  \t\treturn identifier.test(token.v) ? token.v : \"\\\"\" + token.v.replace(/\"/g, \"\\\\\\\"\") + \"\\\"\";\n  \t}\n\n  \tif (token = literal_readNumberLiteral(parser)) {\n  \t\treturn token.v;\n  \t}\n\n  \tif (token = parser.matchPattern(patterns__name)) {\n  \t\treturn token;\n  \t}\n  }\n\n  var keyValuePair = readKeyValuePair;\n  function readKeyValuePair(parser) {\n  \tvar start, key, value;\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace between '{' and key\n  \tparser.allowWhitespace();\n\n  \tkey = shared_readKey(parser);\n  \tif (key === null) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace between key and ':'\n  \tparser.allowWhitespace();\n\n  \t// next character must be ':'\n  \tif (!parser.matchString(\":\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace between ':' and value\n  \tparser.allowWhitespace();\n\n  \t// next expression must be a, well... expression\n  \tvalue = converters_readExpression(parser);\n  \tif (value === null) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tt: KEY_VALUE_PAIR,\n  \t\tk: key,\n  \t\tv: value\n  \t};\n  }\n\n  var objectLiteral_keyValuePairs = readKeyValuePairs;\n  function readKeyValuePairs(parser) {\n  \tvar start, pairs, pair, keyValuePairs;\n\n  \tstart = parser.pos;\n\n  \tpair = keyValuePair(parser);\n  \tif (pair === null) {\n  \t\treturn null;\n  \t}\n\n  \tpairs = [pair];\n\n  \tif (parser.matchString(\",\")) {\n  \t\tkeyValuePairs = readKeyValuePairs(parser);\n\n  \t\tif (!keyValuePairs) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn pairs.concat(keyValuePairs);\n  \t}\n\n  \treturn pairs;\n  }\n\n  var readObjectLiteral = function (parser) {\n  \tvar start, keyValuePairs;\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"{\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tkeyValuePairs = objectLiteral_keyValuePairs(parser);\n\n  \t// allow whitespace between final value and '}'\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"}\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tt: OBJECT_LITERAL,\n  \t\tm: keyValuePairs\n  \t};\n  };\n\n  var shared_readExpressionList = readExpressionList;\n  function readExpressionList(parser) {\n  \tvar start, expressions, expr, next;\n\n  \tstart = parser.pos;\n\n  \tparser.allowWhitespace();\n\n  \texpr = converters_readExpression(parser);\n\n  \tif (expr === null) {\n  \t\treturn null;\n  \t}\n\n  \texpressions = [expr];\n\n  \t// allow whitespace between expression and ','\n  \tparser.allowWhitespace();\n\n  \tif (parser.matchString(\",\")) {\n  \t\tnext = readExpressionList(parser);\n  \t\tif (next === null) {\n  \t\t\tparser.error(expectedExpression);\n  \t\t}\n\n  \t\tnext.forEach(append);\n  \t}\n\n  \tfunction append(expression) {\n  \t\texpressions.push(expression);\n  \t}\n\n  \treturn expressions;\n  }\n\n  var readArrayLiteral = function (parser) {\n  \tvar start, expressionList;\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace before '['\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"[\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \texpressionList = shared_readExpressionList(parser);\n\n  \tif (!parser.matchString(\"]\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tt: ARRAY_LITERAL,\n  \t\tm: expressionList\n  \t};\n  };\n\n  var primary_readLiteral = readLiteral;\n  function readLiteral(parser) {\n  \treturn literal_readNumberLiteral(parser) || literal_readBooleanLiteral(parser) || readStringLiteral(parser) || readObjectLiteral(parser) || readArrayLiteral(parser) || readRegexpLiteral(parser);\n  }\n\n  var primary_readReference = readReference;\n  var prefixPattern = /^(?:~\\/|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/,\n      globals,\n      keywords;\n\n  // if a reference is a browser global, we don't deference it later, so it needs special treatment\n  globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)\\b/;\n\n  // keywords are not valid references, with the exception of `this`\n  keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\n  var legalReference = /^[a-zA-Z$_0-9]+(?:(?:\\.[a-zA-Z$_0-9]+)|(?:\\[[0-9]+\\]))*/;\n  var relaxedName = /^[a-zA-Z_$][-a-zA-Z_$0-9]*/;\n  function readReference(parser) {\n  \tvar startPos, prefix, name, global, reference, lastDotIndex;\n\n  \tstartPos = parser.pos;\n\n  \tname = parser.matchPattern(/^@(?:keypath|index|key)/);\n\n  \tif (!name) {\n  \t\tprefix = parser.matchPattern(prefixPattern) || \"\";\n  \t\tname = !prefix && parser.relaxedNames && parser.matchPattern(relaxedName) || parser.matchPattern(legalReference);\n\n  \t\tif (!name && prefix === \".\") {\n  \t\t\tprefix = \"\";\n  \t\t\tname = \".\";\n  \t\t}\n  \t}\n\n  \tif (!name) {\n  \t\treturn null;\n  \t}\n\n  \t// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n  \tif (!prefix && !parser.relaxedNames && keywords.test(name)) {\n  \t\tparser.pos = startPos;\n  \t\treturn null;\n  \t}\n\n  \t// if this is a browser global, stop here\n  \tif (!prefix && globals.test(name)) {\n  \t\tglobal = globals.exec(name)[0];\n  \t\tparser.pos = startPos + global.length;\n\n  \t\treturn {\n  \t\t\tt: GLOBAL,\n  \t\t\tv: global\n  \t\t};\n  \t}\n\n  \treference = (prefix || \"\") + normalise(name);\n\n  \tif (parser.matchString(\"(\")) {\n  \t\t// if this is a method invocation (as opposed to a function) we need\n  \t\t// to strip the method name from the reference combo, else the context\n  \t\t// will be wrong\n  \t\tlastDotIndex = reference.lastIndexOf(\".\");\n  \t\tif (lastDotIndex !== -1) {\n  \t\t\treference = reference.substr(0, lastDotIndex);\n  \t\t\tparser.pos = startPos + reference.length;\n  \t\t} else {\n  \t\t\tparser.pos -= 1;\n  \t\t}\n  \t}\n\n  \treturn {\n  \t\tt: REFERENCE,\n  \t\tn: reference.replace(/^this\\./, \"./\").replace(/^this$/, \".\")\n  \t};\n  }\n\n  var primary_readBracketedExpression = readBracketedExpression;\n  function readBracketedExpression(parser) {\n  \tvar start, expr;\n\n  \tstart = parser.pos;\n\n  \tif (!parser.matchString(\"(\")) {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \texpr = converters_readExpression(parser);\n  \tif (!expr) {\n  \t\tparser.error(expectedExpression);\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\")\")) {\n  \t\tparser.error(expectedParen);\n  \t}\n\n  \treturn {\n  \t\tt: BRACKETED,\n  \t\tx: expr\n  \t};\n  }\n\n  var readPrimary = function (parser) {\n  \treturn primary_readLiteral(parser) || primary_readReference(parser) || primary_readBracketedExpression(parser);\n  };\n\n  var shared_readRefinement = readRefinement;\n  function readRefinement(parser) {\n  \tvar start, name, expr;\n\n  \tstart = parser.pos;\n\n  \tparser.allowWhitespace();\n\n  \t// \".\" name\n  \tif (parser.matchString(\".\")) {\n  \t\tparser.allowWhitespace();\n\n  \t\tif (name = parser.matchPattern(patterns__name)) {\n  \t\t\treturn {\n  \t\t\t\tt: REFINEMENT,\n  \t\t\t\tn: name\n  \t\t\t};\n  \t\t}\n\n  \t\tparser.error(\"Expected a property name\");\n  \t}\n\n  \t// \"[\" expression \"]\"\n  \tif (parser.matchString(\"[\")) {\n  \t\tparser.allowWhitespace();\n\n  \t\texpr = converters_readExpression(parser);\n  \t\tif (!expr) {\n  \t\t\tparser.error(expectedExpression);\n  \t\t}\n\n  \t\tparser.allowWhitespace();\n\n  \t\tif (!parser.matchString(\"]\")) {\n  \t\t\tparser.error(\"Expected ']'\");\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: REFINEMENT,\n  \t\t\tx: expr\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  var readMemberOrInvocation = function (parser) {\n  \tvar current, expression, refinement, expressionList;\n\n  \texpression = readPrimary(parser);\n\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \twhile (expression) {\n  \t\tcurrent = parser.pos;\n\n  \t\tif (refinement = shared_readRefinement(parser)) {\n  \t\t\texpression = {\n  \t\t\t\tt: MEMBER,\n  \t\t\t\tx: expression,\n  \t\t\t\tr: refinement\n  \t\t\t};\n  \t\t} else if (parser.matchString(\"(\")) {\n  \t\t\tparser.allowWhitespace();\n  \t\t\texpressionList = shared_readExpressionList(parser);\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif (!parser.matchString(\")\")) {\n  \t\t\t\tparser.error(expectedParen);\n  \t\t\t}\n\n  \t\t\texpression = {\n  \t\t\t\tt: INVOCATION,\n  \t\t\t\tx: expression\n  \t\t\t};\n\n  \t\t\tif (expressionList) {\n  \t\t\t\texpression.o = expressionList;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tbreak;\n  \t\t}\n  \t}\n\n  \treturn expression;\n  };\n\n  var readTypeOf, makePrefixSequenceMatcher;\n\n  makePrefixSequenceMatcher = function (symbol, fallthrough) {\n  \treturn function (parser) {\n  \t\tvar expression;\n\n  \t\tif (expression = fallthrough(parser)) {\n  \t\t\treturn expression;\n  \t\t}\n\n  \t\tif (!parser.matchString(symbol)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tparser.allowWhitespace();\n\n  \t\texpression = converters_readExpression(parser);\n  \t\tif (!expression) {\n  \t\t\tparser.error(expectedExpression);\n  \t\t}\n\n  \t\treturn {\n  \t\t\ts: symbol,\n  \t\t\to: expression,\n  \t\t\tt: PREFIX_OPERATOR\n  \t\t};\n  \t};\n  };\n\n  // create all prefix sequence matchers, return readTypeOf\n  (function () {\n  \tvar i, len, matcher, prefixOperators, fallthrough;\n\n  \tprefixOperators = \"! ~ + - typeof\".split(\" \");\n\n  \tfallthrough = readMemberOrInvocation;\n  \tfor (i = 0, len = prefixOperators.length; i < len; i += 1) {\n  \t\tmatcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);\n  \t\tfallthrough = matcher;\n  \t}\n\n  \t// typeof operator is higher precedence than multiplication, so provides the\n  \t// fallthrough for the multiplication sequence matcher we're about to create\n  \t// (we're skipping void and delete)\n  \treadTypeOf = fallthrough;\n  })();\n\n  var readTypeof = readTypeOf;\n\n  var readLogicalOr, makeInfixSequenceMatcher;\n\n  makeInfixSequenceMatcher = function (symbol, fallthrough) {\n  \treturn function (parser) {\n  \t\tvar start, left, right;\n\n  \t\tleft = fallthrough(parser);\n  \t\tif (!left) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\t// Loop to handle left-recursion in a case like `a * b * c` and produce\n  \t\t// left association, i.e. `(a * b) * c`.  The matcher can't call itself\n  \t\t// to parse `left` because that would be infinite regress.\n  \t\twhile (true) {\n  \t\t\tstart = parser.pos;\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif (!parser.matchString(symbol)) {\n  \t\t\t\tparser.pos = start;\n  \t\t\t\treturn left;\n  \t\t\t}\n\n  \t\t\t// special case - in operator must not be followed by [a-zA-Z_$0-9]\n  \t\t\tif (symbol === \"in\" && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {\n  \t\t\t\tparser.pos = start;\n  \t\t\t\treturn left;\n  \t\t\t}\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\t// right operand must also consist of only higher-precedence operators\n  \t\t\tright = fallthrough(parser);\n  \t\t\tif (!right) {\n  \t\t\t\tparser.pos = start;\n  \t\t\t\treturn left;\n  \t\t\t}\n\n  \t\t\tleft = {\n  \t\t\t\tt: INFIX_OPERATOR,\n  \t\t\t\ts: symbol,\n  \t\t\t\to: [left, right]\n  \t\t\t};\n\n  \t\t\t// Loop back around.  If we don't see another occurrence of the symbol,\n  \t\t\t// we'll return left.\n  \t\t}\n  \t};\n  };\n\n  // create all infix sequence matchers, and return readLogicalOr\n  (function () {\n  \tvar i, len, matcher, infixOperators, fallthrough;\n\n  \t// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n  \t// Each sequence matcher will initially fall through to its higher precedence\n  \t// neighbour, and only attempt to match if one of the higher precedence operators\n  \t// (or, ultimately, a literal, reference, or bracketed expression) already matched\n  \tinfixOperators = \"* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||\".split(\" \");\n\n  \t// A typeof operator is higher precedence than multiplication\n  \tfallthrough = readTypeof;\n  \tfor (i = 0, len = infixOperators.length; i < len; i += 1) {\n  \t\tmatcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);\n  \t\tfallthrough = matcher;\n  \t}\n\n  \t// Logical OR is the fallthrough for the conditional matcher\n  \treadLogicalOr = fallthrough;\n  })();\n\n  var expressions_readLogicalOr = readLogicalOr;\n\n  // The conditional operator is the lowest precedence operator, so we start here\n  var readConditional = getConditional;\n  function getConditional(parser) {\n  \tvar start, expression, ifTrue, ifFalse;\n\n  \texpression = expressions_readLogicalOr(parser);\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \tstart = parser.pos;\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"?\")) {\n  \t\tparser.pos = start;\n  \t\treturn expression;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tifTrue = converters_readExpression(parser);\n  \tif (!ifTrue) {\n  \t\tparser.error(expectedExpression);\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\":\")) {\n  \t\tparser.error(\"Expected \\\":\\\"\");\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tifFalse = converters_readExpression(parser);\n  \tif (!ifFalse) {\n  \t\tparser.error(expectedExpression);\n  \t}\n\n  \treturn {\n  \t\tt: CONDITIONAL,\n  \t\to: [expression, ifTrue, ifFalse]\n  \t};\n  }\n\n  var converters_readExpression = readExpression;\n  function readExpression(parser) {\n  \t// The conditional operator is the lowest precedence operator (except yield,\n  \t// assignment operators, and commas, none of which are supported), so we\n  \t// start there. If it doesn't match, it 'falls through' to progressively\n  \t// higher precedence operators, until it eventually matches (or fails to\n  \t// match) a 'primary' - a literal or a reference. This way, the abstract syntax\n  \t// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n  \treturn readConditional(parser);\n  }\n\n  var utils_flattenExpression = flattenExpression;\n\n  function flattenExpression(expression) {\n  \tvar refs;\n\n  \textractRefs(expression, refs = []);\n\n  \treturn {\n  \t\tr: refs,\n  \t\ts: stringify(expression)\n  \t};\n\n  \tfunction stringify(node) {\n  \t\tswitch (node.t) {\n  \t\t\tcase BOOLEAN_LITERAL:\n  \t\t\tcase GLOBAL:\n  \t\t\tcase NUMBER_LITERAL:\n  \t\t\tcase REGEXP_LITERAL:\n  \t\t\t\treturn node.v;\n\n  \t\t\tcase STRING_LITERAL:\n  \t\t\t\treturn JSON.stringify(String(node.v));\n\n  \t\t\tcase ARRAY_LITERAL:\n  \t\t\t\treturn \"[\" + (node.m ? node.m.map(stringify).join(\",\") : \"\") + \"]\";\n\n  \t\t\tcase OBJECT_LITERAL:\n  \t\t\t\treturn \"{\" + (node.m ? node.m.map(stringify).join(\",\") : \"\") + \"}\";\n\n  \t\t\tcase KEY_VALUE_PAIR:\n  \t\t\t\treturn node.k + \":\" + stringify(node.v);\n\n  \t\t\tcase PREFIX_OPERATOR:\n  \t\t\t\treturn (node.s === \"typeof\" ? \"typeof \" : node.s) + stringify(node.o);\n\n  \t\t\tcase INFIX_OPERATOR:\n  \t\t\t\treturn stringify(node.o[0]) + (node.s.substr(0, 2) === \"in\" ? \" \" + node.s + \" \" : node.s) + stringify(node.o[1]);\n\n  \t\t\tcase INVOCATION:\n  \t\t\t\treturn stringify(node.x) + \"(\" + (node.o ? node.o.map(stringify).join(\",\") : \"\") + \")\";\n\n  \t\t\tcase BRACKETED:\n  \t\t\t\treturn \"(\" + stringify(node.x) + \")\";\n\n  \t\t\tcase MEMBER:\n  \t\t\t\treturn stringify(node.x) + stringify(node.r);\n\n  \t\t\tcase REFINEMENT:\n  \t\t\t\treturn node.n ? \".\" + node.n : \"[\" + stringify(node.x) + \"]\";\n\n  \t\t\tcase CONDITIONAL:\n  \t\t\t\treturn stringify(node.o[0]) + \"?\" + stringify(node.o[1]) + \":\" + stringify(node.o[2]);\n\n  \t\t\tcase REFERENCE:\n  \t\t\t\treturn \"_\" + refs.indexOf(node.n);\n\n  \t\t\tdefault:\n  \t\t\t\tthrow new Error(\"Expected legal JavaScript\");\n  \t\t}\n  \t}\n  }\n\n  // TODO maybe refactor this?\n  function extractRefs(node, refs) {\n  \tvar i, list;\n\n  \tif (node.t === REFERENCE) {\n  \t\tif (refs.indexOf(node.n) === -1) {\n  \t\t\trefs.unshift(node.n);\n  \t\t}\n  \t}\n\n  \tlist = node.o || node.m;\n  \tif (list) {\n  \t\tif (isObject(list)) {\n  \t\t\textractRefs(list, refs);\n  \t\t} else {\n  \t\t\ti = list.length;\n  \t\t\twhile (i--) {\n  \t\t\t\textractRefs(list[i], refs);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tif (node.x) {\n  \t\textractRefs(node.x, refs);\n  \t}\n\n  \tif (node.r) {\n  \t\textractRefs(node.r, refs);\n  \t}\n\n  \tif (node.v) {\n  \t\textractRefs(node.v, refs);\n  \t}\n  }\n\n  var utils_refineExpression = refineExpression;\n\n  var arrayMemberPattern = /^[0-9][1-9]*$/;\n  function refineExpression(expression, mustache) {\n  \tvar referenceExpression;\n\n  \tif (expression) {\n  \t\twhile (expression.t === BRACKETED && expression.x) {\n  \t\t\texpression = expression.x;\n  \t\t}\n\n  \t\t// special case - integers should be treated as array members references,\n  \t\t// rather than as expressions in their own right\n  \t\tif (expression.t === REFERENCE) {\n  \t\t\tmustache.r = expression.n;\n  \t\t} else {\n  \t\t\tif (expression.t === NUMBER_LITERAL && arrayMemberPattern.test(expression.v)) {\n  \t\t\t\tmustache.r = expression.v;\n  \t\t\t} else if (referenceExpression = getReferenceExpression(expression)) {\n  \t\t\t\tmustache.rx = referenceExpression;\n  \t\t\t} else {\n  \t\t\t\tmustache.x = utils_flattenExpression(expression);\n  \t\t\t}\n  \t\t}\n\n  \t\treturn mustache;\n  \t}\n  }\n\n  // TODO refactor this! it's bewildering\n  function getReferenceExpression(expression) {\n  \tvar members = [],\n  \t    refinement;\n\n  \twhile (expression.t === MEMBER && expression.r.t === REFINEMENT) {\n  \t\trefinement = expression.r;\n\n  \t\tif (refinement.x) {\n  \t\t\tif (refinement.x.t === REFERENCE) {\n  \t\t\t\tmembers.unshift(refinement.x);\n  \t\t\t} else {\n  \t\t\t\tmembers.unshift(utils_flattenExpression(refinement.x));\n  \t\t\t}\n  \t\t} else {\n  \t\t\tmembers.unshift(refinement.n);\n  \t\t}\n\n  \t\texpression = expression.x;\n  \t}\n\n  \tif (expression.t !== REFERENCE) {\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tr: expression.n,\n  \t\tm: members\n  \t};\n  }\n\n  var mustache_readTriple = readTriple;\n  function readTriple(parser, tag) {\n  \tvar expression = converters_readExpression(parser),\n  \t    triple;\n\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \ttriple = { t: TRIPLE };\n  \tutils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious\n\n  \treturn triple;\n  }\n\n  var mustache_readUnescaped = readUnescaped;\n  function readUnescaped(parser, tag) {\n  \tvar expression, triple;\n\n  \tif (!parser.matchString(\"&\")) {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \texpression = converters_readExpression(parser);\n\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \ttriple = { t: TRIPLE };\n  \tutils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious\n\n  \treturn triple;\n  }\n\n  var mustache_readPartial = readPartial;\n  function readPartial(parser, tag) {\n  \tvar start, nameStart, expression, context, partial;\n\n  \tstart = parser.pos;\n\n  \tif (!parser.matchString(\">\")) {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n  \tnameStart = parser.pos;\n\n  \t// Partial names can include hyphens, so we can't use readExpression\n  \t// blindly. Instead, we use the `relaxedNames` flag to indicate that\n  \t// `foo-bar` should be read as a single name, rather than 'subtract\n  \t// bar from foo'\n  \tparser.relaxedNames = true;\n  \texpression = converters_readExpression(parser);\n  \tparser.relaxedNames = false;\n\n  \tparser.allowWhitespace();\n  \tcontext = converters_readExpression(parser);\n  \tparser.allowWhitespace();\n\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \tpartial = { t: PARTIAL };\n  \tutils_refineExpression(expression, partial); // TODO...\n\n  \tparser.allowWhitespace();\n\n  \t// if we have another expression - e.g. `{{>foo bar}}` - then\n  \t// we turn it into `{{#with bar}}{{>foo}}{{/with}}`\n  \tif (context) {\n  \t\tpartial = {\n  \t\t\tt: SECTION,\n  \t\t\tn: SECTION_WITH,\n  \t\t\tf: [partial]\n  \t\t};\n\n  \t\tutils_refineExpression(context, partial);\n  \t}\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \treturn partial;\n  }\n\n  var readMustacheComment = readComment;\n  function readComment(parser, tag) {\n  \tvar index;\n\n  \tif (!parser.matchString(\"!\")) {\n  \t\treturn null;\n  \t}\n\n  \tindex = parser.remaining().indexOf(tag.close);\n\n  \tif (index !== -1) {\n  \t\tparser.pos += index + tag.close.length;\n  \t\treturn { t: COMMENT };\n  \t}\n  }\n\n  var converters_readExpressionOrReference = readExpressionOrReference;\n  function readExpressionOrReference(parser, expectedFollowers) {\n  \tvar start, expression, i;\n\n  \tstart = parser.pos;\n  \texpression = converters_readExpression(parser);\n\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \tfor (i = 0; i < expectedFollowers.length; i += 1) {\n  \t\tif (parser.remaining().substr(0, expectedFollowers[i].length) === expectedFollowers[i]) {\n  \t\t\treturn expression;\n  \t\t}\n  \t}\n\n  \tparser.pos = start;\n  \treturn primary_readReference(parser);\n  }\n\n  var mustache_readInterpolator = readInterpolator;\n  function readInterpolator(parser, tag) {\n  \tvar start, expression, interpolator, err;\n\n  \tstart = parser.pos;\n\n  \t// TODO would be good for perf if we could do away with the try-catch\n  \ttry {\n  \t\texpression = converters_readExpressionOrReference(parser, [tag.close]);\n  \t} catch (e) {\n  \t\terr = e;\n  \t}\n\n  \tif (!expression) {\n  \t\tif (parser.str.charAt(start) === \"!\") {\n  \t\t\t// special case - comment\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tif (err) {\n  \t\t\tthrow err;\n  \t\t}\n  \t}\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"' after reference\");\n\n  \t\tif (!expression) {\n  \t\t\t// special case - comment\n  \t\t\tif (parser.nextChar() === \"!\") {\n  \t\t\t\treturn null;\n  \t\t\t}\n\n  \t\t\tparser.error(\"Expected expression or legal reference\");\n  \t\t}\n  \t}\n\n  \tinterpolator = { t: INTERPOLATOR };\n  \tutils_refineExpression(expression, interpolator); // TODO handle this differently - it's mysterious\n\n  \treturn interpolator;\n  }\n\n  var mustache_readYielder = readYielder;\n  var yieldPattern = /^yield\\s*/;\n  function readYielder(parser, tag) {\n  \tvar start, name, yielder;\n\n  \tif (!parser.matchPattern(yieldPattern)) {\n  \t\treturn null;\n  \t}\n\n  \tstart = parser.pos;\n  \tname = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/);\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"expected legal partial name\");\n  \t}\n\n  \tyielder = { t: YIELDER };\n\n  \tif (name) {\n  \t\tyielder.n = name;\n  \t}\n\n  \treturn yielder;\n  }\n\n  var section_readClosing = readClosing;\n  function readClosing(parser, tag) {\n  \tvar start, remaining, index, closing;\n\n  \tstart = parser.pos;\n\n  \tif (!parser.matchString(tag.open)) {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"/\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tremaining = parser.remaining();\n  \tindex = remaining.indexOf(tag.close);\n\n  \tif (index !== -1) {\n  \t\tclosing = {\n  \t\t\tt: CLOSING,\n  \t\t\tr: remaining.substr(0, index).split(\" \")[0]\n  \t\t};\n\n  \t\tparser.pos += index;\n\n  \t\tif (!parser.matchString(tag.close)) {\n  \t\t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t\t}\n\n  \t\treturn closing;\n  \t}\n\n  \tparser.pos = start;\n  \treturn null;\n  }\n\n  var section_readElse = section_readElse__readElse;\n  var section_readElse__elsePattern = /^\\s*else\\s*/;\n  function section_readElse__readElse(parser, tag) {\n  \tvar start = parser.pos;\n\n  \tif (!parser.matchString(tag.open)) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchPattern(section_readElse__elsePattern)) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \treturn {\n  \t\tt: ELSE\n  \t};\n  }\n\n  var readElseIf = readElseIf__readElse;\n  var readElseIf__elsePattern = /^\\s*elseif\\s+/;\n  function readElseIf__readElse(parser, tag) {\n  \tvar start = parser.pos,\n  \t    expression;\n\n  \tif (!parser.matchString(tag.open)) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchPattern(readElseIf__elsePattern)) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \texpression = converters_readExpression(parser);\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \treturn {\n  \t\tt: ELSEIF,\n  \t\tx: expression\n  \t};\n  }\n\n  var handlebarsBlockCodes = {\n  \teach: SECTION_EACH,\n  \t\"if\": SECTION_IF,\n  \t\"if-with\": SECTION_IF_WITH,\n  \t\"with\": SECTION_WITH,\n  \tunless: SECTION_UNLESS\n  };\n\n  var mustache_readSection = readSection;\n\n  var indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n      keyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n      handlebarsBlockPattern = new RegExp(\"^(\" + Object.keys(handlebarsBlockCodes).join(\"|\") + \")\\\\b\");\n  function readSection(parser, tag) {\n  \tvar start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose;\n\n  \tstart = parser.pos;\n\n  \tif (parser.matchString(\"^\")) {\n  \t\tsection = { t: SECTION, f: [], n: SECTION_UNLESS };\n  \t} else if (parser.matchString(\"#\")) {\n  \t\tsection = { t: SECTION, f: [] };\n\n  \t\tif (parser.matchString(\"partial\")) {\n  \t\t\tparser.pos = start - parser.standardDelimiters[0].length;\n  \t\t\tparser.error(\"Partial definitions can only be at the top level of the template, or immediately inside components\");\n  \t\t}\n\n  \t\tif (block = parser.matchPattern(handlebarsBlockPattern)) {\n  \t\t\texpectedClose = block;\n  \t\t\tsection.n = handlebarsBlockCodes[block];\n  \t\t}\n  \t} else {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \texpression = converters_readExpression(parser);\n\n  \tif (!expression) {\n  \t\tparser.error(\"Expected expression\");\n  \t}\n\n  \t// optional index and key references\n  \tif (i = parser.matchPattern(indexRefPattern)) {\n  \t\tvar extra = undefined;\n\n  \t\tif (extra = parser.matchPattern(keyIndexRefPattern)) {\n  \t\t\tsection.i = i + \",\" + extra;\n  \t\t} else {\n  \t\t\tsection.i = i;\n  \t\t}\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \tparser.sectionDepth += 1;\n  \tchildren = section.f;\n\n  \tconditions = [];\n\n  \tdo {\n  \t\tif (child = section_readClosing(parser, tag)) {\n  \t\t\tif (expectedClose && child.r !== expectedClose) {\n  \t\t\t\tparser.error(\"Expected \" + tag.open + \"/\" + expectedClose + \"\" + tag.close);\n  \t\t\t}\n\n  \t\t\tparser.sectionDepth -= 1;\n  \t\t\tclosed = true;\n  \t\t} else if (child = readElseIf(parser, tag)) {\n  \t\t\tif (section.n === SECTION_UNLESS) {\n  \t\t\t\tparser.error(\"{{else}} not allowed in {{#unless}}\");\n  \t\t\t}\n\n  \t\t\tif (hasElse) {\n  \t\t\t\tparser.error(\"illegal {{elseif...}} after {{else}}\");\n  \t\t\t}\n\n  \t\t\tif (!unlessBlock) {\n  \t\t\t\tunlessBlock = createUnlessBlock(expression, section.n);\n  \t\t\t}\n\n  \t\t\tunlessBlock.f.push({\n  \t\t\t\tt: SECTION,\n  \t\t\t\tn: SECTION_IF,\n  \t\t\t\tx: utils_flattenExpression(mustache_readSection__combine(conditions.concat(child.x))),\n  \t\t\t\tf: children = []\n  \t\t\t});\n\n  \t\t\tconditions.push(invert(child.x));\n  \t\t} else if (child = section_readElse(parser, tag)) {\n  \t\t\tif (section.n === SECTION_UNLESS) {\n  \t\t\t\tparser.error(\"{{else}} not allowed in {{#unless}}\");\n  \t\t\t}\n\n  \t\t\tif (hasElse) {\n  \t\t\t\tparser.error(\"there can only be one {{else}} block, at the end of a section\");\n  \t\t\t}\n\n  \t\t\thasElse = true;\n\n  \t\t\t// use an unless block if there's no elseif\n  \t\t\tif (!unlessBlock) {\n  \t\t\t\tunlessBlock = createUnlessBlock(expression, section.n);\n  \t\t\t\tchildren = unlessBlock.f;\n  \t\t\t} else {\n  \t\t\t\tunlessBlock.f.push({\n  \t\t\t\t\tt: SECTION,\n  \t\t\t\t\tn: SECTION_IF,\n  \t\t\t\t\tx: utils_flattenExpression(mustache_readSection__combine(conditions)),\n  \t\t\t\t\tf: children = []\n  \t\t\t\t});\n  \t\t\t}\n  \t\t} else {\n  \t\t\tchild = parser.read(READERS);\n\n  \t\t\tif (!child) {\n  \t\t\t\tbreak;\n  \t\t\t}\n\n  \t\t\tchildren.push(child);\n  \t\t}\n  \t} while (!closed);\n\n  \tif (unlessBlock) {\n  \t\t// special case - `with` should become `if-with` (TODO is this right?\n  \t\t// seems to me that `with` ought to behave consistently, regardless\n  \t\t// of the presence/absence of `else`. In other words should always\n  \t\t// be `if-with`\n  \t\tif (section.n === SECTION_WITH) {\n  \t\t\tsection.n = SECTION_IF_WITH;\n  \t\t}\n\n  \t\tsection.l = unlessBlock;\n  \t}\n\n  \tutils_refineExpression(expression, section);\n\n  \t// TODO if a section is empty it should be discarded. Don't do\n  \t// that here though - we need to clean everything up first, as\n  \t// it may contain removeable whitespace. As a temporary measure,\n  \t// to pass the existing tests, remove empty `f` arrays\n  \tif (!section.f.length) {\n  \t\tdelete section.f;\n  \t}\n\n  \treturn section;\n  }\n\n  function createUnlessBlock(expression, sectionType) {\n  \tvar unlessBlock;\n\n  \tif (sectionType === SECTION_WITH) {\n  \t\t// special case - a `{{#with foo}}` section will render if `foo` is\n  \t\t// truthy, so the `{{else}}` section needs to render if `foo` is falsy,\n  \t\t// rather than adhering to the normal `{{#unless foo}}` logic (which\n  \t\t// treats empty arrays/objects as falsy)\n  \t\tunlessBlock = {\n  \t\t\tt: SECTION,\n  \t\t\tn: SECTION_IF,\n  \t\t\tf: []\n  \t\t};\n\n  \t\tutils_refineExpression(invert(expression), unlessBlock);\n  \t} else {\n  \t\tunlessBlock = {\n  \t\t\tt: SECTION,\n  \t\t\tn: SECTION_UNLESS,\n  \t\t\tf: []\n  \t\t};\n\n  \t\tutils_refineExpression(expression, unlessBlock);\n  \t}\n\n  \treturn unlessBlock;\n  }\n\n  function invert(expression) {\n  \tif (expression.t === PREFIX_OPERATOR && expression.s === \"!\") {\n  \t\treturn expression.o;\n  \t}\n\n  \treturn {\n  \t\tt: PREFIX_OPERATOR,\n  \t\ts: \"!\",\n  \t\to: parensIfNecessary(expression)\n  \t};\n  }\n\n  function mustache_readSection__combine(expressions) {\n  \tif (expressions.length === 1) {\n  \t\treturn expressions[0];\n  \t}\n\n  \treturn {\n  \t\tt: INFIX_OPERATOR,\n  \t\ts: \"&&\",\n  \t\to: [parensIfNecessary(expressions[0]), parensIfNecessary(mustache_readSection__combine(expressions.slice(1)))]\n  \t};\n  }\n\n  function parensIfNecessary(expression) {\n  \t// TODO only wrap if necessary\n  \treturn {\n  \t\tt: BRACKETED,\n  \t\tx: expression\n  \t};\n  }\n\n  var converters_readHtmlComment = readHtmlComment;\n  var OPEN_COMMENT = \"<!--\",\n      CLOSE_COMMENT = \"-->\";\n  function readHtmlComment(parser) {\n  \tvar start, content, remaining, endIndex, comment;\n\n  \tstart = parser.pos;\n\n  \tif (!parser.matchString(OPEN_COMMENT)) {\n  \t\treturn null;\n  \t}\n\n  \tremaining = parser.remaining();\n  \tendIndex = remaining.indexOf(CLOSE_COMMENT);\n\n  \tif (endIndex === -1) {\n  \t\tparser.error(\"Illegal HTML - expected closing comment sequence ('-->')\");\n  \t}\n\n  \tcontent = remaining.substr(0, endIndex);\n  \tparser.pos += endIndex + 3;\n\n  \tcomment = {\n  \t\tt: COMMENT,\n  \t\tc: content\n  \t};\n\n  \tif (parser.includeLinePositions) {\n  \t\tcomment.p = parser.getLinePos(start);\n  \t}\n\n  \treturn comment;\n  }\n\n  var booleanAttributes, voidElementNames, htmlEntities, controlCharacters, entityPattern, lessThan, greaterThan, amp;\n\n  // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n  booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\n  voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n\n  htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 };\n  controlCharacters = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376];\n  entityPattern = new RegExp(\"&(#?(?:x[\\\\w\\\\d]+|\\\\d+|\" + Object.keys(htmlEntities).join(\"|\") + \"));?\", \"g\");\n\n  function decodeCharacterReferences(html) {\n  \treturn html.replace(entityPattern, function (match, entity) {\n  \t\tvar code;\n\n  \t\t// Handle named entities\n  \t\tif (entity[0] !== \"#\") {\n  \t\t\tcode = htmlEntities[entity];\n  \t\t} else if (entity[1] === \"x\") {\n  \t\t\tcode = parseInt(entity.substring(2), 16);\n  \t\t} else {\n  \t\t\tcode = parseInt(entity.substring(1), 10);\n  \t\t}\n\n  \t\tif (!code) {\n  \t\t\treturn match;\n  \t\t}\n\n  \t\treturn String.fromCharCode(validateCode(code));\n  \t});\n  }\n\n  // some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n  // code points with alternatives in some cases - since we're bypassing that mechanism, we need\n  // to replace them ourselves\n  //\n  // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n  function validateCode(code) {\n  \tif (!code) {\n  \t\treturn 65533;\n  \t}\n\n  \t// line feed becomes generic whitespace\n  \tif (code === 10) {\n  \t\treturn 32;\n  \t}\n\n  \t// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n  \tif (code < 128) {\n  \t\treturn code;\n  \t}\n\n  \t// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n  \t// to correct the mistake or we'll end up with missing  signs and so on\n  \tif (code <= 159) {\n  \t\treturn controlCharacters[code - 128];\n  \t}\n\n  \t// basic multilingual plane\n  \tif (code < 55296) {\n  \t\treturn code;\n  \t}\n\n  \t// UTF-16 surrogate halves\n  \tif (code <= 57343) {\n  \t\treturn 65533;\n  \t}\n\n  \t// rest of the basic multilingual plane\n  \tif (code <= 65535) {\n  \t\treturn code;\n  \t}\n\n  \treturn 65533;\n  }\n\n  lessThan = /</g;\n  greaterThan = />/g;\n  amp = /&/g;\n\n  function escapeHtml(str) {\n  \treturn str.replace(amp, \"&amp;\").replace(lessThan, \"&lt;\").replace(greaterThan, \"&gt;\");\n  }\n\n  var leadingLinebreak = /^\\s*\\r?\\n/,\n      trailingLinebreak = /\\r?\\n\\s*$/;\n\n  var stripStandalones = function (items) {\n  \tvar i, current, backOne, backTwo, lastSectionItem;\n\n  \tfor (i = 1; i < items.length; i += 1) {\n  \t\tcurrent = items[i];\n  \t\tbackOne = items[i - 1];\n  \t\tbackTwo = items[i - 2];\n\n  \t\t// if we're at the end of a [text][comment][text] sequence...\n  \t\tif (isString(current) && isComment(backOne) && isString(backTwo)) {\n\n  \t\t\t// ... and the comment is a standalone (i.e. line breaks either side)...\n  \t\t\tif (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {\n\n  \t\t\t\t// ... then we want to remove the whitespace after the first line break\n  \t\t\t\titems[i - 2] = backTwo.replace(trailingLinebreak, \"\\n\");\n\n  \t\t\t\t// and the leading line break of the second text token\n  \t\t\t\titems[i] = current.replace(leadingLinebreak, \"\");\n  \t\t\t}\n  \t\t}\n\n  \t\t// if the current item is a section, and it is preceded by a linebreak, and\n  \t\t// its first item is a linebreak...\n  \t\tif (isSection(current) && isString(backOne)) {\n  \t\t\tif (trailingLinebreak.test(backOne) && isString(current.f[0]) && leadingLinebreak.test(current.f[0])) {\n  \t\t\t\titems[i - 1] = backOne.replace(trailingLinebreak, \"\\n\");\n  \t\t\t\tcurrent.f[0] = current.f[0].replace(leadingLinebreak, \"\");\n  \t\t\t}\n  \t\t}\n\n  \t\t// if the last item was a section, and it is followed by a linebreak, and\n  \t\t// its last item is a linebreak...\n  \t\tif (isString(current) && isSection(backOne)) {\n  \t\t\tlastSectionItem = lastItem(backOne.f);\n\n  \t\t\tif (isString(lastSectionItem) && trailingLinebreak.test(lastSectionItem) && leadingLinebreak.test(current)) {\n  \t\t\t\tbackOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, \"\\n\");\n  \t\t\t\titems[i] = current.replace(leadingLinebreak, \"\");\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn items;\n  };\n\n  function isString(item) {\n  \treturn typeof item === \"string\";\n  }\n\n  function isComment(item) {\n  \treturn item.t === COMMENT || item.t === DELIMCHANGE;\n  }\n\n  function isSection(item) {\n  \treturn (item.t === SECTION || item.t === INVERTED) && item.f;\n  }\n\n  var trimWhitespace = function (items, leadingPattern, trailingPattern) {\n  \tvar item;\n\n  \tif (leadingPattern) {\n  \t\titem = items[0];\n  \t\tif (typeof item === \"string\") {\n  \t\t\titem = item.replace(leadingPattern, \"\");\n\n  \t\t\tif (!item) {\n  \t\t\t\titems.shift();\n  \t\t\t} else {\n  \t\t\t\titems[0] = item;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tif (trailingPattern) {\n  \t\titem = lastItem(items);\n  \t\tif (typeof item === \"string\") {\n  \t\t\titem = item.replace(trailingPattern, \"\");\n\n  \t\t\tif (!item) {\n  \t\t\t\titems.pop();\n  \t\t\t} else {\n  \t\t\t\titems[items.length - 1] = item;\n  \t\t\t}\n  \t\t}\n  \t}\n  };\n\n  var utils_cleanup = cleanup;\n  var contiguousWhitespace = /[ \\t\\f\\r\\n]+/g;\n  var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;\n  var utils_cleanup__leadingWhitespace = /^[ \\t\\f\\r\\n]+/;\n  var trailingWhitespace = /[ \\t\\f\\r\\n]+$/;\n  var leadingNewLine = /^(?:\\r\\n|\\r|\\n)/;\n  var trailingNewLine = /(?:\\r\\n|\\r|\\n)$/;\n  function cleanup(items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace) {\n  \tvar i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, key;\n\n  \t// First pass - remove standalones and comments etc\n  \tstripStandalones(items);\n\n  \ti = items.length;\n  \twhile (i--) {\n  \t\titem = items[i];\n\n  \t\t// Remove delimiter changes, unsafe elements etc\n  \t\tif (item.exclude) {\n  \t\t\titems.splice(i, 1);\n  \t\t}\n\n  \t\t// Remove comments, unless we want to keep them\n  \t\telse if (stripComments && item.t === COMMENT) {\n  \t\t\titems.splice(i, 1);\n  \t\t}\n  \t}\n\n  \t// If necessary, remove leading and trailing whitespace\n  \ttrimWhitespace(items, removeLeadingWhitespace ? utils_cleanup__leadingWhitespace : null, removeTrailingWhitespace ? trailingWhitespace : null);\n\n  \ti = items.length;\n  \twhile (i--) {\n  \t\titem = items[i];\n\n  \t\t// Recurse\n  \t\tif (item.f) {\n  \t\t\tvar isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test(item.e);\n  \t\t\tpreserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;\n\n  \t\t\tif (!preserveWhitespace && isPreserveWhitespaceElement) {\n  \t\t\t\ttrimWhitespace(item.f, leadingNewLine, trailingNewLine);\n  \t\t\t}\n\n  \t\t\tif (!preserveWhitespaceInsideFragment) {\n  \t\t\t\tpreviousItem = items[i - 1];\n  \t\t\t\tnextItem = items[i + 1];\n\n  \t\t\t\t// if the previous item was a text item with trailing whitespace,\n  \t\t\t\t// remove leading whitespace inside the fragment\n  \t\t\t\tif (!previousItem || typeof previousItem === \"string\" && trailingWhitespace.test(previousItem)) {\n  \t\t\t\t\tremoveLeadingWhitespaceInsideFragment = true;\n  \t\t\t\t}\n\n  \t\t\t\t// and vice versa\n  \t\t\t\tif (!nextItem || typeof nextItem === \"string\" && utils_cleanup__leadingWhitespace.test(nextItem)) {\n  \t\t\t\t\tremoveTrailingWhitespaceInsideFragment = true;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tcleanup(item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  \t\t}\n\n  \t\t// Split if-else blocks into two (an if, and an unless)\n  \t\tif (item.l) {\n  \t\t\tcleanup(item.l.f, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n\n  \t\t\titems.splice(i + 1, 0, item.l);\n  \t\t\tdelete item.l; // TODO would be nice if there was a way around this\n  \t\t}\n\n  \t\t// Clean up element attributes\n  \t\tif (item.a) {\n  \t\t\tfor (key in item.a) {\n  \t\t\t\tif (item.a.hasOwnProperty(key) && typeof item.a[key] !== \"string\") {\n  \t\t\t\t\tcleanup(item.a[key], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// Clean up conditional attributes\n  \t\tif (item.m) {\n  \t\t\tcleanup(item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  \t\t}\n\n  \t\t// Clean up event handlers\n  \t\tif (item.v) {\n  \t\t\tfor (key in item.v) {\n  \t\t\t\tif (item.v.hasOwnProperty(key)) {\n  \t\t\t\t\t// clean up names\n  \t\t\t\t\tif (isArray(item.v[key].n)) {\n  \t\t\t\t\t\tcleanup(item.v[key].n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  \t\t\t\t\t}\n\n  \t\t\t\t\t// clean up params\n  \t\t\t\t\tif (isArray(item.v[key].d)) {\n  \t\t\t\t\t\tcleanup(item.v[key].d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// final pass - fuse text nodes together\n  \ti = items.length;\n  \twhile (i--) {\n  \t\tif (typeof items[i] === \"string\") {\n  \t\t\tif (typeof items[i + 1] === \"string\") {\n  \t\t\t\titems[i] = items[i] + items[i + 1];\n  \t\t\t\titems.splice(i + 1, 1);\n  \t\t\t}\n\n  \t\t\tif (!preserveWhitespace) {\n  \t\t\t\titems[i] = items[i].replace(contiguousWhitespace, \" \");\n  \t\t\t}\n\n  \t\t\tif (items[i] === \"\") {\n  \t\t\t\titems.splice(i, 1);\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  var element_readClosingTag = readClosingTag;\n  var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n  function readClosingTag(parser) {\n  \tvar start, tag;\n\n  \tstart = parser.pos;\n\n  \t// are we looking at a closing tag?\n  \tif (!parser.matchString(\"</\")) {\n  \t\treturn null;\n  \t}\n\n  \tif (tag = parser.matchPattern(closingTagPattern)) {\n  \t\tif (parser.inside && tag !== parser.inside) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: CLOSING_TAG,\n  \t\t\te: tag\n  \t\t};\n  \t}\n\n  \t// We have an illegal closing tag, report it\n  \tparser.pos -= 2;\n  \tparser.error(\"Illegal closing tag\");\n  }\n\n  var getLowestIndex = function (haystack, needles) {\n  \tvar i, index, lowest;\n\n  \ti = needles.length;\n  \twhile (i--) {\n  \t\tindex = haystack.indexOf(needles[i]);\n\n  \t\t// short circuit\n  \t\tif (!index) {\n  \t\t\treturn 0;\n  \t\t}\n\n  \t\tif (index === -1) {\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tif (!lowest || index < lowest) {\n  \t\t\tlowest = index;\n  \t\t}\n  \t}\n\n  \treturn lowest || -1;\n  };\n\n  var element_readAttribute = readAttribute;\n\n  var attributeNamePattern = /^[^\\s\"'>\\/=]+/,\n      unquotedAttributeValueTextPattern = /^[^\\s\"'=<>`]+/;\n  function readAttribute(parser) {\n  \tvar attr, name, value;\n\n  \tparser.allowWhitespace();\n\n  \tname = parser.matchPattern(attributeNamePattern);\n  \tif (!name) {\n  \t\treturn null;\n  \t}\n\n  \tattr = { name: name };\n\n  \tvalue = readAttributeValue(parser);\n  \tif (value != null) {\n  \t\t// not null/undefined\n  \t\tattr.value = value;\n  \t}\n\n  \treturn attr;\n  }\n\n  function readAttributeValue(parser) {\n  \tvar start, valueStart, startDepth, value;\n\n  \tstart = parser.pos;\n\n  \t// next character must be `=`, `/`, `>` or whitespace\n  \tif (!/[=\\/>\\s]/.test(parser.nextChar())) {\n  \t\tparser.error(\"Expected `=`, `/`, `>` or whitespace\");\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"=\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tvalueStart = parser.pos;\n  \tstartDepth = parser.sectionDepth;\n\n  \tvalue = readQuotedAttributeValue(parser, \"'\") || readQuotedAttributeValue(parser, \"\\\"\") || readUnquotedAttributeValue(parser);\n\n  \tif (value === null) {\n  \t\tparser.error(\"Expected valid attribute value\");\n  \t}\n\n  \tif (parser.sectionDepth !== startDepth) {\n  \t\tparser.pos = valueStart;\n  \t\tparser.error(\"An attribute value must contain as many opening section tags as closing section tags\");\n  \t}\n\n  \tif (!value.length) {\n  \t\treturn \"\";\n  \t}\n\n  \tif (value.length === 1 && typeof value[0] === \"string\") {\n  \t\treturn decodeCharacterReferences(value[0]);\n  \t}\n\n  \treturn value;\n  }\n\n  function readUnquotedAttributeValueToken(parser) {\n  \tvar start, text, haystack, needles, index;\n\n  \tstart = parser.pos;\n\n  \ttext = parser.matchPattern(unquotedAttributeValueTextPattern);\n\n  \tif (!text) {\n  \t\treturn null;\n  \t}\n\n  \thaystack = text;\n  \tneedles = parser.tags.map(function (t) {\n  \t\treturn t.open;\n  \t}); // TODO refactor... we do this in readText.js as well\n\n  \tif ((index = getLowestIndex(haystack, needles)) !== -1) {\n  \t\ttext = text.substr(0, index);\n  \t\tparser.pos = start + text.length;\n  \t}\n\n  \treturn text;\n  }\n\n  function readUnquotedAttributeValue(parser) {\n  \tvar tokens, token;\n\n  \tparser.inAttribute = true;\n\n  \ttokens = [];\n\n  \ttoken = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  \twhile (token !== null) {\n  \t\ttokens.push(token);\n  \t\ttoken = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  \t}\n\n  \tif (!tokens.length) {\n  \t\treturn null;\n  \t}\n\n  \tparser.inAttribute = false;\n  \treturn tokens;\n  }\n\n  function readQuotedAttributeValue(parser, quoteMark) {\n  \tvar start, tokens, token;\n\n  \tstart = parser.pos;\n\n  \tif (!parser.matchString(quoteMark)) {\n  \t\treturn null;\n  \t}\n\n  \tparser.inAttribute = quoteMark;\n\n  \ttokens = [];\n\n  \ttoken = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  \twhile (token !== null) {\n  \t\ttokens.push(token);\n  \t\ttoken = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  \t}\n\n  \tif (!parser.matchString(quoteMark)) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tparser.inAttribute = false;\n\n  \treturn tokens;\n  }\n\n  function readQuotedStringToken(parser, quoteMark) {\n  \tvar start, index, haystack, needles;\n\n  \tstart = parser.pos;\n  \thaystack = parser.remaining();\n\n  \tneedles = parser.tags.map(function (t) {\n  \t\treturn t.open;\n  \t}); // TODO refactor... we do this in readText.js as well\n  \tneedles.push(quoteMark);\n\n  \tindex = getLowestIndex(haystack, needles);\n\n  \tif (index === -1) {\n  \t\tparser.error(\"Quoted attribute value must have a closing quote\");\n  \t}\n\n  \tif (!index) {\n  \t\treturn null;\n  \t}\n\n  \tparser.pos += index;\n  \treturn haystack.substr(0, index);\n  }\n\n  var JsonParser, specials, specialsPattern, parseJSON__numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;\n\n  specials = {\n  \t\"true\": true,\n  \t\"false\": false,\n  \tundefined: undefined,\n  \t\"null\": null\n  };\n\n  specialsPattern = new RegExp(\"^(?:\" + Object.keys(specials).join(\"|\") + \")\");\n  parseJSON__numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n  placeholderPattern = /\\$\\{([^\\}]+)\\}/g;\n  placeholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\n  onlyWhitespace = /^\\s*$/;\n\n  JsonParser = parse_Parser.extend({\n  \tinit: function (str, options) {\n  \t\tthis.values = options.values;\n  \t\tthis.allowWhitespace();\n  \t},\n\n  \tpostProcess: function (result) {\n  \t\tif (result.length !== 1 || !onlyWhitespace.test(this.leftover)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn { value: result[0].v };\n  \t},\n\n  \tconverters: [function getPlaceholder(parser) {\n  \t\tvar placeholder;\n\n  \t\tif (!parser.values) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tplaceholder = parser.matchPattern(placeholderAtStartPattern);\n\n  \t\tif (placeholder && parser.values.hasOwnProperty(placeholder)) {\n  \t\t\treturn { v: parser.values[placeholder] };\n  \t\t}\n  \t}, function getSpecial(parser) {\n  \t\tvar special;\n\n  \t\tif (special = parser.matchPattern(specialsPattern)) {\n  \t\t\treturn { v: specials[special] };\n  \t\t}\n  \t}, function getNumber(parser) {\n  \t\tvar number;\n\n  \t\tif (number = parser.matchPattern(parseJSON__numberPattern)) {\n  \t\t\treturn { v: +number };\n  \t\t}\n  \t}, function getString(parser) {\n  \t\tvar stringLiteral = readStringLiteral(parser),\n  \t\t    values;\n\n  \t\tif (stringLiteral && (values = parser.values)) {\n  \t\t\treturn {\n  \t\t\t\tv: stringLiteral.v.replace(placeholderPattern, function (match, $1) {\n  \t\t\t\t\treturn $1 in values ? values[$1] : $1;\n  \t\t\t\t})\n  \t\t\t};\n  \t\t}\n\n  \t\treturn stringLiteral;\n  \t}, function getObject(parser) {\n  \t\tvar result, pair;\n\n  \t\tif (!parser.matchString(\"{\")) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tresult = {};\n\n  \t\tparser.allowWhitespace();\n\n  \t\tif (parser.matchString(\"}\")) {\n  \t\t\treturn { v: result };\n  \t\t}\n\n  \t\twhile (pair = getKeyValuePair(parser)) {\n  \t\t\tresult[pair.key] = pair.value;\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif (parser.matchString(\"}\")) {\n  \t\t\t\treturn { v: result };\n  \t\t\t}\n\n  \t\t\tif (!parser.matchString(\",\")) {\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn null;\n  \t}, function getArray(parser) {\n  \t\tvar result, valueToken;\n\n  \t\tif (!parser.matchString(\"[\")) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tresult = [];\n\n  \t\tparser.allowWhitespace();\n\n  \t\tif (parser.matchString(\"]\")) {\n  \t\t\treturn { v: result };\n  \t\t}\n\n  \t\twhile (valueToken = parser.read()) {\n  \t\t\tresult.push(valueToken.v);\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif (parser.matchString(\"]\")) {\n  \t\t\t\treturn { v: result };\n  \t\t\t}\n\n  \t\t\tif (!parser.matchString(\",\")) {\n  \t\t\t\treturn null;\n  \t\t\t}\n\n  \t\t\tparser.allowWhitespace();\n  \t\t}\n\n  \t\treturn null;\n  \t}]\n  });\n\n  function getKeyValuePair(parser) {\n  \tvar key, valueToken, pair;\n\n  \tparser.allowWhitespace();\n\n  \tkey = shared_readKey(parser);\n\n  \tif (!key) {\n  \t\treturn null;\n  \t}\n\n  \tpair = { key: key };\n\n  \tparser.allowWhitespace();\n  \tif (!parser.matchString(\":\")) {\n  \t\treturn null;\n  \t}\n  \tparser.allowWhitespace();\n\n  \tvalueToken = parser.read();\n  \tif (!valueToken) {\n  \t\treturn null;\n  \t}\n\n  \tpair.value = valueToken.v;\n\n  \treturn pair;\n  }\n\n  var parseJSON = function (str, values) {\n  \tvar parser = new JsonParser(str, {\n  \t\tvalues: values\n  \t});\n\n  \treturn parser.result;\n  };\n\n  // TODO clean this up, it's shocking\n  var element_processDirective = processDirective;\n  var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\\(/,\n      methodCallExcessPattern = /\\)\\s*$/,\n      ExpressionParser;\n\n  ExpressionParser = parse_Parser.extend({\n  \tconverters: [converters_readExpression]\n  });\n  function processDirective(tokens, parentParser) {\n  \tvar result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;\n\n  \tif (typeof tokens === \"string\") {\n  \t\tif (match = methodCallPattern.exec(tokens)) {\n  \t\t\tvar end = tokens.lastIndexOf(\")\");\n\n  \t\t\t// check for invalid method calls\n  \t\t\tif (!methodCallExcessPattern.test(tokens)) {\n  \t\t\t\tparentParser.error(\"Invalid input after method call expression '\" + tokens.slice(end + 1) + \"'\");\n  \t\t\t}\n\n  \t\t\tresult = { m: match[1] };\n  \t\t\targs = \"[\" + tokens.slice(result.m.length + 1, end) + \"]\";\n\n  \t\t\tparser = new ExpressionParser(args);\n  \t\t\tresult.a = utils_flattenExpression(parser.result[0]);\n\n  \t\t\treturn result;\n  \t\t}\n\n  \t\tif (tokens.indexOf(\":\") === -1) {\n  \t\t\treturn tokens.trim();\n  \t\t}\n\n  \t\ttokens = [tokens];\n  \t}\n\n  \tresult = {};\n\n  \tdirectiveName = [];\n  \tdirectiveArgs = [];\n\n  \tif (tokens) {\n  \t\twhile (tokens.length) {\n  \t\t\ttoken = tokens.shift();\n\n  \t\t\tif (typeof token === \"string\") {\n  \t\t\t\tcolonIndex = token.indexOf(\":\");\n\n  \t\t\t\tif (colonIndex === -1) {\n  \t\t\t\t\tdirectiveName.push(token);\n  \t\t\t\t} else {\n\n  \t\t\t\t\t// is the colon the first character?\n  \t\t\t\t\tif (colonIndex) {\n  \t\t\t\t\t\t// no\n  \t\t\t\t\t\tdirectiveName.push(token.substr(0, colonIndex));\n  \t\t\t\t\t}\n\n  \t\t\t\t\t// if there is anything after the colon in this token, treat\n  \t\t\t\t\t// it as the first token of the directiveArgs fragment\n  \t\t\t\t\tif (token.length > colonIndex + 1) {\n  \t\t\t\t\t\tdirectiveArgs[0] = token.substring(colonIndex + 1);\n  \t\t\t\t\t}\n\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t} else {\n  \t\t\t\tdirectiveName.push(token);\n  \t\t\t}\n  \t\t}\n\n  \t\tdirectiveArgs = directiveArgs.concat(tokens);\n  \t}\n\n  \tif (!directiveName.length) {\n  \t\tresult = \"\";\n  \t} else if (directiveArgs.length || typeof directiveName !== \"string\") {\n  \t\tresult = {\n  \t\t\t// TODO is this really necessary? just use the array\n  \t\t\tn: directiveName.length === 1 && typeof directiveName[0] === \"string\" ? directiveName[0] : directiveName\n  \t\t};\n\n  \t\tif (directiveArgs.length === 1 && typeof directiveArgs[0] === \"string\") {\n  \t\t\tparsed = parseJSON(\"[\" + directiveArgs[0] + \"]\");\n  \t\t\tresult.a = parsed ? parsed.value : directiveArgs[0].trim();\n  \t\t} else {\n  \t\t\tresult.d = directiveArgs;\n  \t\t}\n  \t} else {\n  \t\tresult = directiveName;\n  \t}\n\n  \treturn result;\n  }\n\n  var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/,\n      validTagNameFollower = /^[\\s\\n\\/>]/,\n      onPattern = /^on/,\n      proxyEventPattern = /^on-([a-zA-Z\\\\*\\\\.$_][a-zA-Z\\\\*\\\\.$_0-9\\-]+)$/,\n      reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,\n      directives = { \"intro-outro\": \"t0\", intro: \"t1\", outro: \"t2\", decorator: \"o\" },\n      exclude = { exclude: true },\n      disallowedContents;\n\n  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\n  disallowedContents = {\n  \tli: [\"li\"],\n  \tdt: [\"dt\", \"dd\"],\n  \tdd: [\"dt\", \"dd\"],\n  \tp: \"address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul\".split(\" \"),\n  \trt: [\"rt\", \"rp\"],\n  \trp: [\"rt\", \"rp\"],\n  \toptgroup: [\"optgroup\"],\n  \toption: [\"option\", \"optgroup\"],\n  \tthead: [\"tbody\", \"tfoot\"],\n  \ttbody: [\"tbody\", \"tfoot\"],\n  \ttfoot: [\"tbody\"],\n  \ttr: [\"tr\", \"tbody\"],\n  \ttd: [\"td\", \"th\", \"tr\"],\n  \tth: [\"td\", \"th\", \"tr\"]\n  };\n\n  var converters_readElement = readElement;\n\n  function readElement(parser) {\n  \tvar start, element, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, partials, hasPartials, child, closed, pos, remaining, closingTag;\n\n  \tstart = parser.pos;\n\n  \tif (parser.inside || parser.inAttribute) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchString(\"<\")) {\n  \t\treturn null;\n  \t}\n\n  \t// if this is a closing tag, abort straight away\n  \tif (parser.nextChar() === \"/\") {\n  \t\treturn null;\n  \t}\n\n  \telement = {};\n  \tif (parser.includeLinePositions) {\n  \t\telement.p = parser.getLinePos(start);\n  \t}\n\n  \tif (parser.matchString(\"!\")) {\n  \t\telement.t = DOCTYPE;\n  \t\tif (!parser.matchPattern(/^doctype/i)) {\n  \t\t\tparser.error(\"Expected DOCTYPE declaration\");\n  \t\t}\n\n  \t\telement.a = parser.matchPattern(/^(.+?)>/);\n  \t\treturn element;\n  \t}\n\n  \telement.t = ELEMENT;\n\n  \t// element name\n  \telement.e = parser.matchPattern(tagNamePattern);\n  \tif (!element.e) {\n  \t\treturn null;\n  \t}\n\n  \t// next character must be whitespace, closing solidus or '>'\n  \tif (!validTagNameFollower.test(parser.nextChar())) {\n  \t\tparser.error(\"Illegal tag name\");\n  \t}\n\n  \taddProxyEvent = function (name, directive) {\n  \t\tvar directiveName = directive.n || directive;\n\n  \t\tif (reservedEventNames.test(directiveName)) {\n  \t\t\tparser.pos -= directiveName.length;\n  \t\t\tparser.error(\"Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)\");\n  \t\t}\n\n  \t\telement.v[name] = directive;\n  \t};\n\n  \tparser.allowWhitespace();\n\n  \t// directives and attributes\n  \twhile (attribute = converters_readMustache(parser) || element_readAttribute(parser)) {\n  \t\t// regular attributes\n  \t\tif (attribute.name) {\n  \t\t\t// intro, outro, decorator\n  \t\t\tif (directiveName = directives[attribute.name]) {\n  \t\t\t\telement[directiveName] = element_processDirective(attribute.value, parser);\n  \t\t\t}\n\n  \t\t\t// on-click etc\n  \t\t\telse if (match = proxyEventPattern.exec(attribute.name)) {\n  \t\t\t\tif (!element.v) element.v = {};\n  \t\t\t\tdirective = element_processDirective(attribute.value, parser);\n  \t\t\t\taddProxyEvent(match[1], directive);\n  \t\t\t} else {\n  \t\t\t\tif (!parser.sanitizeEventAttributes || !onPattern.test(attribute.name)) {\n  \t\t\t\t\tif (!element.a) element.a = {};\n  \t\t\t\t\telement.a[attribute.name] = attribute.value || (attribute.value === \"\" ? \"\" : 0);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// {{#if foo}}class='foo'{{/if}}\n  \t\telse {\n  \t\t\tif (!element.m) element.m = [];\n  \t\t\telement.m.push(attribute);\n  \t\t}\n\n  \t\tparser.allowWhitespace();\n  \t}\n\n  \t// allow whitespace before closing solidus\n  \tparser.allowWhitespace();\n\n  \t// self-closing solidus?\n  \tif (parser.matchString(\"/\")) {\n  \t\tselfClosing = true;\n  \t}\n\n  \t// closing angle bracket\n  \tif (!parser.matchString(\">\")) {\n  \t\treturn null;\n  \t}\n\n  \tvar lowerCaseName = element.e.toLowerCase();\n  \tvar preserveWhitespace = parser.preserveWhitespace;\n\n  \tif (!selfClosing && !voidElementNames.test(element.e)) {\n  \t\tparser.elementStack.push(lowerCaseName);\n\n  \t\t// Special case - if we open a script element, further tags should\n  \t\t// be ignored unless they're a closing script element\n  \t\tif (lowerCaseName === \"script\" || lowerCaseName === \"style\") {\n  \t\t\tparser.inside = lowerCaseName;\n  \t\t}\n\n  \t\tchildren = [];\n  \t\tpartials = create(null);\n\n  \t\tdo {\n  \t\t\tpos = parser.pos;\n  \t\t\tremaining = parser.remaining();\n\n  \t\t\t// if for example we're in an <li> element, and we see another\n  \t\t\t// <li> tag, close the first so they become siblings\n  \t\t\tif (!canContain(lowerCaseName, remaining)) {\n  \t\t\t\tclosed = true;\n  \t\t\t}\n\n  \t\t\t// closing tag\n  \t\t\telse if (closingTag = element_readClosingTag(parser)) {\n  \t\t\t\tclosed = true;\n\n  \t\t\t\tvar closingTagName = closingTag.e.toLowerCase();\n\n  \t\t\t\t// if this *isn't* the closing tag for the current element...\n  \t\t\t\tif (closingTagName !== lowerCaseName) {\n  \t\t\t\t\t// rewind parser\n  \t\t\t\t\tparser.pos = pos;\n\n  \t\t\t\t\t// if it doesn't close a parent tag, error\n  \t\t\t\t\tif (! ~parser.elementStack.indexOf(closingTagName)) {\n  \t\t\t\t\t\tvar errorMessage = \"Unexpected closing tag\";\n\n  \t\t\t\t\t\t// add additional help for void elements, since component names\n  \t\t\t\t\t\t// might clash with them\n  \t\t\t\t\t\tif (voidElementNames.test(closingTagName)) {\n  \t\t\t\t\t\t\terrorMessage += \" (<\" + closingTagName + \"> is a void element - it cannot contain children)\";\n  \t\t\t\t\t\t}\n\n  \t\t\t\t\t\tparser.error(errorMessage);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\t// implicit close by closing section tag. TODO clean this up\n  \t\t\telse if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {\n  \t\t\t\tclosed = true;\n  \t\t\t\tparser.pos = pos;\n  \t\t\t} else {\n  \t\t\t\tif (child = parser.read(PARTIAL_READERS)) {\n  \t\t\t\t\tif (partials[child.n]) {\n  \t\t\t\t\t\tparser.pos = pos;\n  \t\t\t\t\t\tparser.error(\"Duplicate partial definition\");\n  \t\t\t\t\t}\n\n  \t\t\t\t\tutils_cleanup(child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);\n\n  \t\t\t\t\tpartials[child.n] = child.f;\n  \t\t\t\t\thasPartials = true;\n  \t\t\t\t} else {\n  \t\t\t\t\tif (child = parser.read(READERS)) {\n  \t\t\t\t\t\tchildren.push(child);\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tclosed = true;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} while (!closed);\n\n  \t\tif (children.length) {\n  \t\t\telement.f = children;\n  \t\t}\n\n  \t\tif (hasPartials) {\n  \t\t\telement.p = partials;\n  \t\t}\n\n  \t\tparser.elementStack.pop();\n  \t}\n\n  \tparser.inside = null;\n\n  \tif (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {\n  \t\treturn exclude;\n  \t}\n\n  \treturn element;\n  }\n\n  function canContain(name, remaining) {\n  \tvar match, disallowed;\n\n  \tmatch = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);\n  \tdisallowed = disallowedContents[name];\n\n  \tif (!match || !disallowed) {\n  \t\treturn true;\n  \t}\n\n  \treturn ! ~disallowed.indexOf(match[1].toLowerCase());\n  }\n\n  var converters_readText = readText;\n  function readText(parser) {\n  \tvar index, remaining, disallowed, barrier;\n\n  \tremaining = parser.remaining();\n\n  \tbarrier = parser.inside ? \"</\" + parser.inside : \"<\";\n\n  \tif (parser.inside && !parser.interpolate[parser.inside]) {\n  \t\tindex = remaining.indexOf(barrier);\n  \t} else {\n  \t\tdisallowed = parser.tags.map(function (t) {\n  \t\t\treturn t.open;\n  \t\t});\n  \t\tdisallowed = disallowed.concat(parser.tags.map(function (t) {\n  \t\t\treturn \"\\\\\" + t.open;\n  \t\t}));\n\n  \t\t// http://developers.whatwg.org/syntax.html#syntax-attributes\n  \t\tif (parser.inAttribute === true) {\n  \t\t\t// we're inside an unquoted attribute value\n  \t\t\tdisallowed.push(\"\\\"\", \"'\", \"=\", \"<\", \">\", \"`\");\n  \t\t} else if (parser.inAttribute) {\n  \t\t\t// quoted attribute value\n  \t\t\tdisallowed.push(parser.inAttribute);\n  \t\t} else {\n  \t\t\tdisallowed.push(barrier);\n  \t\t}\n\n  \t\tindex = getLowestIndex(remaining, disallowed);\n  \t}\n\n  \tif (!index) {\n  \t\treturn null;\n  \t}\n\n  \tif (index === -1) {\n  \t\tindex = remaining.length;\n  \t}\n\n  \tparser.pos += index;\n\n  \treturn parser.inside ? remaining.substr(0, index) : decodeCharacterReferences(remaining.substr(0, index));\n  }\n\n  var utils_escapeRegExp = escapeRegExp;\n  var utils_escapeRegExp__pattern = /[-/\\\\^$*+?.()|[\\]{}]/g;\n  function escapeRegExp(str) {\n  \treturn str.replace(utils_escapeRegExp__pattern, \"\\\\$&\");\n  }\n\n  var converters_readPartialDefinitionComment = readPartialDefinitionComment;\n\n  var startPattern = /^<!--\\s*/,\n      namePattern = /s*>\\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\\s*/,\n      finishPattern = /\\s*-->/,\n      child;\n\n  function readPartialDefinitionComment(parser) {\n  \tvar firstPos = parser.pos,\n  \t    open = parser.standardDelimiters[0],\n  \t    close = parser.standardDelimiters[1],\n  \t    content = undefined,\n  \t    closed = undefined;\n\n  \tif (!parser.matchPattern(startPattern) || !parser.matchString(open)) {\n  \t\tparser.pos = firstPos;\n  \t\treturn null;\n  \t}\n\n  \tvar name = parser.matchPattern(namePattern);\n\n  \twarnOnceIfDebug(\"Inline partial comments are deprecated.\\nUse this...\\n  {{#partial \" + name + \"}} ... {{/partial}}\\n\\n...instead of this:\\n  <!-- {{>\" + name + \"}} --> ... <!-- {{/\" + name + \"}} -->'\");\n\n  \t// make sure the rest of the comment is in the correct place\n  \tif (!parser.matchString(close) || !parser.matchPattern(finishPattern)) {\n  \t\tparser.pos = firstPos;\n  \t\treturn null;\n  \t}\n\n  \tcontent = [];\n\n  \tvar endPattern = new RegExp(\"^<!--\\\\s*\" + utils_escapeRegExp(open) + \"\\\\s*\\\\/\\\\s*\" + name + \"\\\\s*\" + utils_escapeRegExp(close) + \"\\\\s*-->\");\n\n  \tdo {\n  \t\tif (parser.matchPattern(endPattern)) {\n  \t\t\tclosed = true;\n  \t\t} else {\n  \t\t\tchild = parser.read(READERS);\n  \t\t\tif (!child) {\n  \t\t\t\tparser.error(\"expected closing comment ('<!-- \" + open + \"/\" + name + \"\" + close + \" -->')\");\n  \t\t\t}\n\n  \t\t\tcontent.push(child);\n  \t\t}\n  \t} while (!closed);\n\n  \treturn {\n  \t\tt: INLINE_PARTIAL,\n  \t\tf: content,\n  \t\tn: name\n  \t};\n  }\n\n  var converters_readPartialDefinitionSection = readPartialDefinitionSection;\n  var partialDefinitionSectionPattern = /^#\\s*partial\\s+/;\n  function readPartialDefinitionSection(parser) {\n  \tvar start, name, content, child, closed;\n\n  \tstart = parser.pos;\n\n  \tvar delimiters = parser.standardDelimiters;\n\n  \tif (!parser.matchString(delimiters[0])) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchPattern(partialDefinitionSectionPattern)) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tname = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/);\n\n  \tif (!name) {\n  \t\tparser.error(\"expected legal partial name\");\n  \t}\n\n  \tif (!parser.matchString(delimiters[1])) {\n  \t\tparser.error(\"Expected closing delimiter '\" + delimiters[1] + \"'\");\n  \t}\n\n  \tcontent = [];\n\n  \tdo {\n  \t\t// TODO clean this up\n  \t\tif (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {\n  \t\t\tif (!child.r === \"partial\") {\n  \t\t\t\tparser.error(\"Expected \" + delimiters[0] + \"/partial\" + delimiters[1]);\n  \t\t\t}\n\n  \t\t\tclosed = true;\n  \t\t} else {\n  \t\t\tchild = parser.read(READERS);\n\n  \t\t\tif (!child) {\n  \t\t\t\tparser.error(\"Expected \" + delimiters[0] + \"/partial\" + delimiters[1]);\n  \t\t\t}\n\n  \t\t\tcontent.push(child);\n  \t\t}\n  \t} while (!closed);\n\n  \treturn {\n  \t\tt: INLINE_PARTIAL,\n  \t\tn: name,\n  \t\tf: content\n  \t};\n  }\n\n  var converters_readTemplate = readTemplate;\n  function readTemplate(parser) {\n  \tvar fragment = [];\n  \tvar partials = create(null);\n  \tvar hasPartials = false;\n\n  \tvar preserveWhitespace = parser.preserveWhitespace;\n\n  \twhile (parser.pos < parser.str.length) {\n  \t\tvar pos = parser.pos,\n  \t\t    item = undefined,\n  \t\t    partial = undefined;\n\n  \t\tif (partial = parser.read(PARTIAL_READERS)) {\n  \t\t\tif (partials[partial.n]) {\n  \t\t\t\tparser.pos = pos;\n  \t\t\t\tparser.error(\"Duplicated partial definition\");\n  \t\t\t}\n\n  \t\t\tutils_cleanup(partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);\n\n  \t\t\tpartials[partial.n] = partial.f;\n  \t\t\thasPartials = true;\n  \t\t} else if (item = parser.read(READERS)) {\n  \t\t\tfragment.push(item);\n  \t\t} else {\n  \t\t\tparser.error(\"Unexpected template content\");\n  \t\t}\n  \t}\n\n  \tvar result = {\n  \t\tv: TEMPLATE_VERSION,\n  \t\tt: fragment\n  \t};\n\n  \tif (hasPartials) {\n  \t\tresult.p = partials;\n  \t}\n\n  \treturn result;\n  }\n\n  var _parse = parse;\n\n  var STANDARD_READERS = [mustache_readPartial, mustache_readUnescaped, mustache_readSection, mustache_readYielder, mustache_readInterpolator, readMustacheComment];\n  var TRIPLE_READERS = [mustache_readTriple];\n  var STATIC_READERS = [mustache_readUnescaped, mustache_readSection, mustache_readInterpolator]; // TODO does it make sense to have a static section?\n\n  var StandardParser = undefined;\n  function parse(template, options) {\n  \treturn new StandardParser(template, options || {}).result;\n  }\n\n  var READERS = [converters_readMustache, converters_readHtmlComment, converters_readElement, converters_readText];\n  var PARTIAL_READERS = [converters_readPartialDefinitionComment, converters_readPartialDefinitionSection];\n\n  StandardParser = parse_Parser.extend({\n  \tinit: function (str, options) {\n  \t\tvar tripleDelimiters = options.tripleDelimiters || [\"{{{\", \"}}}\"],\n  \t\t    staticDelimiters = options.staticDelimiters || [\"[[\", \"]]\"],\n  \t\t    staticTripleDelimiters = options.staticTripleDelimiters || [\"[[[\", \"]]]\"];\n\n  \t\tthis.standardDelimiters = options.delimiters || [\"{{\", \"}}\"];\n\n  \t\tthis.tags = [{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS }, { isStatic: false, isTriple: true, open: tripleDelimiters[0], close: tripleDelimiters[1], readers: TRIPLE_READERS }, { isStatic: true, isTriple: false, open: staticDelimiters[0], close: staticDelimiters[1], readers: STATIC_READERS }, { isStatic: true, isTriple: true, open: staticTripleDelimiters[0], close: staticTripleDelimiters[1], readers: TRIPLE_READERS }];\n\n  \t\tthis.sortMustacheTags();\n\n  \t\tthis.sectionDepth = 0;\n  \t\tthis.elementStack = [];\n\n  \t\tthis.interpolate = {\n  \t\t\tscript: !options.interpolate || options.interpolate.script !== false,\n  \t\t\tstyle: !options.interpolate || options.interpolate.style !== false\n  \t\t};\n\n  \t\tif (options.sanitize === true) {\n  \t\t\toptions.sanitize = {\n  \t\t\t\t// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n  \t\t\t\telements: \"applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title\".split(\" \"),\n  \t\t\t\teventAttributes: true\n  \t\t\t};\n  \t\t}\n\n  \t\tthis.stripComments = options.stripComments !== false;\n  \t\tthis.preserveWhitespace = options.preserveWhitespace;\n  \t\tthis.sanitizeElements = options.sanitize && options.sanitize.elements;\n  \t\tthis.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n  \t\tthis.includeLinePositions = options.includeLinePositions;\n  \t},\n\n  \tpostProcess: function (result) {\n  \t\t// special case - empty string\n  \t\tif (!result.length) {\n  \t\t\treturn { t: [], v: TEMPLATE_VERSION };\n  \t\t}\n\n  \t\tif (this.sectionDepth > 0) {\n  \t\t\tthis.error(\"A section was left open\");\n  \t\t}\n\n  \t\tutils_cleanup(result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace);\n\n  \t\treturn result[0];\n  \t},\n\n  \tconverters: [converters_readTemplate],\n\n  \tsortMustacheTags: function () {\n  \t\t// Sort in order of descending opening delimiter length (longer first),\n  \t\t// to protect against opening delimiters being substrings of each other\n  \t\tthis.tags.sort(function (a, b) {\n  \t\t\treturn b.open.length - a.open.length;\n  \t\t});\n  \t}\n  });\n\n  var parseOptions = [\"preserveWhitespace\", \"sanitize\", \"stripComments\", \"delimiters\", \"tripleDelimiters\", \"interpolate\"];\n\n  var parser = {\n  \tfromId: fromId, isHashedId: isHashedId, isParsed: isParsed, getParseOptions: getParseOptions, createHelper: template_parser__createHelper,\n  \tparse: doParse\n  };\n\n  function template_parser__createHelper(parseOptions) {\n  \tvar helper = create(parser);\n  \thelper.parse = function (template, options) {\n  \t\treturn doParse(template, options || parseOptions);\n  \t};\n  \treturn helper;\n  }\n\n  function doParse(template, parseOptions) {\n  \tif (!_parse) {\n  \t\tthrow new Error(\"Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser\");\n  \t}\n\n  \treturn _parse(template, parseOptions || this.options);\n  }\n\n  function fromId(id, options) {\n  \tvar template;\n\n  \tif (!isClient) {\n  \t\tif (options && options.noThrow) {\n  \t\t\treturn;\n  \t\t}\n  \t\tthrow new Error(\"Cannot retrieve template #\" + id + \" as Ractive is not running in a browser.\");\n  \t}\n\n  \tif (isHashedId(id)) {\n  \t\tid = id.substring(1);\n  \t}\n\n  \tif (!(template = document.getElementById(id))) {\n  \t\tif (options && options.noThrow) {\n  \t\t\treturn;\n  \t\t}\n  \t\tthrow new Error(\"Could not find template element with id #\" + id);\n  \t}\n\n  \tif (template.tagName.toUpperCase() !== \"SCRIPT\") {\n  \t\tif (options && options.noThrow) {\n  \t\t\treturn;\n  \t\t}\n  \t\tthrow new Error(\"Template element with id #\" + id + \", must be a <script> element\");\n  \t}\n\n  \treturn \"textContent\" in template ? template.textContent : template.innerHTML;\n  }\n\n  function isHashedId(id) {\n  \treturn id && id[0] === \"#\";\n  }\n\n  function isParsed(template) {\n  \treturn !(typeof template === \"string\");\n  }\n\n  function getParseOptions(ractive) {\n  \t// Could be Ractive or a Component\n  \tif (ractive.defaults) {\n  \t\tractive = ractive.defaults;\n  \t}\n\n  \treturn parseOptions.reduce(function (val, key) {\n  \t\tval[key] = ractive[key];\n  \t\treturn val;\n  \t}, {});\n  }\n\n  var template_parser = parser;\n\n  var templateConfigurator = {\n  \tname: \"template\",\n\n  \textend: function extend(Parent, proto, options) {\n  \t\tvar template;\n\n  \t\t// only assign if exists\n  \t\tif (\"template\" in options) {\n  \t\t\ttemplate = options.template;\n\n  \t\t\tif (typeof template === \"function\") {\n  \t\t\t\tproto.template = template;\n  \t\t\t} else {\n  \t\t\t\tproto.template = parseIfString(template, proto);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tinit: function init(Parent, ractive, options) {\n  \t\tvar template, fn;\n\n  \t\t// TODO because of prototypal inheritance, we might just be able to use\n  \t\t// ractive.template, and not bother passing through the Parent object.\n  \t\t// At present that breaks the test mocks' expectations\n  \t\ttemplate = \"template\" in options ? options.template : Parent.prototype.template;\n\n  \t\tif (typeof template === \"function\") {\n  \t\t\tfn = template;\n  \t\t\ttemplate = getDynamicTemplate(ractive, fn);\n\n  \t\t\tractive._config.template = {\n  \t\t\t\tfn: fn,\n  \t\t\t\tresult: template\n  \t\t\t};\n  \t\t}\n\n  \t\ttemplate = parseIfString(template, ractive);\n\n  \t\t// TODO the naming of this is confusing - ractive.template refers to [...],\n  \t\t// but Component.prototype.template refers to {v:1,t:[],p:[]}...\n  \t\t// it's unnecessary, because the developer never needs to access\n  \t\t// ractive.template\n  \t\tractive.template = template.t;\n\n  \t\tif (template.p) {\n  \t\t\textendPartials(ractive.partials, template.p);\n  \t\t}\n  \t},\n\n  \treset: function (ractive) {\n  \t\tvar result = resetValue(ractive),\n  \t\t    parsed;\n\n  \t\tif (result) {\n  \t\t\tparsed = parseIfString(result, ractive);\n\n  \t\t\tractive.template = parsed.t;\n  \t\t\textendPartials(ractive.partials, parsed.p, true);\n\n  \t\t\treturn true;\n  \t\t}\n  \t}\n  };\n\n  function resetValue(ractive) {\n  \tvar initial = ractive._config.template,\n  \t    result;\n\n  \t// If this isn't a dynamic template, there's nothing to do\n  \tif (!initial || !initial.fn) {\n  \t\treturn;\n  \t}\n\n  \tresult = getDynamicTemplate(ractive, initial.fn);\n\n  \t// TODO deep equality check to prevent unnecessary re-rendering\n  \t// in the case of already-parsed templates\n  \tif (result !== initial.result) {\n  \t\tinitial.result = result;\n  \t\tresult = parseIfString(result, ractive);\n  \t\treturn result;\n  \t}\n  }\n\n  function getDynamicTemplate(ractive, fn) {\n  \tvar helper = template_template__createHelper(template_parser.getParseOptions(ractive));\n  \treturn fn.call(ractive, helper);\n  }\n\n  function template_template__createHelper(parseOptions) {\n  \tvar helper = create(template_parser);\n  \thelper.parse = function (template, options) {\n  \t\treturn template_parser.parse(template, options || parseOptions);\n  \t};\n  \treturn helper;\n  }\n\n  function parseIfString(template, ractive) {\n  \tif (typeof template === \"string\") {\n  \t\t// ID of an element containing the template?\n  \t\tif (template[0] === \"#\") {\n  \t\t\ttemplate = template_parser.fromId(template);\n  \t\t}\n\n  \t\ttemplate = _parse(template, template_parser.getParseOptions(ractive));\n  \t}\n\n  \t// Check that the template even exists\n  \telse if (template == undefined) {\n  \t\tthrow new Error(\"The template cannot be \" + template + \".\");\n  \t}\n\n  \t// Check the parsed template has a version at all\n  \telse if (typeof template.v !== \"number\") {\n  \t\tthrow new Error(\"The template parser was passed a non-string template, but the template doesn't have a version.  Make sure you're passing in the template you think you are.\");\n  \t}\n\n  \t// Check we're using the correct version\n  \telse if (template.v !== TEMPLATE_VERSION) {\n  \t\tthrow new Error(\"Mismatched template version (expected \" + TEMPLATE_VERSION + \", got \" + template.v + \") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app\");\n  \t}\n\n  \treturn template;\n  }\n\n  function extendPartials(existingPartials, newPartials, overwrite) {\n  \tif (!newPartials) return;\n\n  \t// TODO there's an ambiguity here - we need to overwrite in the `reset()`\n  \t// case, but not initially...\n\n  \tfor (var key in newPartials) {\n  \t\tif (overwrite || !existingPartials.hasOwnProperty(key)) {\n  \t\t\texistingPartials[key] = newPartials[key];\n  \t\t}\n  \t}\n  }\n\n  var template_template = templateConfigurator;\n\n  var config_registries__registryNames, Registry, registries;\n\n  config_registries__registryNames = [\"adaptors\", \"components\", \"computed\", \"decorators\", \"easing\", \"events\", \"interpolators\", \"partials\", \"transitions\"];\n\n  Registry = function (name, useDefaults) {\n  \tthis.name = name;\n  \tthis.useDefaults = useDefaults;\n  };\n\n  Registry.prototype = {\n  \tconstructor: Registry,\n\n  \textend: function (Parent, proto, options) {\n  \t\tthis.configure(this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options);\n  \t},\n\n  \tinit: function () {},\n\n  \tconfigure: function (Parent, target, options) {\n  \t\tvar name = this.name,\n  \t\t    option = options[name],\n  \t\t    registry;\n\n  \t\tregistry = create(Parent[name]);\n\n  \t\tfor (var key in option) {\n  \t\t\tregistry[key] = option[key];\n  \t\t}\n\n  \t\ttarget[name] = registry;\n  \t},\n\n  \treset: function (ractive) {\n  \t\tvar registry = ractive[this.name];\n  \t\tvar changed = false;\n  \t\tObject.keys(registry).forEach(function (key) {\n  \t\t\tvar item = registry[key];\n  \t\t\tif (item._fn) {\n  \t\t\t\tif (item._fn.isOwner) {\n  \t\t\t\t\tregistry[key] = item._fn;\n  \t\t\t\t} else {\n  \t\t\t\t\tdelete registry[key];\n  \t\t\t\t}\n  \t\t\t\tchanged = true;\n  \t\t\t}\n  \t\t});\n  \t\treturn changed;\n  \t}\n  };\n\n  registries = config_registries__registryNames.map(function (name) {\n  \treturn new Registry(name, name === \"computed\");\n  });\n\n  var config_registries = registries;\n\n  /*this.configure(\n  \tthis.useDefaults ? Parent.defaults : Parent,\n  \tractive,\n  \toptions );*/\n\n  var wrapPrototype = wrap;\n\n  function wrap(parent, name, method) {\n  \tif (!/_super/.test(method)) {\n  \t\treturn method;\n  \t}\n\n  \tvar wrapper = function wrapSuper() {\n  \t\tvar superMethod = getSuperMethod(wrapper._parent, name),\n  \t\t    hasSuper = (\"_super\" in this),\n  \t\t    oldSuper = this._super,\n  \t\t    result;\n\n  \t\tthis._super = superMethod;\n\n  \t\tresult = method.apply(this, arguments);\n\n  \t\tif (hasSuper) {\n  \t\t\tthis._super = oldSuper;\n  \t\t} else {\n  \t\t\tdelete this._super;\n  \t\t}\n\n  \t\treturn result;\n  \t};\n\n  \twrapper._parent = parent;\n  \twrapper._method = method;\n\n  \treturn wrapper;\n  }\n\n  function getSuperMethod(parent, name) {\n  \tvar value, method;\n\n  \tif (name in parent) {\n  \t\tvalue = parent[name];\n\n  \t\tif (typeof value === \"function\") {\n  \t\t\tmethod = value;\n  \t\t} else {\n  \t\t\tmethod = function returnValue() {\n  \t\t\t\treturn value;\n  \t\t\t};\n  \t\t}\n  \t} else {\n  \t\tmethod = noop;\n  \t}\n\n  \treturn method;\n  }\n\n  var config_deprecate = deprecate;\n  function getMessage(deprecated, correct, isError) {\n  \treturn \"options.\" + deprecated + \" has been deprecated in favour of options.\" + correct + \".\" + (isError ? \" You cannot specify both options, please use options.\" + correct + \".\" : \"\");\n  }\n\n  function deprecateOption(options, deprecatedOption, correct) {\n  \tif (deprecatedOption in options) {\n  \t\tif (!(correct in options)) {\n  \t\t\twarnIfDebug(getMessage(deprecatedOption, correct));\n  \t\t\toptions[correct] = options[deprecatedOption];\n  \t\t} else {\n  \t\t\tthrow new Error(getMessage(deprecatedOption, correct, true));\n  \t\t}\n  \t}\n  }\n  function deprecate(options) {\n  \tdeprecateOption(options, \"beforeInit\", \"onconstruct\");\n  \tdeprecateOption(options, \"init\", \"onrender\");\n  \tdeprecateOption(options, \"complete\", \"oncomplete\");\n  \tdeprecateOption(options, \"eventDefinitions\", \"events\");\n\n  \t// Using extend with Component instead of options,\n  \t// like Human.extend( Spider ) means adaptors as a registry\n  \t// gets copied to options. So we have to check if actually an array\n  \tif (isArray(options.adaptors)) {\n  \t\tdeprecateOption(options, \"adaptors\", \"adapt\");\n  \t}\n  }\n\n  var config, order, defaultKeys, custom, isBlacklisted, isStandardKey;\n\n  custom = {\n  \tadapt: custom_adapt,\n  \tcss: css_css,\n  \tdata: custom_data,\n  \ttemplate: template_template\n  };\n\n  defaultKeys = Object.keys(config_defaults);\n\n  isStandardKey = makeObj(defaultKeys.filter(function (key) {\n  \treturn !custom[key];\n  }));\n\n  // blacklisted keys that we don't double extend\n  isBlacklisted = makeObj(defaultKeys.concat(config_registries.map(function (r) {\n  \treturn r.name;\n  })));\n\n  order = [].concat(defaultKeys.filter(function (key) {\n  \treturn !config_registries[key] && !custom[key];\n  }), config_registries, custom.data, custom.template, custom.css);\n\n  config = {\n  \textend: function (Parent, proto, options) {\n  \t\treturn configure(\"extend\", Parent, proto, options);\n  \t},\n\n  \tinit: function (Parent, ractive, options) {\n  \t\treturn configure(\"init\", Parent, ractive, options);\n  \t},\n\n  \treset: function (ractive) {\n  \t\treturn order.filter(function (c) {\n  \t\t\treturn c.reset && c.reset(ractive);\n  \t\t}).map(function (c) {\n  \t\t\treturn c.name;\n  \t\t});\n  \t},\n\n  \t// this defines the order. TODO this isn't used anywhere in the codebase,\n  \t// only in the test suite - should get rid of it\n  \torder: order };\n\n  function configure(method, Parent, target, options) {\n  \tconfig_deprecate(options);\n\n  \tfor (var key in options) {\n  \t\tif (isStandardKey.hasOwnProperty(key)) {\n  \t\t\tvar value = options[key];\n\n  \t\t\t// warn the developer if they passed a function and ignore its value\n\n  \t\t\t// NOTE: we allow some functions on \"el\" because we duck type element lists\n  \t\t\t// and some libraries or ef'ed-up virtual browsers (phantomJS) return a\n  \t\t\t// function object as the result of querySelector methods\n  \t\t\tif (key !== \"el\" && typeof value === \"function\") {\n  \t\t\t\twarnIfDebug(\"\" + key + \" is a Ractive option that does not expect a function and will be ignored\", method === \"init\" ? target : null);\n  \t\t\t} else {\n  \t\t\t\ttarget[key] = value;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tconfig_registries.forEach(function (registry) {\n  \t\tregistry[method](Parent, target, options);\n  \t});\n\n  \tcustom_adapt[method](Parent, target, options);\n  \ttemplate_template[method](Parent, target, options);\n  \tcss_css[method](Parent, target, options);\n\n  \textendOtherMethods(Parent.prototype, target, options);\n  }\n\n  function extendOtherMethods(parent, target, options) {\n  \tfor (var key in options) {\n  \t\tif (!isBlacklisted[key] && options.hasOwnProperty(key)) {\n  \t\t\tvar member = options[key];\n\n  \t\t\t// if this is a method that overwrites a method, wrap it:\n  \t\t\tif (typeof member === \"function\") {\n  \t\t\t\tmember = wrapPrototype(parent, key, member);\n  \t\t\t}\n\n  \t\t\ttarget[key] = member;\n  \t\t}\n  \t}\n  }\n\n  function makeObj(array) {\n  \tvar obj = {};\n  \tarray.forEach(function (x) {\n  \t\treturn obj[x] = true;\n  \t});\n  \treturn obj;\n  }\n\n  var config_config = config;\n\n  var prototype_bubble = Fragment$bubble;\n\n  function Fragment$bubble() {\n  \tthis.dirtyValue = this.dirtyArgs = true;\n\n  \tif (this.bound && typeof this.owner.bubble === \"function\") {\n  \t\tthis.owner.bubble();\n  \t}\n  }\n\n  var Fragment_prototype_detach = Fragment$detach;\n\n  function Fragment$detach() {\n  \tvar docFrag;\n\n  \tif (this.items.length === 1) {\n  \t\treturn this.items[0].detach();\n  \t}\n\n  \tdocFrag = document.createDocumentFragment();\n\n  \tthis.items.forEach(function (item) {\n  \t\tvar node = item.detach();\n\n  \t\t// TODO The if {...} wasn't previously required - it is now, because we're\n  \t\t// forcibly detaching everything to reorder sections after an update. That's\n  \t\t// a non-ideal brute force approach, implemented to get all the tests to pass\n  \t\t// - as soon as it's replaced with something more elegant, this should\n  \t\t// revert to `docFrag.appendChild( item.detach() )`\n  \t\tif (node) {\n  \t\t\tdocFrag.appendChild(node);\n  \t\t}\n  \t});\n\n  \treturn docFrag;\n  }\n\n  var Fragment_prototype_find = Fragment$find;\n\n  function Fragment$find(selector) {\n  \tvar i, len, item, queryResult;\n\n  \tif (this.items) {\n  \t\tlen = this.items.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\titem = this.items[i];\n\n  \t\t\tif (item.find && (queryResult = item.find(selector))) {\n  \t\t\t\treturn queryResult;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn null;\n  \t}\n  }\n\n  var Fragment_prototype_findAll = Fragment$findAll;\n\n  function Fragment$findAll(selector, query) {\n  \tvar i, len, item;\n\n  \tif (this.items) {\n  \t\tlen = this.items.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\titem = this.items[i];\n\n  \t\t\tif (item.findAll) {\n  \t\t\t\titem.findAll(selector, query);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn query;\n  }\n\n  var Fragment_prototype_findAllComponents = Fragment$findAllComponents;\n\n  function Fragment$findAllComponents(selector, query) {\n  \tvar i, len, item;\n\n  \tif (this.items) {\n  \t\tlen = this.items.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\titem = this.items[i];\n\n  \t\t\tif (item.findAllComponents) {\n  \t\t\t\titem.findAllComponents(selector, query);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn query;\n  }\n\n  var Fragment_prototype_findComponent = Fragment$findComponent;\n\n  function Fragment$findComponent(selector) {\n  \tvar len, i, item, queryResult;\n\n  \tif (this.items) {\n  \t\tlen = this.items.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\titem = this.items[i];\n\n  \t\t\tif (item.findComponent && (queryResult = item.findComponent(selector))) {\n  \t\t\t\treturn queryResult;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn null;\n  \t}\n  }\n\n  var prototype_findNextNode = Fragment$findNextNode;\n\n  function Fragment$findNextNode(item) {\n  \tvar index = item.index,\n  \t    node;\n\n  \tif (this.items[index + 1]) {\n  \t\tnode = this.items[index + 1].firstNode();\n  \t}\n\n  \t// if this is the root fragment, and there are no more items,\n  \t// it means we're at the end...\n  \telse if (this.owner === this.root) {\n  \t\tif (!this.owner.component) {\n  \t\t\t// TODO but something else could have been appended to\n  \t\t\t// this.root.el, no?\n  \t\t\tnode = null;\n  \t\t}\n\n  \t\t// ...unless this is a component\n  \t\telse {\n  \t\t\tnode = this.owner.component.findNextNode();\n  \t\t}\n  \t} else {\n  \t\tnode = this.owner.findNextNode(this);\n  \t}\n\n  \treturn node;\n  }\n\n  var prototype_firstNode = Fragment$firstNode;\n\n  function Fragment$firstNode() {\n  \tif (this.items && this.items[0]) {\n  \t\treturn this.items[0].firstNode();\n  \t}\n\n  \treturn null;\n  }\n\n  var shared_processItems = processItems;\n\n  function processItems(items, values, guid, counter) {\n  \tcounter = counter || 0;\n\n  \treturn items.map(function (item) {\n  \t\tvar placeholderId, wrapped, value;\n\n  \t\tif (item.text) {\n  \t\t\treturn item.text;\n  \t\t}\n\n  \t\tif (item.fragments) {\n  \t\t\treturn item.fragments.map(function (fragment) {\n  \t\t\t\treturn processItems(fragment.items, values, guid, counter);\n  \t\t\t}).join(\"\");\n  \t\t}\n\n  \t\tplaceholderId = guid + \"-\" + counter++;\n\n  \t\tif (item.keypath && (wrapped = item.root.viewmodel.wrapped[item.keypath.str])) {\n  \t\t\tvalue = wrapped.value;\n  \t\t} else {\n  \t\t\tvalue = item.getValue();\n  \t\t}\n\n  \t\tvalues[placeholderId] = value;\n\n  \t\treturn \"${\" + placeholderId + \"}\";\n  \t}).join(\"\");\n  }\n\n  var getArgsList = Fragment$getArgsList;\n  function Fragment$getArgsList() {\n  \tvar values, source, parsed, result;\n\n  \tif (this.dirtyArgs) {\n  \t\tsource = shared_processItems(this.items, values = {}, this.root._guid);\n  \t\tparsed = parseJSON(\"[\" + source + \"]\", values);\n\n  \t\tif (!parsed) {\n  \t\t\tresult = [this.toString()];\n  \t\t} else {\n  \t\t\tresult = parsed.value;\n  \t\t}\n\n  \t\tthis.argsList = result;\n  \t\tthis.dirtyArgs = false;\n  \t}\n\n  \treturn this.argsList;\n  }\n\n  var getNode = Fragment$getNode;\n\n  function Fragment$getNode() {\n  \tvar fragment = this;\n\n  \tdo {\n  \t\tif (fragment.pElement) {\n  \t\t\treturn fragment.pElement.node;\n  \t\t}\n  \t} while (fragment = fragment.parent);\n\n  \treturn this.root.detached || this.root.el;\n  }\n\n  var prototype_getValue = Fragment$getValue;\n  function Fragment$getValue() {\n  \tvar values, source, parsed, result;\n\n  \tif (this.dirtyValue) {\n  \t\tsource = shared_processItems(this.items, values = {}, this.root._guid);\n  \t\tparsed = parseJSON(source, values);\n\n  \t\tif (!parsed) {\n  \t\t\tresult = this.toString();\n  \t\t} else {\n  \t\t\tresult = parsed.value;\n  \t\t}\n\n  \t\tthis.value = result;\n  \t\tthis.dirtyValue = false;\n  \t}\n\n  \treturn this.value;\n  }\n\n  var shared_detach = function () {\n  \treturn detachNode(this.node);\n  };\n\n  var Text = function (options) {\n  \tthis.type = TEXT;\n  \tthis.text = options.template;\n  };\n\n  Text.prototype = {\n  \tdetach: shared_detach,\n\n  \tfirstNode: function () {\n  \t\treturn this.node;\n  \t},\n\n  \trender: function () {\n  \t\tif (!this.node) {\n  \t\t\tthis.node = document.createTextNode(this.text);\n  \t\t}\n\n  \t\treturn this.node;\n  \t},\n\n  \ttoString: function (escape) {\n  \t\treturn escape ? escapeHtml(this.text) : this.text;\n  \t},\n\n  \tunrender: function (shouldDestroy) {\n  \t\tif (shouldDestroy) {\n  \t\t\treturn this.detach();\n  \t\t}\n  \t}\n  };\n\n  var items_Text = Text;\n\n  var shared_unbind = shared_unbind__unbind;\n\n  function shared_unbind__unbind() {\n  \tif (this.registered) {\n  \t\t// this was registered as a dependant\n  \t\tthis.root.viewmodel.unregister(this.keypath, this);\n  \t}\n\n  \tif (this.resolver) {\n  \t\tthis.resolver.unbind();\n  \t}\n  }\n\n  var Mustache_getValue = Mustache$getValue;\n\n  function Mustache$getValue() {\n  \treturn this.value;\n  }\n\n  var ReferenceResolver = function (owner, ref, callback) {\n  \tvar keypath;\n\n  \tthis.ref = ref;\n  \tthis.resolved = false;\n\n  \tthis.root = owner.root;\n  \tthis.parentFragment = owner.parentFragment;\n  \tthis.callback = callback;\n\n  \tkeypath = shared_resolveRef(owner.root, ref, owner.parentFragment);\n  \tif (keypath != undefined) {\n  \t\tthis.resolve(keypath);\n  \t} else {\n  \t\tglobal_runloop.addUnresolved(this);\n  \t}\n  };\n\n  ReferenceResolver.prototype = {\n  \tresolve: function (keypath) {\n  \t\tif (this.keypath && !keypath) {\n  \t\t\t// it was resolved, and now it's not. Can happen if e.g. `bar` in\n  \t\t\t// `{{foo[bar]}}` becomes undefined\n  \t\t\tglobal_runloop.addUnresolved(this);\n  \t\t}\n\n  \t\tthis.resolved = true;\n\n  \t\tthis.keypath = keypath;\n  \t\tthis.callback(keypath);\n  \t},\n\n  \tforceResolution: function () {\n  \t\tthis.resolve(getKeypath(this.ref));\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tvar keypath;\n\n  \t\tif (this.keypath != undefined) {\n  \t\t\tkeypath = this.keypath.replace(oldKeypath, newKeypath);\n  \t\t\t// was a new keypath created?\n  \t\t\tif (keypath !== undefined) {\n  \t\t\t\t// resolve it\n  \t\t\t\tthis.resolve(keypath);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tunbind: function () {\n  \t\tif (!this.resolved) {\n  \t\t\tglobal_runloop.removeUnresolved(this);\n  \t\t}\n  \t}\n  };\n\n  var Resolvers_ReferenceResolver = ReferenceResolver;\n\n  var SpecialResolver = function (owner, ref, callback) {\n  \tthis.parentFragment = owner.parentFragment;\n  \tthis.ref = ref;\n  \tthis.callback = callback;\n\n  \tthis.rebind();\n  };\n\n  var props = {\n  \t\"@keypath\": { prefix: \"c\", prop: [\"context\"] },\n  \t\"@index\": { prefix: \"i\", prop: [\"index\"] },\n  \t\"@key\": { prefix: \"k\", prop: [\"key\", \"index\"] }\n  };\n\n  function getProp(target, prop) {\n  \tvar value;\n  \tfor (var i = 0; i < prop.prop.length; i++) {\n  \t\tif ((value = target[prop.prop[i]]) !== undefined) {\n  \t\t\treturn value;\n  \t\t}\n  \t}\n  }\n\n  SpecialResolver.prototype = {\n  \trebind: function () {\n  \t\tvar ref = this.ref,\n  \t\t    fragment = this.parentFragment,\n  \t\t    prop = props[ref],\n  \t\t    value;\n\n  \t\tif (!prop) {\n  \t\t\tthrow new Error(\"Unknown special reference \\\"\" + ref + \"\\\" - valid references are @index, @key and @keypath\");\n  \t\t}\n\n  \t\t// have we already found the nearest parent?\n  \t\tif (this.cached) {\n  \t\t\treturn this.callback(getKeypath(\"@\" + prop.prefix + getProp(this.cached, prop)));\n  \t\t}\n\n  \t\t// special case for indices, which may cross component boundaries\n  \t\tif (prop.prop.indexOf(\"index\") !== -1 || prop.prop.indexOf(\"key\") !== -1) {\n  \t\t\twhile (fragment) {\n  \t\t\t\tif (fragment.owner.currentSubtype === SECTION_EACH && (value = getProp(fragment, prop)) !== undefined) {\n  \t\t\t\t\tthis.cached = fragment;\n\n  \t\t\t\t\tfragment.registerIndexRef(this);\n\n  \t\t\t\t\treturn this.callback(getKeypath(\"@\" + prop.prefix + value));\n  \t\t\t\t}\n\n  \t\t\t\t// watch for component boundaries\n  \t\t\t\tif (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {\n  \t\t\t\t\tfragment = fragment.owner.component.parentFragment;\n  \t\t\t\t} else {\n  \t\t\t\t\tfragment = fragment.parent;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else {\n  \t\t\twhile (fragment) {\n  \t\t\t\tif ((value = getProp(fragment, prop)) !== undefined) {\n  \t\t\t\t\treturn this.callback(getKeypath(\"@\" + prop.prefix + value.str));\n  \t\t\t\t}\n\n  \t\t\t\tfragment = fragment.parent;\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tunbind: function () {\n  \t\tif (this.cached) {\n  \t\t\tthis.cached.unregisterIndexRef(this);\n  \t\t}\n  \t}\n  };\n\n  var Resolvers_SpecialResolver = SpecialResolver;\n\n  var IndexResolver = function (owner, ref, callback) {\n  \tthis.parentFragment = owner.parentFragment;\n  \tthis.ref = ref;\n  \tthis.callback = callback;\n\n  \tref.ref.fragment.registerIndexRef(this);\n\n  \tthis.rebind();\n  };\n\n  IndexResolver.prototype = {\n  \trebind: function () {\n  \t\tvar index,\n  \t\t    ref = this.ref.ref;\n\n  \t\tif (ref.ref.t === \"k\") {\n  \t\t\tindex = \"k\" + ref.fragment.key;\n  \t\t} else {\n  \t\t\tindex = \"i\" + ref.fragment.index;\n  \t\t}\n\n  \t\tif (index !== undefined) {\n  \t\t\tthis.callback(getKeypath(\"@\" + index));\n  \t\t}\n  \t},\n\n  \tunbind: function () {\n  \t\tthis.ref.ref.fragment.unregisterIndexRef(this);\n  \t}\n  };\n\n  var Resolvers_IndexResolver = IndexResolver;\n\n  var Resolvers_findIndexRefs = findIndexRefs;\n\n  function findIndexRefs(fragment, refName) {\n  \tvar result = {},\n  \t    refs,\n  \t    fragRefs,\n  \t    ref,\n  \t    i,\n  \t    owner,\n  \t    hit = false;\n\n  \tif (!refName) {\n  \t\tresult.refs = refs = {};\n  \t}\n\n  \twhile (fragment) {\n  \t\tif ((owner = fragment.owner) && (fragRefs = owner.indexRefs)) {\n\n  \t\t\t// we're looking for a particular ref, and it's here\n  \t\t\tif (refName && (ref = owner.getIndexRef(refName))) {\n  \t\t\t\tresult.ref = {\n  \t\t\t\t\tfragment: fragment,\n  \t\t\t\t\tref: ref\n  \t\t\t\t};\n  \t\t\t\treturn result;\n  \t\t\t}\n\n  \t\t\t// we're collecting refs up-tree\n  \t\t\telse if (!refName) {\n  \t\t\t\tfor (i in fragRefs) {\n  \t\t\t\t\tref = fragRefs[i];\n\n  \t\t\t\t\t// don't overwrite existing refs - they should shadow parents\n  \t\t\t\t\tif (!refs[ref.n]) {\n  \t\t\t\t\t\thit = true;\n  \t\t\t\t\t\trefs[ref.n] = {\n  \t\t\t\t\t\t\tfragment: fragment,\n  \t\t\t\t\t\t\tref: ref\n  \t\t\t\t\t\t};\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// watch for component boundaries\n  \t\tif (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {\n  \t\t\tresult.componentBoundary = true;\n  \t\t\tfragment = fragment.owner.component.parentFragment;\n  \t\t} else {\n  \t\t\tfragment = fragment.parent;\n  \t\t}\n  \t}\n\n  \tif (!hit) {\n  \t\treturn undefined;\n  \t} else {\n  \t\treturn result;\n  \t}\n  }\n\n  findIndexRefs.resolve = function resolve(indices) {\n  \tvar refs = {},\n  \t    k,\n  \t    ref;\n\n  \tfor (k in indices.refs) {\n  \t\tref = indices.refs[k];\n  \t\trefs[ref.ref.n] = ref.ref.t === \"k\" ? ref.fragment.key : ref.fragment.index;\n  \t}\n\n  \treturn refs;\n  };\n\n  var Resolvers_createReferenceResolver = createReferenceResolver;\n  function createReferenceResolver(owner, ref, callback) {\n  \tvar indexRef;\n\n  \tif (ref.charAt(0) === \"@\") {\n  \t\treturn new Resolvers_SpecialResolver(owner, ref, callback);\n  \t}\n\n  \tif (indexRef = Resolvers_findIndexRefs(owner.parentFragment, ref)) {\n  \t\treturn new Resolvers_IndexResolver(owner, indexRef, callback);\n  \t}\n\n  \treturn new Resolvers_ReferenceResolver(owner, ref, callback);\n  }\n\n  var shared_getFunctionFromString = getFunctionFromString;\n  var cache = {};\n  function getFunctionFromString(str, i) {\n  \tvar fn, args;\n\n  \tif (cache[str]) {\n  \t\treturn cache[str];\n  \t}\n\n  \targs = [];\n  \twhile (i--) {\n  \t\targs[i] = \"_\" + i;\n  \t}\n\n  \tfn = new Function(args.join(\",\"), \"return(\" + str + \")\");\n\n  \tcache[str] = fn;\n  \treturn fn;\n  }\n\n  var ExpressionResolver,\n      Resolvers_ExpressionResolver__bind = Function.prototype.bind;\n\n  ExpressionResolver = function (owner, parentFragment, expression, callback) {\n  \tvar _this = this;\n\n  \tvar ractive;\n\n  \tractive = owner.root;\n\n  \tthis.root = ractive;\n  \tthis.parentFragment = parentFragment;\n  \tthis.callback = callback;\n  \tthis.owner = owner;\n  \tthis.str = expression.s;\n  \tthis.keypaths = [];\n\n  \t// Create resolvers for each reference\n  \tthis.pending = expression.r.length;\n  \tthis.refResolvers = expression.r.map(function (ref, i) {\n  \t\treturn Resolvers_createReferenceResolver(_this, ref, function (keypath) {\n  \t\t\t_this.resolve(i, keypath);\n  \t\t});\n  \t});\n\n  \tthis.ready = true;\n  \tthis.bubble();\n  };\n\n  ExpressionResolver.prototype = {\n  \tbubble: function () {\n  \t\tif (!this.ready) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.uniqueString = getUniqueString(this.str, this.keypaths);\n  \t\tthis.keypath = createExpressionKeypath(this.uniqueString);\n\n  \t\tthis.createEvaluator();\n  \t\tthis.callback(this.keypath);\n  \t},\n\n  \tunbind: function () {\n  \t\tvar resolver;\n\n  \t\twhile (resolver = this.refResolvers.pop()) {\n  \t\t\tresolver.unbind();\n  \t\t}\n  \t},\n\n  \tresolve: function (index, keypath) {\n  \t\tthis.keypaths[index] = keypath;\n  \t\tthis.bubble();\n  \t},\n\n  \tcreateEvaluator: function () {\n  \t\tvar _this = this;\n\n  \t\tvar computation, valueGetters, signature, keypath, fn;\n\n  \t\tkeypath = this.keypath;\n  \t\tcomputation = this.root.viewmodel.computations[keypath.str];\n\n  \t\t// only if it doesn't exist yet!\n  \t\tif (!computation) {\n  \t\t\tfn = shared_getFunctionFromString(this.str, this.refResolvers.length);\n\n  \t\t\tvalueGetters = this.keypaths.map(function (keypath) {\n  \t\t\t\tvar value;\n\n  \t\t\t\tif (keypath === \"undefined\") {\n  \t\t\t\t\treturn function () {\n  \t\t\t\t\t\treturn undefined;\n  \t\t\t\t\t};\n  \t\t\t\t}\n\n  \t\t\t\t// 'special' keypaths encode a value\n  \t\t\t\tif (keypath.isSpecial) {\n  \t\t\t\t\tvalue = keypath.value;\n  \t\t\t\t\treturn function () {\n  \t\t\t\t\t\treturn value;\n  \t\t\t\t\t};\n  \t\t\t\t}\n\n  \t\t\t\treturn function () {\n  \t\t\t\t\tvar value = _this.root.viewmodel.get(keypath, { noUnwrap: true, fullRootGet: true });\n  \t\t\t\t\tif (typeof value === \"function\") {\n  \t\t\t\t\t\tvalue = wrapFunction(value, _this.root);\n  \t\t\t\t\t}\n  \t\t\t\t\treturn value;\n  \t\t\t\t};\n  \t\t\t});\n\n  \t\t\tsignature = {\n  \t\t\t\tdeps: this.keypaths.filter(isValidDependency),\n  \t\t\t\tgetter: function () {\n  \t\t\t\t\tvar args = valueGetters.map(call);\n  \t\t\t\t\treturn fn.apply(null, args);\n  \t\t\t\t}\n  \t\t\t};\n\n  \t\t\tcomputation = this.root.viewmodel.compute(keypath, signature);\n  \t\t} else {\n  \t\t\tthis.root.viewmodel.mark(keypath);\n  \t\t}\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\t// TODO only bubble once, no matter how many references are affected by the rebind\n  \t\tthis.refResolvers.forEach(function (r) {\n  \t\t\treturn r.rebind(oldKeypath, newKeypath);\n  \t\t});\n  \t}\n  };\n\n  var Resolvers_ExpressionResolver = ExpressionResolver;\n\n  function call(value) {\n  \treturn value.call();\n  }\n\n  function getUniqueString(str, keypaths) {\n  \t// get string that is unique to this expression\n  \treturn str.replace(/_([0-9]+)/g, function (match, $1) {\n  \t\tvar keypath, value;\n\n  \t\t// make sure we're not replacing a non-keypath _[0-9]\n  \t\tif (+$1 >= keypaths.length) {\n  \t\t\treturn \"_\" + $1;\n  \t\t}\n\n  \t\tkeypath = keypaths[$1];\n\n  \t\tif (keypath === undefined) {\n  \t\t\treturn \"undefined\";\n  \t\t}\n\n  \t\tif (keypath.isSpecial) {\n  \t\t\tvalue = keypath.value;\n  \t\t\treturn typeof value === \"number\" ? value : \"\\\"\" + value + \"\\\"\";\n  \t\t}\n\n  \t\treturn keypath.str;\n  \t});\n  }\n\n  function createExpressionKeypath(uniqueString) {\n  \t// Sanitize by removing any periods or square brackets. Otherwise\n  \t// we can't split the keypath into keys!\n  \t// Remove asterisks too, since they mess with pattern observers\n  \treturn getKeypath(\"${\" + uniqueString.replace(/[\\.\\[\\]]/g, \"-\").replace(/\\*/, \"#MUL#\") + \"}\");\n  }\n\n  function isValidDependency(keypath) {\n  \treturn keypath !== undefined && keypath[0] !== \"@\";\n  }\n\n  function wrapFunction(fn, ractive) {\n  \tvar wrapped, prop, key;\n\n  \tif (fn.__ractive_nowrap) {\n  \t\treturn fn;\n  \t}\n\n  \tprop = \"__ractive_\" + ractive._guid;\n  \twrapped = fn[prop];\n\n  \tif (wrapped) {\n  \t\treturn wrapped;\n  \t} else if (/this/.test(fn.toString())) {\n  \t\tdefineProperty(fn, prop, {\n  \t\t\tvalue: Resolvers_ExpressionResolver__bind.call(fn, ractive),\n  \t\t\tconfigurable: true\n  \t\t});\n\n  \t\t// Add properties/methods to wrapped function\n  \t\tfor (key in fn) {\n  \t\t\tif (fn.hasOwnProperty(key)) {\n  \t\t\t\tfn[prop][key] = fn[key];\n  \t\t\t}\n  \t\t}\n\n  \t\tractive._boundFunctions.push({\n  \t\t\tfn: fn,\n  \t\t\tprop: prop\n  \t\t});\n\n  \t\treturn fn[prop];\n  \t}\n\n  \tdefineProperty(fn, \"__ractive_nowrap\", {\n  \t\tvalue: fn\n  \t});\n\n  \treturn fn.__ractive_nowrap;\n  }\n\n  var MemberResolver = function (template, resolver, parentFragment) {\n  \tvar _this = this;\n\n  \tthis.resolver = resolver;\n  \tthis.root = resolver.root;\n  \tthis.parentFragment = parentFragment;\n  \tthis.viewmodel = resolver.root.viewmodel;\n\n  \tif (typeof template === \"string\") {\n  \t\tthis.value = template;\n  \t}\n\n  \t// Simple reference?\n  \telse if (template.t === REFERENCE) {\n  \t\tthis.refResolver = Resolvers_createReferenceResolver(this, template.n, function (keypath) {\n  \t\t\t_this.resolve(keypath);\n  \t\t});\n  \t}\n\n  \t// Otherwise we have an expression in its own right\n  \telse {\n  \t\tnew Resolvers_ExpressionResolver(resolver, parentFragment, template, function (keypath) {\n  \t\t\t_this.resolve(keypath);\n  \t\t});\n  \t}\n  };\n\n  MemberResolver.prototype = {\n  \tresolve: function (keypath) {\n  \t\tif (this.keypath) {\n  \t\t\tthis.viewmodel.unregister(this.keypath, this);\n  \t\t}\n\n  \t\tthis.keypath = keypath;\n  \t\tthis.value = this.viewmodel.get(keypath);\n\n  \t\tthis.bind();\n\n  \t\tthis.resolver.bubble();\n  \t},\n\n  \tbind: function () {\n  \t\tthis.viewmodel.register(this.keypath, this);\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tif (this.refResolver) {\n  \t\t\tthis.refResolver.rebind(oldKeypath, newKeypath);\n  \t\t}\n  \t},\n\n  \tsetValue: function (value) {\n  \t\tthis.value = value;\n  \t\tthis.resolver.bubble();\n  \t},\n\n  \tunbind: function () {\n  \t\tif (this.keypath) {\n  \t\t\tthis.viewmodel.unregister(this.keypath, this);\n  \t\t}\n\n  \t\tif (this.refResolver) {\n  \t\t\tthis.refResolver.unbind();\n  \t\t}\n  \t},\n\n  \tforceResolution: function () {\n  \t\tif (this.refResolver) {\n  \t\t\tthis.refResolver.forceResolution();\n  \t\t}\n  \t}\n  };\n\n  var ReferenceExpressionResolver_MemberResolver = MemberResolver;\n\n  var ReferenceExpressionResolver = function (mustache, template, callback) {\n  \tvar _this = this;\n\n  \tvar ractive, ref, keypath, parentFragment;\n\n  \tthis.parentFragment = parentFragment = mustache.parentFragment;\n  \tthis.root = ractive = mustache.root;\n  \tthis.mustache = mustache;\n\n  \tthis.ref = ref = template.r;\n  \tthis.callback = callback;\n\n  \tthis.unresolved = [];\n\n  \t// Find base keypath\n  \tif (keypath = shared_resolveRef(ractive, ref, parentFragment)) {\n  \t\tthis.base = keypath;\n  \t} else {\n  \t\tthis.baseResolver = new Resolvers_ReferenceResolver(this, ref, function (keypath) {\n  \t\t\t_this.base = keypath;\n  \t\t\t_this.baseResolver = null;\n  \t\t\t_this.bubble();\n  \t\t});\n  \t}\n\n  \t// Find values for members, or mark them as unresolved\n  \tthis.members = template.m.map(function (template) {\n  \t\treturn new ReferenceExpressionResolver_MemberResolver(template, _this, parentFragment);\n  \t});\n\n  \tthis.ready = true;\n  \tthis.bubble(); // trigger initial resolution if possible\n  };\n\n  ReferenceExpressionResolver.prototype = {\n  \tgetKeypath: function () {\n  \t\tvar values = this.members.map(ReferenceExpressionResolver_ReferenceExpressionResolver__getValue);\n\n  \t\tif (!values.every(isDefined) || this.baseResolver) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn this.base.join(values.join(\".\"));\n  \t},\n\n  \tbubble: function () {\n  \t\tif (!this.ready || this.baseResolver) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.callback(this.getKeypath());\n  \t},\n\n  \tunbind: function () {\n  \t\tthis.members.forEach(methodCallers__unbind);\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tvar changed;\n\n  \t\tif (this.base) {\n  \t\t\tvar newBase = this.base.replace(oldKeypath, newKeypath);\n  \t\t\tif (newBase && newBase !== this.base) {\n  \t\t\t\tthis.base = newBase;\n  \t\t\t\tchanged = true;\n  \t\t\t}\n  \t\t}\n\n  \t\tthis.members.forEach(function (members) {\n  \t\t\tif (members.rebind(oldKeypath, newKeypath)) {\n  \t\t\t\tchanged = true;\n  \t\t\t}\n  \t\t});\n\n  \t\tif (changed) {\n  \t\t\tthis.bubble();\n  \t\t}\n  \t},\n\n  \tforceResolution: function () {\n  \t\tif (this.baseResolver) {\n  \t\t\tthis.base = getKeypath(this.ref);\n\n  \t\t\tthis.baseResolver.unbind();\n  \t\t\tthis.baseResolver = null;\n  \t\t}\n\n  \t\tthis.members.forEach(forceResolution);\n  \t\tthis.bubble();\n  \t}\n  };\n\n  function ReferenceExpressionResolver_ReferenceExpressionResolver__getValue(member) {\n  \treturn member.value;\n  }\n\n  function isDefined(value) {\n  \treturn value != undefined;\n  }\n\n  function forceResolution(member) {\n  \tmember.forceResolution();\n  }\n\n  var ReferenceExpressionResolver_ReferenceExpressionResolver = ReferenceExpressionResolver;\n\n  var Mustache_initialise = Mustache$init;\n  function Mustache$init(mustache, options) {\n\n  \tvar ref, parentFragment, template;\n\n  \tparentFragment = options.parentFragment;\n  \ttemplate = options.template;\n\n  \tmustache.root = parentFragment.root;\n  \tmustache.parentFragment = parentFragment;\n  \tmustache.pElement = parentFragment.pElement;\n\n  \tmustache.template = options.template;\n  \tmustache.index = options.index || 0;\n  \tmustache.isStatic = options.template.s;\n\n  \tmustache.type = options.template.t;\n\n  \tmustache.registered = false;\n\n  \t// if this is a simple mustache, with a reference, we just need to resolve\n  \t// the reference to a keypath\n  \tif (ref = template.r) {\n  \t\tmustache.resolver = Resolvers_createReferenceResolver(mustache, ref, resolve);\n  \t}\n\n  \t// if it's an expression, we have a bit more work to do\n  \tif (options.template.x) {\n  \t\tmustache.resolver = new Resolvers_ExpressionResolver(mustache, parentFragment, options.template.x, resolveAndRebindChildren);\n  \t}\n\n  \tif (options.template.rx) {\n  \t\tmustache.resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(mustache, options.template.rx, resolveAndRebindChildren);\n  \t}\n\n  \t// Special case - inverted sections\n  \tif (mustache.template.n === SECTION_UNLESS && !mustache.hasOwnProperty(\"value\")) {\n  \t\tmustache.setValue(undefined);\n  \t}\n\n  \tfunction resolve(keypath) {\n  \t\tmustache.resolve(keypath);\n  \t}\n\n  \tfunction resolveAndRebindChildren(newKeypath) {\n  \t\tvar oldKeypath = mustache.keypath;\n\n  \t\tif (newKeypath != oldKeypath) {\n  \t\t\tmustache.resolve(newKeypath);\n\n  \t\t\tif (oldKeypath !== undefined) {\n  \t\t\t\tmustache.fragments && mustache.fragments.forEach(function (f) {\n  \t\t\t\t\tf.rebind(oldKeypath, newKeypath);\n  \t\t\t\t});\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  var Mustache_resolve = Mustache$resolve;\n\n  function Mustache$resolve(keypath) {\n  \tvar wasResolved, value, twowayBinding;\n\n  \t// 'Special' keypaths, e.g. @foo or @7, encode a value\n  \tif (keypath && keypath.isSpecial) {\n  \t\tthis.keypath = keypath;\n  \t\tthis.setValue(keypath.value);\n  \t\treturn;\n  \t}\n\n  \t// If we resolved previously, we need to unregister\n  \tif (this.registered) {\n  \t\t// undefined or null\n  \t\tthis.root.viewmodel.unregister(this.keypath, this);\n  \t\tthis.registered = false;\n\n  \t\twasResolved = true;\n  \t}\n\n  \tthis.keypath = keypath;\n\n  \t// If the new keypath exists, we need to register\n  \t// with the viewmodel\n  \tif (keypath != undefined) {\n  \t\t// undefined or null\n  \t\tvalue = this.root.viewmodel.get(keypath);\n  \t\tthis.root.viewmodel.register(keypath, this);\n\n  \t\tthis.registered = true;\n  \t}\n\n  \t// Either way we need to queue up a render (`value`\n  \t// will be `undefined` if there's no keypath)\n  \tthis.setValue(value);\n\n  \t// Two-way bindings need to point to their new target keypath\n  \tif (wasResolved && (twowayBinding = this.twowayBinding)) {\n  \t\ttwowayBinding.rebound();\n  \t}\n  }\n\n  var Mustache_rebind = Mustache$rebind;\n\n  function Mustache$rebind(oldKeypath, newKeypath) {\n  \t// Children first\n  \tif (this.fragments) {\n  \t\tthis.fragments.forEach(function (f) {\n  \t\t\treturn f.rebind(oldKeypath, newKeypath);\n  \t\t});\n  \t}\n\n  \t// Expression mustache?\n  \tif (this.resolver) {\n  \t\tthis.resolver.rebind(oldKeypath, newKeypath);\n  \t}\n  }\n\n  var Mustache = {\n  \tgetValue: Mustache_getValue,\n  \tinit: Mustache_initialise,\n  \tresolve: Mustache_resolve,\n  \trebind: Mustache_rebind\n  };\n\n  var Interpolator = function (options) {\n  \tthis.type = INTERPOLATOR;\n  \tMustache.init(this, options);\n  };\n\n  Interpolator.prototype = {\n  \tupdate: function () {\n  \t\tthis.node.data = this.value == undefined ? \"\" : this.value;\n  \t},\n  \tresolve: Mustache.resolve,\n  \trebind: Mustache.rebind,\n  \tdetach: shared_detach,\n\n  \tunbind: shared_unbind,\n\n  \trender: function () {\n  \t\tif (!this.node) {\n  \t\t\tthis.node = document.createTextNode(safeToStringValue(this.value));\n  \t\t}\n\n  \t\treturn this.node;\n  \t},\n\n  \tunrender: function (shouldDestroy) {\n  \t\tif (shouldDestroy) {\n  \t\t\tdetachNode(this.node);\n  \t\t}\n  \t},\n\n  \tgetValue: Mustache.getValue,\n\n  \t// TEMP\n  \tsetValue: function (value) {\n  \t\tvar wrapper;\n\n  \t\t// TODO is there a better way to approach this?\n  \t\tif (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {\n  \t\t\tvalue = wrapper.get();\n  \t\t}\n\n  \t\tif (!isEqual(value, this.value)) {\n  \t\t\tthis.value = value;\n  \t\t\tthis.parentFragment.bubble();\n\n  \t\t\tif (this.node) {\n  \t\t\t\tglobal_runloop.addView(this);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tfirstNode: function () {\n  \t\treturn this.node;\n  \t},\n\n  \ttoString: function (escape) {\n  \t\tvar string = \"\" + safeToStringValue(this.value);\n  \t\treturn escape ? escapeHtml(string) : string;\n  \t}\n  };\n\n  var items_Interpolator = Interpolator;\n\n  var Section_prototype_bubble = Section$bubble;\n\n  function Section$bubble() {\n  \tthis.parentFragment.bubble();\n  }\n\n  var Section_prototype_detach = Section$detach;\n\n  function Section$detach() {\n  \tvar docFrag;\n\n  \tif (this.fragments.length === 1) {\n  \t\treturn this.fragments[0].detach();\n  \t}\n\n  \tdocFrag = document.createDocumentFragment();\n\n  \tthis.fragments.forEach(function (item) {\n  \t\tdocFrag.appendChild(item.detach());\n  \t});\n\n  \treturn docFrag;\n  }\n\n  var find = Section$find;\n\n  function Section$find(selector) {\n  \tvar i, len, queryResult;\n\n  \tlen = this.fragments.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tif (queryResult = this.fragments[i].find(selector)) {\n  \t\t\treturn queryResult;\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  var findAll = Section$findAll;\n\n  function Section$findAll(selector, query) {\n  \tvar i, len;\n\n  \tlen = this.fragments.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tthis.fragments[i].findAll(selector, query);\n  \t}\n  }\n\n  var findAllComponents = Section$findAllComponents;\n\n  function Section$findAllComponents(selector, query) {\n  \tvar i, len;\n\n  \tlen = this.fragments.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tthis.fragments[i].findAllComponents(selector, query);\n  \t}\n  }\n\n  var findComponent = Section$findComponent;\n\n  function Section$findComponent(selector) {\n  \tvar i, len, queryResult;\n\n  \tlen = this.fragments.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tif (queryResult = this.fragments[i].findComponent(selector)) {\n  \t\t\treturn queryResult;\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  var findNextNode = Section$findNextNode;\n\n  function Section$findNextNode(fragment) {\n  \tif (this.fragments[fragment.index + 1]) {\n  \t\treturn this.fragments[fragment.index + 1].firstNode();\n  \t}\n\n  \treturn this.parentFragment.findNextNode(this);\n  }\n\n  var firstNode = Section$firstNode;\n\n  function Section$firstNode() {\n  \tvar len, i, node;\n\n  \tif (len = this.fragments.length) {\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\tif (node = this.fragments[i].firstNode()) {\n  \t\t\t\treturn node;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn this.parentFragment.findNextNode(this);\n  }\n\n  var shuffle = Section$shuffle;\n\n  function Section$shuffle(newIndices) {\n  \tvar _this = this;\n\n  \tvar parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;\n\n  \t// short circuit any double-updates, and ensure that this isn't applied to\n  \t// non-list sections\n  \tif (this.shuffling || this.unbound || this.currentSubtype !== SECTION_EACH) {\n  \t\treturn;\n  \t}\n\n  \tthis.shuffling = true;\n  \tglobal_runloop.scheduleTask(function () {\n  \t\treturn _this.shuffling = false;\n  \t});\n\n  \tparentFragment = this.parentFragment;\n\n  \treboundFragments = [];\n\n  \t// TODO: need to update this\n  \t// first, rebind existing fragments\n  \tnewIndices.forEach(function (newIndex, oldIndex) {\n  \t\tvar fragment, by, oldKeypath, newKeypath, deps;\n\n  \t\tif (newIndex === oldIndex) {\n  \t\t\treboundFragments[newIndex] = _this.fragments[oldIndex];\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfragment = _this.fragments[oldIndex];\n\n  \t\tif (firstChange === undefined) {\n  \t\t\tfirstChange = oldIndex;\n  \t\t}\n\n  \t\t// does this fragment need to be torn down?\n  \t\tif (newIndex === -1) {\n  \t\t\t_this.fragmentsToUnrender.push(fragment);\n  \t\t\tfragment.unbind();\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// Otherwise, it needs to be rebound to a new index\n  \t\tby = newIndex - oldIndex;\n  \t\toldKeypath = _this.keypath.join(oldIndex);\n  \t\tnewKeypath = _this.keypath.join(newIndex);\n\n  \t\tfragment.index = newIndex;\n\n  \t\t// notify any registered index refs directly\n  \t\tif (deps = fragment.registeredIndexRefs) {\n  \t\t\tdeps.forEach(shuffle__blindRebind);\n  \t\t}\n\n  \t\tfragment.rebind(oldKeypath, newKeypath);\n  \t\treboundFragments[newIndex] = fragment;\n  \t});\n\n  \tnewLength = this.root.viewmodel.get(this.keypath).length;\n\n  \t// If nothing changed with the existing fragments, then we start adding\n  \t// new fragments at the end...\n  \tif (firstChange === undefined) {\n  \t\t// ...unless there are no new fragments to add\n  \t\tif (this.length === newLength) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfirstChange = this.length;\n  \t}\n\n  \tthis.length = this.fragments.length = newLength;\n\n  \tif (this.rendered) {\n  \t\tglobal_runloop.addView(this);\n  \t}\n\n  \t// Prepare new fragment options\n  \tfragmentOptions = {\n  \t\ttemplate: this.template.f,\n  \t\troot: this.root,\n  \t\towner: this\n  \t};\n\n  \t// Add as many new fragments as we need to, or add back existing\n  \t// (detached) fragments\n  \tfor (i = firstChange; i < newLength; i += 1) {\n  \t\tfragment = reboundFragments[i];\n\n  \t\tif (!fragment) {\n  \t\t\tthis.fragmentsToCreate.push(i);\n  \t\t}\n\n  \t\tthis.fragments[i] = fragment;\n  \t}\n  }\n\n  function shuffle__blindRebind(dep) {\n  \t// the keypath doesn't actually matter here as it won't have changed\n  \tdep.rebind(\"\", \"\");\n  }\n\n  var prototype_rebind = function (oldKeypath, newKeypath) {\n  \tMustache.rebind.call(this, oldKeypath, newKeypath);\n  };\n\n  var Section_prototype_render = Section$render;\n\n  function Section$render() {\n  \tvar _this = this;\n\n  \tthis.docFrag = document.createDocumentFragment();\n\n  \tthis.fragments.forEach(function (f) {\n  \t\treturn _this.docFrag.appendChild(f.render());\n  \t});\n\n  \tthis.renderedFragments = this.fragments.slice();\n  \tthis.fragmentsToRender = [];\n\n  \tthis.rendered = true;\n  \treturn this.docFrag;\n  }\n\n  var setValue = Section$setValue;\n\n  function Section$setValue(value) {\n  \tvar _this = this;\n\n  \tvar wrapper, fragmentOptions;\n\n  \tif (this.updating) {\n  \t\t// If a child of this section causes a re-evaluation - for example, an\n  \t\t// expression refers to a function that mutates the array that this\n  \t\t// section depends on - we'll end up with a double rendering bug (see\n  \t\t// https://github.com/ractivejs/ractive/issues/748). This prevents it.\n  \t\treturn;\n  \t}\n\n  \tthis.updating = true;\n\n  \t// with sections, we need to get the fake value if we have a wrapped object\n  \tif (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {\n  \t\tvalue = wrapper.get();\n  \t}\n\n  \t// If any fragments are awaiting creation after a splice,\n  \t// this is the place to do it\n  \tif (this.fragmentsToCreate.length) {\n  \t\tfragmentOptions = {\n  \t\t\ttemplate: this.template.f || [],\n  \t\t\troot: this.root,\n  \t\t\tpElement: this.pElement,\n  \t\t\towner: this\n  \t\t};\n\n  \t\tthis.fragmentsToCreate.forEach(function (index) {\n  \t\t\tvar fragment;\n\n  \t\t\tfragmentOptions.context = _this.keypath.join(index);\n  \t\t\tfragmentOptions.index = index;\n\n  \t\t\tfragment = new virtualdom_Fragment(fragmentOptions);\n  \t\t\t_this.fragmentsToRender.push(_this.fragments[index] = fragment);\n  \t\t});\n\n  \t\tthis.fragmentsToCreate.length = 0;\n  \t} else if (reevaluateSection(this, value)) {\n  \t\tthis.bubble();\n\n  \t\tif (this.rendered) {\n  \t\t\tglobal_runloop.addView(this);\n  \t\t}\n  \t}\n\n  \tthis.value = value;\n  \tthis.updating = false;\n  }\n\n  function changeCurrentSubtype(section, value, obj) {\n  \tif (value === SECTION_EACH) {\n  \t\t// make sure ref type is up to date for key or value indices\n  \t\tif (section.indexRefs && section.indexRefs[0]) {\n  \t\t\tvar ref = section.indexRefs[0];\n\n  \t\t\t// when switching flavors, make sure the section gets updated\n  \t\t\tif (obj && ref.t === \"i\" || !obj && ref.t === \"k\") {\n  \t\t\t\t// if switching from object to list, unbind all of the old fragments\n  \t\t\t\tif (!obj) {\n  \t\t\t\t\tsection.length = 0;\n  \t\t\t\t\tsection.fragmentsToUnrender = section.fragments.slice(0);\n  \t\t\t\t\tsection.fragmentsToUnrender.forEach(function (f) {\n  \t\t\t\t\t\treturn f.unbind();\n  \t\t\t\t\t});\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tref.t = obj ? \"k\" : \"i\";\n  \t\t}\n  \t}\n\n  \tsection.currentSubtype = value;\n  }\n\n  function reevaluateSection(section, value) {\n  \tvar fragmentOptions = {\n  \t\ttemplate: section.template.f || [],\n  \t\troot: section.root,\n  \t\tpElement: section.parentFragment.pElement,\n  \t\towner: section\n  \t};\n\n  \tsection.hasContext = true;\n\n  \t// If we already know the section type, great\n  \t// TODO can this be optimised? i.e. pick an reevaluateSection function during init\n  \t// and avoid doing this each time?\n  \tif (section.subtype) {\n  \t\tswitch (section.subtype) {\n  \t\t\tcase SECTION_IF:\n  \t\t\t\tsection.hasContext = false;\n  \t\t\t\treturn reevaluateConditionalSection(section, value, false, fragmentOptions);\n\n  \t\t\tcase SECTION_UNLESS:\n  \t\t\t\tsection.hasContext = false;\n  \t\t\t\treturn reevaluateConditionalSection(section, value, true, fragmentOptions);\n\n  \t\t\tcase SECTION_WITH:\n  \t\t\t\treturn reevaluateContextSection(section, fragmentOptions);\n\n  \t\t\tcase SECTION_IF_WITH:\n  \t\t\t\treturn reevaluateConditionalContextSection(section, value, fragmentOptions);\n\n  \t\t\tcase SECTION_EACH:\n  \t\t\t\tif (isObject(value)) {\n  \t\t\t\t\tchangeCurrentSubtype(section, section.subtype, true);\n  \t\t\t\t\treturn reevaluateListObjectSection(section, value, fragmentOptions);\n  \t\t\t\t}\n\n  \t\t\t\t// Fallthrough - if it's a conditional or an array we need to continue\n  \t\t}\n  \t}\n\n  \t// Otherwise we need to work out what sort of section we're dealing with\n  \tsection.ordered = !!isArrayLike(value);\n\n  \t// Ordered list section\n  \tif (section.ordered) {\n  \t\tchangeCurrentSubtype(section, SECTION_EACH, false);\n  \t\treturn reevaluateListSection(section, value, fragmentOptions);\n  \t}\n\n  \t// Unordered list, or context\n  \tif (isObject(value) || typeof value === \"function\") {\n  \t\t// Index reference indicates section should be treated as a list\n  \t\tif (section.template.i) {\n  \t\t\tchangeCurrentSubtype(section, SECTION_EACH, true);\n  \t\t\treturn reevaluateListObjectSection(section, value, fragmentOptions);\n  \t\t}\n\n  \t\t// Otherwise, object provides context for contents\n  \t\tchangeCurrentSubtype(section, SECTION_WITH, false);\n  \t\treturn reevaluateContextSection(section, fragmentOptions);\n  \t}\n\n  \t// Conditional section\n  \tchangeCurrentSubtype(section, SECTION_IF, false);\n  \tsection.hasContext = false;\n  \treturn reevaluateConditionalSection(section, value, false, fragmentOptions);\n  }\n\n  function reevaluateListSection(section, value, fragmentOptions) {\n  \tvar i, length, fragment;\n\n  \tlength = value.length;\n\n  \tif (length === section.length) {\n  \t\t// Nothing to do\n  \t\treturn false;\n  \t}\n\n  \t// if the array is shorter than it was previously, remove items\n  \tif (length < section.length) {\n  \t\tsection.fragmentsToUnrender = section.fragments.splice(length, section.length - length);\n  \t\tsection.fragmentsToUnrender.forEach(methodCallers__unbind);\n  \t}\n\n  \t// otherwise...\n  \telse {\n  \t\tif (length > section.length) {\n  \t\t\t// add any new ones\n  \t\t\tfor (i = section.length; i < length; i += 1) {\n  \t\t\t\t// append list item to context stack\n  \t\t\t\tfragmentOptions.context = section.keypath.join(i);\n  \t\t\t\tfragmentOptions.index = i;\n\n  \t\t\t\tfragment = new virtualdom_Fragment(fragmentOptions);\n  \t\t\t\tsection.fragmentsToRender.push(section.fragments[i] = fragment);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tsection.length = length;\n  \treturn true;\n  }\n\n  function reevaluateListObjectSection(section, value, fragmentOptions) {\n  \tvar id, i, hasKey, fragment, changed, deps;\n\n  \thasKey = section.hasKey || (section.hasKey = {});\n\n  \t// remove any fragments that should no longer exist\n  \ti = section.fragments.length;\n  \twhile (i--) {\n  \t\tfragment = section.fragments[i];\n\n  \t\tif (!(fragment.key in value)) {\n  \t\t\tchanged = true;\n\n  \t\t\tfragment.unbind();\n  \t\t\tsection.fragmentsToUnrender.push(fragment);\n  \t\t\tsection.fragments.splice(i, 1);\n\n  \t\t\thasKey[fragment.key] = false;\n  \t\t}\n  \t}\n\n  \t// notify any dependents about changed indices\n  \ti = section.fragments.length;\n  \twhile (i--) {\n  \t\tfragment = section.fragments[i];\n\n  \t\tif (fragment.index !== i) {\n  \t\t\tfragment.index = i;\n  \t\t\tif (deps = fragment.registeredIndexRefs) {\n  \t\t\t\tdeps.forEach(setValue__blindRebind);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// add any that haven't been created yet\n  \ti = section.fragments.length;\n  \tfor (id in value) {\n  \t\tif (!hasKey[id]) {\n  \t\t\tchanged = true;\n\n  \t\t\tfragmentOptions.context = section.keypath.join(id);\n  \t\t\tfragmentOptions.key = id;\n  \t\t\tfragmentOptions.index = i++;\n\n  \t\t\tfragment = new virtualdom_Fragment(fragmentOptions);\n\n  \t\t\tsection.fragmentsToRender.push(fragment);\n  \t\t\tsection.fragments.push(fragment);\n  \t\t\thasKey[id] = true;\n  \t\t}\n  \t}\n\n  \tsection.length = section.fragments.length;\n  \treturn changed;\n  }\n\n  function reevaluateConditionalContextSection(section, value, fragmentOptions) {\n  \tif (value) {\n  \t\treturn reevaluateContextSection(section, fragmentOptions);\n  \t} else {\n  \t\treturn removeSectionFragments(section);\n  \t}\n  }\n\n  function reevaluateContextSection(section, fragmentOptions) {\n  \tvar fragment;\n\n  \t// ...then if it isn't rendered, render it, adding section.keypath to the context stack\n  \t// (if it is already rendered, then any children dependent on the context stack\n  \t// will update themselves without any prompting)\n  \tif (!section.length) {\n  \t\t// append this section to the context stack\n  \t\tfragmentOptions.context = section.keypath;\n  \t\tfragmentOptions.index = 0;\n\n  \t\tfragment = new virtualdom_Fragment(fragmentOptions);\n\n  \t\tsection.fragmentsToRender.push(section.fragments[0] = fragment);\n  \t\tsection.length = 1;\n\n  \t\treturn true;\n  \t}\n  }\n\n  function reevaluateConditionalSection(section, value, inverted, fragmentOptions) {\n  \tvar doRender, emptyArray, emptyObject, fragment, name;\n\n  \temptyArray = isArrayLike(value) && value.length === 0;\n  \temptyObject = false;\n  \tif (!isArrayLike(value) && isObject(value)) {\n  \t\temptyObject = true;\n  \t\tfor (name in value) {\n  \t\t\temptyObject = false;\n  \t\t\tbreak;\n  \t\t}\n  \t}\n\n  \tif (inverted) {\n  \t\tdoRender = emptyArray || emptyObject || !value;\n  \t} else {\n  \t\tdoRender = value && !emptyArray && !emptyObject;\n  \t}\n\n  \tif (doRender) {\n  \t\tif (!section.length) {\n  \t\t\t// no change to context stack\n  \t\t\tfragmentOptions.index = 0;\n\n  \t\t\tfragment = new virtualdom_Fragment(fragmentOptions);\n  \t\t\tsection.fragmentsToRender.push(section.fragments[0] = fragment);\n  \t\t\tsection.length = 1;\n\n  \t\t\treturn true;\n  \t\t}\n\n  \t\tif (section.length > 1) {\n  \t\t\tsection.fragmentsToUnrender = section.fragments.splice(1);\n  \t\t\tsection.fragmentsToUnrender.forEach(methodCallers__unbind);\n\n  \t\t\treturn true;\n  \t\t}\n  \t} else {\n  \t\treturn removeSectionFragments(section);\n  \t}\n  }\n\n  function removeSectionFragments(section) {\n  \tif (section.length) {\n  \t\tsection.fragmentsToUnrender = section.fragments.splice(0, section.fragments.length).filter(isRendered);\n  \t\tsection.fragmentsToUnrender.forEach(methodCallers__unbind);\n  \t\tsection.length = section.fragmentsToRender.length = 0;\n  \t\treturn true;\n  \t}\n  }\n\n  function isRendered(fragment) {\n  \treturn fragment.rendered;\n  }\n\n  function setValue__blindRebind(dep) {\n  \t// the keypath doesn't actually matter here as it won't have changed\n  \tdep.rebind(\"\", \"\");\n  }\n\n  var prototype_toString = Section$toString;\n\n  function Section$toString(escape) {\n  \tvar str, i, len;\n\n  \tstr = \"\";\n\n  \ti = 0;\n  \tlen = this.length;\n\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tstr += this.fragments[i].toString(escape);\n  \t}\n\n  \treturn str;\n  }\n\n  var prototype_unbind = Section$unbind;\n  function Section$unbind() {\n  \tvar _this = this;\n\n  \tthis.fragments.forEach(methodCallers__unbind);\n  \tthis.fragmentsToRender.forEach(function (f) {\n  \t\treturn removeFromArray(_this.fragments, f);\n  \t});\n  \tthis.fragmentsToRender = [];\n  \tshared_unbind.call(this);\n\n  \tthis.length = 0;\n  \tthis.unbound = true;\n  }\n\n  var prototype_unrender = Section$unrender;\n\n  function Section$unrender(shouldDestroy) {\n  \tthis.fragments.forEach(shouldDestroy ? unrenderAndDestroy : prototype_unrender__unrender);\n  \tthis.renderedFragments = [];\n  \tthis.rendered = false;\n  }\n\n  function unrenderAndDestroy(fragment) {\n  \tfragment.unrender(true);\n  }\n\n  function prototype_unrender__unrender(fragment) {\n  \tfragment.unrender(false);\n  }\n\n  var prototype_update = Section$update;\n\n  function Section$update() {\n  \tvar fragment, renderIndex, renderedFragments, anchor, target, i, len;\n\n  \t// `this.renderedFragments` is in the order of the previous render.\n  \t// If fragments have shuffled about, this allows us to quickly\n  \t// reinsert them in the correct place\n  \trenderedFragments = this.renderedFragments;\n\n  \t// Remove fragments that have been marked for destruction\n  \twhile (fragment = this.fragmentsToUnrender.pop()) {\n  \t\tfragment.unrender(true);\n  \t\trenderedFragments.splice(renderedFragments.indexOf(fragment), 1);\n  \t}\n\n  \t// Render new fragments (but don't insert them yet)\n  \twhile (fragment = this.fragmentsToRender.shift()) {\n  \t\tfragment.render();\n  \t}\n\n  \tif (this.rendered) {\n  \t\ttarget = this.parentFragment.getNode();\n  \t}\n\n  \tlen = this.fragments.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tfragment = this.fragments[i];\n  \t\trenderIndex = renderedFragments.indexOf(fragment, i); // search from current index - it's guaranteed to be the same or higher\n\n  \t\tif (renderIndex === i) {\n  \t\t\t// already in the right place. insert accumulated nodes (if any) and carry on\n  \t\t\tif (this.docFrag.childNodes.length) {\n  \t\t\t\tanchor = fragment.firstNode();\n  \t\t\t\ttarget.insertBefore(this.docFrag, anchor);\n  \t\t\t}\n\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tthis.docFrag.appendChild(fragment.detach());\n\n  \t\t// update renderedFragments\n  \t\tif (renderIndex !== -1) {\n  \t\t\trenderedFragments.splice(renderIndex, 1);\n  \t\t}\n  \t\trenderedFragments.splice(i, 0, fragment);\n  \t}\n\n  \tif (this.rendered && this.docFrag.childNodes.length) {\n  \t\tanchor = this.parentFragment.findNextNode(this);\n  \t\ttarget.insertBefore(this.docFrag, anchor);\n  \t}\n\n  \t// Save the rendering order for next time\n  \tthis.renderedFragments = this.fragments.slice();\n  }\n\n  var Section = function (options) {\n  \tthis.type = SECTION;\n  \tthis.subtype = this.currentSubtype = options.template.n;\n  \tthis.inverted = this.subtype === SECTION_UNLESS;\n\n  \tthis.pElement = options.pElement;\n\n  \tthis.fragments = [];\n  \tthis.fragmentsToCreate = [];\n  \tthis.fragmentsToRender = [];\n  \tthis.fragmentsToUnrender = [];\n\n  \tif (options.template.i) {\n  \t\tthis.indexRefs = options.template.i.split(\",\").map(function (k, i) {\n  \t\t\treturn { n: k, t: i === 0 ? \"k\" : \"i\" };\n  \t\t});\n  \t}\n\n  \tthis.renderedFragments = [];\n\n  \tthis.length = 0; // number of times this section is rendered\n\n  \tMustache.init(this, options);\n  };\n\n  Section.prototype = {\n  \tbubble: Section_prototype_bubble,\n  \tdetach: Section_prototype_detach,\n  \tfind: find,\n  \tfindAll: findAll,\n  \tfindAllComponents: findAllComponents,\n  \tfindComponent: findComponent,\n  \tfindNextNode: findNextNode,\n  \tfirstNode: firstNode,\n  \tgetIndexRef: function (name) {\n  \t\tif (this.indexRefs) {\n  \t\t\tvar i = this.indexRefs.length;\n  \t\t\twhile (i--) {\n  \t\t\t\tvar ref = this.indexRefs[i];\n  \t\t\t\tif (ref.n === name) {\n  \t\t\t\t\treturn ref;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetValue: Mustache.getValue,\n  \tshuffle: shuffle,\n  \trebind: prototype_rebind,\n  \trender: Section_prototype_render,\n  \tresolve: Mustache.resolve,\n  \tsetValue: setValue,\n  \ttoString: prototype_toString,\n  \tunbind: prototype_unbind,\n  \tunrender: prototype_unrender,\n  \tupdate: prototype_update\n  };\n\n  var _Section = Section;\n\n  var Triple_prototype_detach = Triple$detach;\n\n  function Triple$detach() {\n  \tvar len, i;\n\n  \tif (this.docFrag) {\n  \t\tlen = this.nodes.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\tthis.docFrag.appendChild(this.nodes[i]);\n  \t\t}\n\n  \t\treturn this.docFrag;\n  \t}\n  }\n\n  var Triple_prototype_find = Triple$find;\n  function Triple$find(selector) {\n  \tvar i, len, node, queryResult;\n\n  \tlen = this.nodes.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tnode = this.nodes[i];\n\n  \t\tif (node.nodeType !== 1) {\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tif (matches(node, selector)) {\n  \t\t\treturn node;\n  \t\t}\n\n  \t\tif (queryResult = node.querySelector(selector)) {\n  \t\t\treturn queryResult;\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  var Triple_prototype_findAll = Triple$findAll;\n  function Triple$findAll(selector, queryResult) {\n  \tvar i, len, node, queryAllResult, numNodes, j;\n\n  \tlen = this.nodes.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tnode = this.nodes[i];\n\n  \t\tif (node.nodeType !== 1) {\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tif (matches(node, selector)) {\n  \t\t\tqueryResult.push(node);\n  \t\t}\n\n  \t\tif (queryAllResult = node.querySelectorAll(selector)) {\n  \t\t\tnumNodes = queryAllResult.length;\n  \t\t\tfor (j = 0; j < numNodes; j += 1) {\n  \t\t\t\tqueryResult.push(queryAllResult[j]);\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  var Triple_prototype_firstNode = Triple$firstNode;\n\n  function Triple$firstNode() {\n  \tif (this.rendered && this.nodes[0]) {\n  \t\treturn this.nodes[0];\n  \t}\n\n  \treturn this.parentFragment.findNextNode(this);\n  }\n\n  var elementCache = {},\n      ieBug,\n      ieBlacklist;\n\n  try {\n  \tcreateElement(\"table\").innerHTML = \"foo\";\n  } catch (err) {\n  \tieBug = true;\n\n  \tieBlacklist = {\n  \t\tTABLE: [\"<table class=\\\"x\\\">\", \"</table>\"],\n  \t\tTHEAD: [\"<table><thead class=\\\"x\\\">\", \"</thead></table>\"],\n  \t\tTBODY: [\"<table><tbody class=\\\"x\\\">\", \"</tbody></table>\"],\n  \t\tTR: [\"<table><tr class=\\\"x\\\">\", \"</tr></table>\"],\n  \t\tSELECT: [\"<select class=\\\"x\\\">\", \"</select>\"]\n  \t};\n  }\n\n  var insertHtml = function (html, node, docFrag) {\n  \tvar container,\n  \t    nodes = [],\n  \t    wrapper,\n  \t    selectedOption,\n  \t    child,\n  \t    i;\n\n  \t// render 0 and false\n  \tif (html != null && html !== \"\") {\n  \t\tif (ieBug && (wrapper = ieBlacklist[node.tagName])) {\n  \t\t\tcontainer = element(\"DIV\");\n  \t\t\tcontainer.innerHTML = wrapper[0] + html + wrapper[1];\n  \t\t\tcontainer = container.querySelector(\".x\");\n\n  \t\t\tif (container.tagName === \"SELECT\") {\n  \t\t\t\tselectedOption = container.options[container.selectedIndex];\n  \t\t\t}\n  \t\t} else if (node.namespaceURI === namespaces.svg) {\n  \t\t\tcontainer = element(\"DIV\");\n  \t\t\tcontainer.innerHTML = \"<svg class=\\\"x\\\">\" + html + \"</svg>\";\n  \t\t\tcontainer = container.querySelector(\".x\");\n  \t\t} else {\n  \t\t\tcontainer = element(node.tagName);\n  \t\t\tcontainer.innerHTML = html;\n\n  \t\t\tif (container.tagName === \"SELECT\") {\n  \t\t\t\tselectedOption = container.options[container.selectedIndex];\n  \t\t\t}\n  \t\t}\n\n  \t\twhile (child = container.firstChild) {\n  \t\t\tnodes.push(child);\n  \t\t\tdocFrag.appendChild(child);\n  \t\t}\n\n  \t\t// This is really annoying. Extracting <option> nodes from the\n  \t\t// temporary container <select> causes the remaining ones to\n  \t\t// become selected. So now we have to deselect them. IE8, you\n  \t\t// amaze me. You really do\n  \t\t// ...and now Chrome too\n  \t\tif (node.tagName === \"SELECT\") {\n  \t\t\ti = nodes.length;\n  \t\t\twhile (i--) {\n  \t\t\t\tif (nodes[i] !== selectedOption) {\n  \t\t\t\t\tnodes[i].selected = false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn nodes;\n  };\n\n  function element(tagName) {\n  \treturn elementCache[tagName] || (elementCache[tagName] = createElement(tagName));\n  }\n\n  var helpers_updateSelect = updateSelect;\n\n  function updateSelect(parentElement) {\n  \tvar selectedOptions, option, value;\n\n  \tif (!parentElement || parentElement.name !== \"select\" || !parentElement.binding) {\n  \t\treturn;\n  \t}\n\n  \tselectedOptions = toArray(parentElement.node.options).filter(isSelected);\n\n  \t// If one of them had a `selected` attribute, we need to sync\n  \t// the model to the view\n  \tif (parentElement.getAttribute(\"multiple\")) {\n  \t\tvalue = selectedOptions.map(function (o) {\n  \t\t\treturn o.value;\n  \t\t});\n  \t} else if (option = selectedOptions[0]) {\n  \t\tvalue = option.value;\n  \t}\n\n  \tif (value !== undefined) {\n  \t\tparentElement.binding.setValue(value);\n  \t}\n\n  \tparentElement.bubble();\n  }\n\n  function isSelected(option) {\n  \treturn option.selected;\n  }\n\n  var Triple_prototype_render = Triple$render;\n  function Triple$render() {\n  \tif (this.rendered) {\n  \t\tthrow new Error(\"Attempted to render an item that was already rendered\");\n  \t}\n\n  \tthis.docFrag = document.createDocumentFragment();\n  \tthis.nodes = insertHtml(this.value, this.parentFragment.getNode(), this.docFrag);\n\n  \t// Special case - we're inserting the contents of a <select>\n  \thelpers_updateSelect(this.pElement);\n\n  \tthis.rendered = true;\n  \treturn this.docFrag;\n  }\n\n  var prototype_setValue = Triple$setValue;\n  function Triple$setValue(value) {\n  \tvar wrapper;\n\n  \t// TODO is there a better way to approach this?\n  \tif (wrapper = this.root.viewmodel.wrapped[this.keypath.str]) {\n  \t\tvalue = wrapper.get();\n  \t}\n\n  \tif (value !== this.value) {\n  \t\tthis.value = value;\n  \t\tthis.parentFragment.bubble();\n\n  \t\tif (this.rendered) {\n  \t\t\tglobal_runloop.addView(this);\n  \t\t}\n  \t}\n  }\n\n  var Triple_prototype_toString = Triple$toString;\n  function Triple$toString() {\n  \treturn this.value != undefined ? decodeCharacterReferences(\"\" + this.value) : \"\";\n  }\n\n  var Triple_prototype_unrender = Triple$unrender;\n  function Triple$unrender(shouldDestroy) {\n  \tif (this.rendered && shouldDestroy) {\n  \t\tthis.nodes.forEach(detachNode);\n  \t\tthis.rendered = false;\n  \t}\n\n  \t// TODO update live queries\n  }\n\n  var Triple_prototype_update = Triple$update;\n  function Triple$update() {\n  \tvar node, parentNode;\n\n  \tif (!this.rendered) {\n  \t\treturn;\n  \t}\n\n  \t// Remove existing nodes\n  \twhile (this.nodes && this.nodes.length) {\n  \t\tnode = this.nodes.pop();\n  \t\tnode.parentNode.removeChild(node);\n  \t}\n\n  \t// Insert new nodes\n  \tparentNode = this.parentFragment.getNode();\n\n  \tthis.nodes = insertHtml(this.value, parentNode, this.docFrag);\n  \tparentNode.insertBefore(this.docFrag, this.parentFragment.findNextNode(this));\n\n  \t// Special case - we're inserting the contents of a <select>\n  \thelpers_updateSelect(this.pElement);\n  }\n\n  var Triple = function (options) {\n  \tthis.type = TRIPLE;\n  \tMustache.init(this, options);\n  };\n\n  Triple.prototype = {\n  \tdetach: Triple_prototype_detach,\n  \tfind: Triple_prototype_find,\n  \tfindAll: Triple_prototype_findAll,\n  \tfirstNode: Triple_prototype_firstNode,\n  \tgetValue: Mustache.getValue,\n  \trebind: Mustache.rebind,\n  \trender: Triple_prototype_render,\n  \tresolve: Mustache.resolve,\n  \tsetValue: prototype_setValue,\n  \ttoString: Triple_prototype_toString,\n  \tunbind: shared_unbind,\n  \tunrender: Triple_prototype_unrender,\n  \tupdate: Triple_prototype_update\n  };\n\n  var _Triple = Triple;\n\n  var Element_prototype_bubble = function () {\n  \tthis.parentFragment.bubble();\n  };\n\n  var Element_prototype_detach = Element$detach;\n\n  function Element$detach() {\n  \tvar node = this.node,\n  \t    parentNode;\n\n  \tif (node) {\n  \t\t// need to check for parent node - DOM may have been altered\n  \t\t// by something other than Ractive! e.g. jQuery UI...\n  \t\tif (parentNode = node.parentNode) {\n  \t\t\tparentNode.removeChild(node);\n  \t\t}\n\n  \t\treturn node;\n  \t}\n  }\n\n  var Element_prototype_find = function (selector) {\n  \tif (!this.node) {\n  \t\t// this element hasn't been rendered yet\n  \t\treturn null;\n  \t}\n\n  \tif (matches(this.node, selector)) {\n  \t\treturn this.node;\n  \t}\n\n  \tif (this.fragment && this.fragment.find) {\n  \t\treturn this.fragment.find(selector);\n  \t}\n  };\n\n  var Element_prototype_findAll = function (selector, query) {\n  \t// Add this node to the query, if applicable, and register the\n  \t// query on this element\n  \tif (query._test(this, true) && query.live) {\n  \t\t(this.liveQueries || (this.liveQueries = [])).push(query);\n  \t}\n\n  \tif (this.fragment) {\n  \t\tthis.fragment.findAll(selector, query);\n  \t}\n  };\n\n  var Element_prototype_findAllComponents = function (selector, query) {\n  \tif (this.fragment) {\n  \t\tthis.fragment.findAllComponents(selector, query);\n  \t}\n  };\n\n  var Element_prototype_findComponent = function (selector) {\n  \tif (this.fragment) {\n  \t\treturn this.fragment.findComponent(selector);\n  \t}\n  };\n\n  var Element_prototype_findNextNode = Element$findNextNode;\n\n  function Element$findNextNode() {\n  \treturn null;\n  }\n\n  var Element_prototype_firstNode = Element$firstNode;\n\n  function Element$firstNode() {\n  \treturn this.node;\n  }\n\n  var getAttribute = Element$getAttribute;\n\n  function Element$getAttribute(name) {\n  \tif (!this.attributes || !this.attributes[name]) {\n  \t\treturn;\n  \t}\n\n  \treturn this.attributes[name].value;\n  }\n\n  var truthy = /^true|on|yes|1$/i;\n  var processBindingAttributes__isNumeric = /^[0-9]+$/;\n\n  var processBindingAttributes = function (element, template) {\n  \tvar val, attrs, attributes;\n\n  \tattributes = template.a || {};\n  \tattrs = {};\n\n  \t// attributes that are present but don't have a value (=)\n  \t// will be set to the number 0, which we condider to be true\n  \t// the string '0', however is false\n\n  \tval = attributes.twoway;\n  \tif (val !== undefined) {\n  \t\tattrs.twoway = val === 0 || truthy.test(val);\n  \t}\n\n  \tval = attributes.lazy;\n  \tif (val !== undefined) {\n  \t\t// check for timeout value\n  \t\tif (val !== 0 && processBindingAttributes__isNumeric.test(val)) {\n  \t\t\tattrs.lazy = parseInt(val);\n  \t\t} else {\n  \t\t\tattrs.lazy = val === 0 || truthy.test(val);\n  \t\t}\n  \t}\n\n  \treturn attrs;\n  };\n\n  var Attribute_prototype_bubble = Attribute$bubble;\n  function Attribute$bubble() {\n  \tvar value = this.useProperty || !this.rendered ? this.fragment.getValue() : this.fragment.toString();\n\n  \t// TODO this can register the attribute multiple times (see render test\n  \t// 'Attribute with nested mustaches')\n  \tif (!isEqual(value, this.value)) {\n\n  \t\t// Need to clear old id from ractive.nodes\n  \t\tif (this.name === \"id\" && this.value) {\n  \t\t\tdelete this.root.nodes[this.value];\n  \t\t}\n\n  \t\tthis.value = value;\n\n  \t\tif (this.name === \"value\" && this.node) {\n  \t\t\t// We need to store the value on the DOM like this so we\n  \t\t\t// can retrieve it later without it being coerced to a string\n  \t\t\tthis.node._ractive.value = value;\n  \t\t}\n\n  \t\tif (this.rendered) {\n  \t\t\tglobal_runloop.addView(this);\n  \t\t}\n  \t}\n  }\n\n  var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;\n  svgCamelCaseElements = \"altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern\".split(\" \");\n  svgCamelCaseAttributes = \"attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan\".split(\" \");\n\n  createMap = function (items) {\n  \tvar map = {},\n  \t    i = items.length;\n  \twhile (i--) {\n  \t\tmap[items[i].toLowerCase()] = items[i];\n  \t}\n  \treturn map;\n  };\n\n  map = createMap(svgCamelCaseElements.concat(svgCamelCaseAttributes));\n\n  var enforceCase = function (elementName) {\n  \tvar lowerCaseElementName = elementName.toLowerCase();\n  \treturn map[lowerCaseElementName] || lowerCaseElementName;\n  };\n\n  var determineNameAndNamespace = function (attribute, name) {\n  \tvar colonIndex, namespacePrefix;\n\n  \t// are we dealing with a namespaced attribute, e.g. xlink:href?\n  \tcolonIndex = name.indexOf(\":\");\n  \tif (colonIndex !== -1) {\n\n  \t\t// looks like we are, yes...\n  \t\tnamespacePrefix = name.substr(0, colonIndex);\n\n  \t\t// ...unless it's a namespace *declaration*, which we ignore (on the assumption\n  \t\t// that only valid namespaces will be used)\n  \t\tif (namespacePrefix !== \"xmlns\") {\n  \t\t\tname = name.substring(colonIndex + 1);\n\n  \t\t\tattribute.name = enforceCase(name);\n  \t\t\tattribute.namespace = namespaces[namespacePrefix.toLowerCase()];\n  \t\t\tattribute.namespacePrefix = namespacePrefix;\n\n  \t\t\tif (!attribute.namespace) {\n  \t\t\t\tthrow \"Unknown namespace (\\\"\" + namespacePrefix + \"\\\")\";\n  \t\t\t}\n\n  \t\t\treturn;\n  \t\t}\n  \t}\n\n  \t// SVG attribute names are case sensitive\n  \tattribute.name = attribute.element.namespace !== namespaces.html ? enforceCase(name) : name;\n  };\n\n  var helpers_getInterpolator = getInterpolator;\n  function getInterpolator(attribute) {\n  \tvar items = attribute.fragment.items;\n\n  \tif (items.length !== 1) {\n  \t\treturn;\n  \t}\n\n  \tif (items[0].type === INTERPOLATOR) {\n  \t\treturn items[0];\n  \t}\n  }\n\n  var prototype_init = Attribute$init;\n  function Attribute$init(options) {\n  \tthis.type = ATTRIBUTE;\n  \tthis.element = options.element;\n  \tthis.root = options.root;\n\n  \tdetermineNameAndNamespace(this, options.name);\n  \tthis.isBoolean = booleanAttributes.test(this.name);\n\n  \t// if it's an empty attribute, or just a straight key-value pair, with no\n  \t// mustache shenanigans, set the attribute accordingly and go home\n  \tif (!options.value || typeof options.value === \"string\") {\n  \t\tthis.value = this.isBoolean ? true : options.value || \"\";\n  \t\treturn;\n  \t}\n\n  \t// otherwise we need to do some work\n\n  \t// share parentFragment with parent element\n  \tthis.parentFragment = this.element.parentFragment;\n\n  \tthis.fragment = new virtualdom_Fragment({\n  \t\ttemplate: options.value,\n  \t\troot: this.root,\n  \t\towner: this\n  \t});\n\n  \t// TODO can we use this.fragment.toString() in some cases? It's quicker\n  \tthis.value = this.fragment.getValue();\n\n  \t// Store a reference to this attribute's interpolator, if its fragment\n  \t// takes the form `{{foo}}`. This is necessary for two-way binding and\n  \t// for correctly rendering HTML later\n  \tthis.interpolator = helpers_getInterpolator(this);\n  \tthis.isBindable = !!this.interpolator && !this.interpolator.isStatic;\n\n  \t// mark as ready\n  \tthis.ready = true;\n  }\n\n  var Attribute_prototype_rebind = Attribute$rebind;\n\n  function Attribute$rebind(oldKeypath, newKeypath) {\n  \tif (this.fragment) {\n  \t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t}\n  }\n\n  var Attribute_prototype_render = Attribute$render;\n  var propertyNames = {\n  \t\"accept-charset\": \"acceptCharset\",\n  \taccesskey: \"accessKey\",\n  \tbgcolor: \"bgColor\",\n  \t\"class\": \"className\",\n  \tcodebase: \"codeBase\",\n  \tcolspan: \"colSpan\",\n  \tcontenteditable: \"contentEditable\",\n  \tdatetime: \"dateTime\",\n  \tdirname: \"dirName\",\n  \t\"for\": \"htmlFor\",\n  \t\"http-equiv\": \"httpEquiv\",\n  \tismap: \"isMap\",\n  \tmaxlength: \"maxLength\",\n  \tnovalidate: \"noValidate\",\n  \tpubdate: \"pubDate\",\n  \treadonly: \"readOnly\",\n  \trowspan: \"rowSpan\",\n  \ttabindex: \"tabIndex\",\n  \tusemap: \"useMap\"\n  };\n  function Attribute$render(node) {\n  \tvar propertyName;\n\n  \tthis.node = node;\n\n  \t// should we use direct property access, or setAttribute?\n  \tif (!node.namespaceURI || node.namespaceURI === namespaces.html) {\n  \t\tpropertyName = propertyNames[this.name] || this.name;\n\n  \t\tif (node[propertyName] !== undefined) {\n  \t\t\tthis.propertyName = propertyName;\n  \t\t}\n\n  \t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n  \t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n  \t\tif (this.isBoolean || this.isTwoway) {\n  \t\t\tthis.useProperty = true;\n  \t\t}\n\n  \t\tif (propertyName === \"value\") {\n  \t\t\tnode._ractive.value = this.value;\n  \t\t}\n  \t}\n\n  \tthis.rendered = true;\n  \tthis.update();\n  }\n\n  var Attribute_prototype_toString = Attribute$toString;\n\n  function Attribute$toString() {\n  \tvar _ref = this;\n\n  \tvar name = _ref.name;\n  \tvar namespacePrefix = _ref.namespacePrefix;\n  \tvar value = _ref.value;\n  \tvar interpolator = _ref.interpolator;\n  \tvar fragment = _ref.fragment;\n\n  \t// Special case - select and textarea values (should not be stringified)\n  \tif (name === \"value\" && (this.element.name === \"select\" || this.element.name === \"textarea\")) {\n  \t\treturn;\n  \t}\n\n  \t// Special case - content editable\n  \tif (name === \"value\" && this.element.getAttribute(\"contenteditable\") !== undefined) {\n  \t\treturn;\n  \t}\n\n  \t// Special case - radio names\n  \tif (name === \"name\" && this.element.name === \"input\" && interpolator) {\n  \t\treturn \"name={{\" + (interpolator.keypath.str || interpolator.ref) + \"}}\";\n  \t}\n\n  \t// Boolean attributes\n  \tif (this.isBoolean) {\n  \t\treturn value ? name : \"\";\n  \t}\n\n  \tif (fragment) {\n  \t\t// special case - this catches undefined/null values (#1211)\n  \t\tif (fragment.items.length === 1 && fragment.items[0].value == null) {\n  \t\t\treturn \"\";\n  \t\t}\n\n  \t\tvalue = fragment.toString();\n  \t}\n\n  \tif (namespacePrefix) {\n  \t\tname = namespacePrefix + \":\" + name;\n  \t}\n\n  \treturn value ? name + \"=\\\"\" + Attribute_prototype_toString__escape(value) + \"\\\"\" : name;\n  }\n\n  function Attribute_prototype_toString__escape(value) {\n  \treturn value.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#39;\");\n  }\n\n  var Attribute_prototype_unbind = Attribute$unbind;\n\n  function Attribute$unbind() {\n  \t// ignore non-dynamic attributes\n  \tif (this.fragment) {\n  \t\tthis.fragment.unbind();\n  \t}\n\n  \tif (this.name === \"id\") {\n  \t\tdelete this.root.nodes[this.value];\n  \t}\n  }\n\n  var updateSelectValue = Attribute$updateSelect;\n\n  function Attribute$updateSelect() {\n  \tvar value = this.value,\n  \t    options,\n  \t    option,\n  \t    optionValue,\n  \t    i;\n\n  \tif (!this.locked) {\n  \t\tthis.node._ractive.value = value;\n\n  \t\toptions = this.node.options;\n  \t\ti = options.length;\n\n  \t\twhile (i--) {\n  \t\t\toption = options[i];\n  \t\t\toptionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\n  \t\t\tif (optionValue == value) {\n  \t\t\t\t// double equals as we may be comparing numbers with strings\n  \t\t\t\toption.selected = true;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// if we're still here, it means the new value didn't match any of the options...\n  \t// TODO figure out what to do in this situation\n  }\n\n  var updateMultipleSelectValue = Attribute$updateMultipleSelect;\n  function Attribute$updateMultipleSelect() {\n  \tvar value = this.value,\n  \t    options,\n  \t    i,\n  \t    option,\n  \t    optionValue;\n\n  \tif (!isArray(value)) {\n  \t\tvalue = [value];\n  \t}\n\n  \toptions = this.node.options;\n  \ti = options.length;\n\n  \twhile (i--) {\n  \t\toption = options[i];\n  \t\toptionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n  \t\toption.selected = arrayContains(value, optionValue);\n  \t}\n  }\n\n  var updateRadioName = Attribute$updateRadioName;\n\n  function Attribute$updateRadioName() {\n  \tvar _ref = this;\n\n  \tvar node = _ref.node;\n  \tvar value = _ref.value;\n\n  \tnode.checked = value == node._ractive.value;\n  }\n\n  var updateRadioValue = Attribute$updateRadioValue;\n  function Attribute$updateRadioValue() {\n  \tvar wasChecked,\n  \t    node = this.node,\n  \t    binding,\n  \t    bindings,\n  \t    i;\n\n  \twasChecked = node.checked;\n\n  \tnode.value = this.element.getAttribute(\"value\");\n  \tnode.checked = this.element.getAttribute(\"value\") === this.element.getAttribute(\"name\");\n\n  \t// This is a special case - if the input was checked, and the value\n  \t// changed so that it's no longer checked, the twoway binding is\n  \t// most likely out of date. To fix it we have to jump through some\n  \t// hoops... this is a little kludgy but it works\n  \tif (wasChecked && !node.checked && this.element.binding) {\n  \t\tbindings = this.element.binding.siblings;\n\n  \t\tif (i = bindings.length) {\n  \t\t\twhile (i--) {\n  \t\t\t\tbinding = bindings[i];\n\n  \t\t\t\tif (!binding.element.node) {\n  \t\t\t\t\t// this is the initial render, siblings are still rendering!\n  \t\t\t\t\t// we'll come back later...\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tif (binding.element.node.checked) {\n  \t\t\t\t\tglobal_runloop.addRactive(binding.root);\n  \t\t\t\t\treturn binding.handleChange();\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tthis.root.viewmodel.set(binding.keypath, undefined);\n  \t\t}\n  \t}\n  }\n\n  var updateCheckboxName = Attribute$updateCheckboxName;\n  function Attribute$updateCheckboxName() {\n  \tvar _ref = this;\n\n  \tvar element = _ref.element;\n  \tvar node = _ref.node;\n  \tvar value = _ref.value;var binding = element.binding;var valueAttribute;var i;\n\n  \tvalueAttribute = element.getAttribute(\"value\");\n\n  \tif (!isArray(value)) {\n  \t\tbinding.isChecked = node.checked = value == valueAttribute;\n  \t} else {\n  \t\ti = value.length;\n  \t\twhile (i--) {\n  \t\t\tif (valueAttribute == value[i]) {\n  \t\t\t\tbinding.isChecked = node.checked = true;\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n  \t\tbinding.isChecked = node.checked = false;\n  \t}\n  }\n\n  var updateClassName = Attribute$updateClassName;\n  function Attribute$updateClassName() {\n  \tthis.node.className = safeToStringValue(this.value);\n  }\n\n  var updateIdAttribute = Attribute$updateIdAttribute;\n\n  function Attribute$updateIdAttribute() {\n  \tvar _ref = this;\n\n  \tvar node = _ref.node;\n  \tvar value = _ref.value;\n\n  \tthis.root.nodes[value] = node;\n  \tnode.id = value;\n  }\n\n  var updateIEStyleAttribute = Attribute$updateIEStyleAttribute;\n\n  function Attribute$updateIEStyleAttribute() {\n  \tvar node, value;\n\n  \tnode = this.node;\n  \tvalue = this.value;\n\n  \tif (value === undefined) {\n  \t\tvalue = \"\";\n  \t}\n\n  \tnode.style.setAttribute(\"cssText\", value);\n  }\n\n  var updateContentEditableValue = Attribute$updateContentEditableValue;\n\n  function Attribute$updateContentEditableValue() {\n  \tvar value = this.value;\n\n  \tif (value === undefined) {\n  \t\tvalue = \"\";\n  \t}\n\n  \tif (!this.locked) {\n  \t\tthis.node.innerHTML = value;\n  \t}\n  }\n\n  var updateValue = Attribute$updateValue;\n\n  function Attribute$updateValue() {\n  \tvar _ref = this;\n\n  \tvar node = _ref.node;\n  \tvar value = _ref.value;\n\n  \t// store actual value, so it doesn't get coerced to a string\n  \tnode._ractive.value = value;\n\n  \t// with two-way binding, only update if the change wasn't initiated by the user\n  \t// otherwise the cursor will often be sent to the wrong place\n  \tif (!this.locked) {\n  \t\tnode.value = value == undefined ? \"\" : value;\n  \t}\n  }\n\n  var updateBoolean = Attribute$updateBooleanAttribute;\n\n  function Attribute$updateBooleanAttribute() {\n  \t// with two-way binding, only update if the change wasn't initiated by the user\n  \t// otherwise the cursor will often be sent to the wrong place\n  \tif (!this.locked) {\n  \t\tthis.node[this.propertyName] = this.value;\n  \t}\n  }\n\n  var updateEverythingElse = Attribute$updateEverythingElse;\n\n  function Attribute$updateEverythingElse() {\n  \tvar _ref = this;\n\n  \tvar node = _ref.node;\n  \tvar namespace = _ref.namespace;\n  \tvar name = _ref.name;\n  \tvar value = _ref.value;\n  \tvar fragment = _ref.fragment;\n\n  \tif (namespace) {\n  \t\tnode.setAttributeNS(namespace, name, (fragment || value).toString());\n  \t} else if (!this.isBoolean) {\n  \t\tif (value == null) {\n  \t\t\tnode.removeAttribute(name);\n  \t\t} else {\n  \t\t\tnode.setAttribute(name, (fragment || value).toString());\n  \t\t}\n  \t}\n\n  \t// Boolean attributes - truthy becomes '', falsy means 'remove attribute'\n  \telse {\n  \t\tif (value) {\n  \t\t\tnode.setAttribute(name, \"\");\n  \t\t} else {\n  \t\t\tnode.removeAttribute(name);\n  \t\t}\n  \t}\n  }\n\n  // There are a few special cases when it comes to updating attributes. For this reason,\n  // the prototype .update() method points to this method, which waits until the\n  // attribute has finished initialising, then replaces the prototype method with a more\n  // suitable one. That way, we save ourselves doing a bunch of tests on each call\n  var Attribute_prototype_update = Attribute$update;\n  function Attribute$update() {\n  \tvar _ref = this;\n\n  \tvar name = _ref.name;\n  \tvar element = _ref.element;\n  \tvar node = _ref.node;var type;var updateMethod;\n\n  \tif (name === \"id\") {\n  \t\tupdateMethod = updateIdAttribute;\n  \t} else if (name === \"value\") {\n  \t\t// special case - selects\n  \t\tif (element.name === \"select\" && name === \"value\") {\n  \t\t\tupdateMethod = element.getAttribute(\"multiple\") ? updateMultipleSelectValue : updateSelectValue;\n  \t\t} else if (element.name === \"textarea\") {\n  \t\t\tupdateMethod = updateValue;\n  \t\t}\n\n  \t\t// special case - contenteditable\n  \t\telse if (element.getAttribute(\"contenteditable\") != null) {\n  \t\t\tupdateMethod = updateContentEditableValue;\n  \t\t}\n\n  \t\t// special case - <input>\n  \t\telse if (element.name === \"input\") {\n  \t\t\ttype = element.getAttribute(\"type\");\n\n  \t\t\t// type='file' value='{{fileList}}'>\n  \t\t\tif (type === \"file\") {\n  \t\t\t\tupdateMethod = noop; // read-only\n  \t\t\t}\n\n  \t\t\t// type='radio' name='{{twoway}}'\n  \t\t\telse if (type === \"radio\" && element.binding && element.binding.name === \"name\") {\n  \t\t\t\tupdateMethod = updateRadioValue;\n  \t\t\t} else {\n  \t\t\t\tupdateMethod = updateValue;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// special case - <input type='radio' name='{{twoway}}' value='foo'>\n  \telse if (this.isTwoway && name === \"name\") {\n  \t\tif (node.type === \"radio\") {\n  \t\t\tupdateMethod = updateRadioName;\n  \t\t} else if (node.type === \"checkbox\") {\n  \t\t\tupdateMethod = updateCheckboxName;\n  \t\t}\n  \t}\n\n  \t// special case - style attributes in Internet Exploder\n  \telse if (name === \"style\" && node.style.setAttribute) {\n  \t\tupdateMethod = updateIEStyleAttribute;\n  \t}\n\n  \t// special case - class names. IE fucks things up, again\n  \telse if (name === \"class\" && (!node.namespaceURI || node.namespaceURI === namespaces.html)) {\n  \t\tupdateMethod = updateClassName;\n  \t} else if (this.useProperty) {\n  \t\tupdateMethod = updateBoolean;\n  \t}\n\n  \tif (!updateMethod) {\n  \t\tupdateMethod = updateEverythingElse;\n  \t}\n\n  \tthis.update = updateMethod;\n  \tthis.update();\n  }\n\n  var Attribute = function (options) {\n  \tthis.init(options);\n  };\n\n  Attribute.prototype = {\n  \tbubble: Attribute_prototype_bubble,\n  \tinit: prototype_init,\n  \trebind: Attribute_prototype_rebind,\n  \trender: Attribute_prototype_render,\n  \ttoString: Attribute_prototype_toString,\n  \tunbind: Attribute_prototype_unbind,\n  \tupdate: Attribute_prototype_update\n  };\n\n  var _Attribute = Attribute;\n\n  var createAttributes = function (element, attributes) {\n  \tvar name,\n  \t    attribute,\n  \t    result = [];\n\n  \tfor (name in attributes) {\n  \t\t// skip binding attributes\n  \t\tif (name === \"twoway\" || name === \"lazy\") {\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tif (attributes.hasOwnProperty(name)) {\n  \t\t\tattribute = new _Attribute({\n  \t\t\t\telement: element,\n  \t\t\t\tname: name,\n  \t\t\t\tvalue: attributes[name],\n  \t\t\t\troot: element.root\n  \t\t\t});\n\n  \t\t\tresult[name] = attribute;\n\n  \t\t\tif (name !== \"value\") {\n  \t\t\t\tresult.push(attribute);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// value attribute goes last. This is because it\n  \t// may get clamped on render otherwise, e.g. in\n  \t// `<input type='range' value='999' min='0' max='1000'>`\n  \t// since default max is 100\n  \tif (attribute = result.value) {\n  \t\tresult.push(attribute);\n  \t}\n\n  \treturn result;\n  };\n\n  var _ConditionalAttribute__div;\n\n  if (typeof document !== \"undefined\") {\n  \t_ConditionalAttribute__div = createElement(\"div\");\n  }\n\n  var ConditionalAttribute = function (element, template) {\n  \tthis.element = element;\n  \tthis.root = element.root;\n  \tthis.parentFragment = element.parentFragment;\n\n  \tthis.attributes = [];\n\n  \tthis.fragment = new virtualdom_Fragment({\n  \t\troot: element.root,\n  \t\towner: this,\n  \t\ttemplate: [template]\n  \t});\n  };\n\n  ConditionalAttribute.prototype = {\n  \tbubble: function () {\n  \t\tif (this.node) {\n  \t\t\tthis.update();\n  \t\t}\n\n  \t\tthis.element.bubble();\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t},\n\n  \trender: function (node) {\n  \t\tthis.node = node;\n  \t\tthis.isSvg = node.namespaceURI === namespaces.svg;\n\n  \t\tthis.update();\n  \t},\n\n  \tunbind: function () {\n  \t\tthis.fragment.unbind();\n  \t},\n\n  \tupdate: function () {\n  \t\tvar _this = this;\n\n  \t\tvar str, attrs;\n\n  \t\tstr = this.fragment.toString();\n  \t\tattrs = parseAttributes(str, this.isSvg);\n\n  \t\t// any attributes that previously existed but no longer do\n  \t\t// must be removed\n  \t\tthis.attributes.filter(function (a) {\n  \t\t\treturn notIn(attrs, a);\n  \t\t}).forEach(function (a) {\n  \t\t\t_this.node.removeAttribute(a.name);\n  \t\t});\n\n  \t\tattrs.forEach(function (a) {\n  \t\t\t_this.node.setAttribute(a.name, a.value);\n  \t\t});\n\n  \t\tthis.attributes = attrs;\n  \t},\n\n  \ttoString: function () {\n  \t\treturn this.fragment.toString();\n  \t}\n  };\n\n  var _ConditionalAttribute = ConditionalAttribute;\n\n  function parseAttributes(str, isSvg) {\n  \tvar tag = isSvg ? \"svg\" : \"div\";\n  \t_ConditionalAttribute__div.innerHTML = \"<\" + tag + \" \" + str + \"></\" + tag + \">\";\n\n  \treturn toArray(_ConditionalAttribute__div.childNodes[0].attributes);\n  }\n\n  function notIn(haystack, needle) {\n  \tvar i = haystack.length;\n\n  \twhile (i--) {\n  \t\tif (haystack[i].name === needle.name) {\n  \t\t\treturn false;\n  \t\t}\n  \t}\n\n  \treturn true;\n  }\n\n  var createConditionalAttributes = function (element, attributes) {\n  \tif (!attributes) {\n  \t\treturn [];\n  \t}\n\n  \treturn attributes.map(function (a) {\n  \t\treturn new _ConditionalAttribute(element, a);\n  \t});\n  };\n\n  var Binding = function (element) {\n  \tvar interpolator, keypath, value, parentForm;\n\n  \tthis.element = element;\n  \tthis.root = element.root;\n  \tthis.attribute = element.attributes[this.name || \"value\"];\n\n  \tinterpolator = this.attribute.interpolator;\n  \tinterpolator.twowayBinding = this;\n\n  \tif (keypath = interpolator.keypath) {\n  \t\tif (keypath.str.slice(-1) === \"}\") {\n  \t\t\twarnOnceIfDebug(\"Two-way binding does not work with expressions (`%s` on <%s>)\", interpolator.resolver.uniqueString, element.name, { ractive: this.root });\n  \t\t\treturn false;\n  \t\t}\n\n  \t\tif (keypath.isSpecial) {\n  \t\t\twarnOnceIfDebug(\"Two-way binding does not work with %s\", interpolator.resolver.ref, { ractive: this.root });\n  \t\t\treturn false;\n  \t\t}\n  \t} else {\n  \t\t// A mustache may be *ambiguous*. Let's say we were given\n  \t\t// `value=\"{{bar}}\"`. If the context was `foo`, and `foo.bar`\n  \t\t// *wasn't* `undefined`, the keypath would be `foo.bar`.\n  \t\t// Then, any user input would result in `foo.bar` being updated.\n  \t\t//\n  \t\t// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be\n  \t\t// left with an unresolved partial keypath - so we are forced to make an\n  \t\t// assumption. That assumption is that the input in question should\n  \t\t// be forced to resolve to `bar`, and any user input would affect `bar`\n  \t\t// and not `foo.bar`.\n  \t\t//\n  \t\t// Did that make any sense? No? Oh. Sorry. Well the moral of the story is\n  \t\t// be explicit when using two-way data-binding about what keypath you're\n  \t\t// updating. Using it in lists is probably a recipe for confusion...\n  \t\tvar ref = interpolator.template.r ? \"'\" + interpolator.template.r + \"' reference\" : \"expression\";\n  \t\twarnIfDebug(\"The %s being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity\", ref, { ractive: this.root });\n  \t\tinterpolator.resolver.forceResolution();\n  \t\tkeypath = interpolator.keypath;\n  \t}\n\n  \tthis.attribute.isTwoway = true;\n  \tthis.keypath = keypath;\n\n  \t// initialise value, if it's undefined\n  \tvalue = this.root.viewmodel.get(keypath);\n\n  \tif (value === undefined && this.getInitialValue) {\n  \t\tvalue = this.getInitialValue();\n\n  \t\tif (value !== undefined) {\n  \t\t\tthis.root.viewmodel.set(keypath, value);\n  \t\t}\n  \t}\n\n  \tif (parentForm = findParentForm(element)) {\n  \t\tthis.resetValue = value;\n  \t\tparentForm.formBindings.push(this);\n  \t}\n  };\n\n  Binding.prototype = {\n  \thandleChange: function () {\n  \t\tvar _this = this;\n\n  \t\tglobal_runloop.start(this.root);\n  \t\tthis.attribute.locked = true;\n  \t\tthis.root.viewmodel.set(this.keypath, this.getValue());\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\treturn _this.attribute.locked = false;\n  \t\t});\n  \t\tglobal_runloop.end();\n  \t},\n\n  \trebound: function () {\n  \t\tvar bindings, oldKeypath, newKeypath;\n\n  \t\toldKeypath = this.keypath;\n  \t\tnewKeypath = this.attribute.interpolator.keypath;\n\n  \t\t// The attribute this binding is linked to has already done the work\n  \t\tif (oldKeypath === newKeypath) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tremoveFromArray(this.root._twowayBindings[oldKeypath.str], this);\n\n  \t\tthis.keypath = newKeypath;\n\n  \t\tbindings = this.root._twowayBindings[newKeypath.str] || (this.root._twowayBindings[newKeypath.str] = []);\n  \t\tbindings.push(this);\n  \t},\n\n  \tunbind: function () {}\n  };\n\n  Binding.extend = function (properties) {\n  \tvar Parent = this,\n  \t    SpecialisedBinding;\n\n  \tSpecialisedBinding = function (element) {\n  \t\tBinding.call(this, element);\n\n  \t\tif (this.init) {\n  \t\t\tthis.init();\n  \t\t}\n  \t};\n\n  \tSpecialisedBinding.prototype = create(Parent.prototype);\n  \tutils_object__extend(SpecialisedBinding.prototype, properties);\n\n  \tSpecialisedBinding.extend = Binding.extend;\n\n  \treturn SpecialisedBinding;\n  };\n\n  var Binding_Binding = Binding;\n\n  function findParentForm(element) {\n  \twhile (element = element.parent) {\n  \t\tif (element.name === \"form\") {\n  \t\t\treturn element;\n  \t\t}\n  \t}\n  }\n\n  // this is called when the element is unbound.\n  // Specialised bindings can override it\n\n  // This is the handler for DOM events that would lead to a change in the model\n  // (i.e. change, sometimes, input, and occasionally click and keyup)\n  var handleDomEvent = handleChange;\n\n  function handleChange() {\n  \tthis._ractive.binding.handleChange();\n  }\n\n  var GenericBinding;\n\n  GenericBinding = Binding_Binding.extend({\n  \tgetInitialValue: function () {\n  \t\treturn \"\";\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.element.node.value;\n  \t},\n\n  \trender: function () {\n  \t\tvar node = this.element.node,\n  \t\t    lazy,\n  \t\t    timeout = false;\n  \t\tthis.rendered = true;\n\n  \t\t// any lazy setting for this element overrides the root\n  \t\t// if the value is a number, it's a timeout\n  \t\tlazy = this.root.lazy;\n  \t\tif (this.element.lazy === true) {\n  \t\t\tlazy = true;\n  \t\t} else if (this.element.lazy === false) {\n  \t\t\tlazy = false;\n  \t\t} else if (is__isNumeric(this.element.lazy)) {\n  \t\t\tlazy = false;\n  \t\t\ttimeout = +this.element.lazy;\n  \t\t} else if (is__isNumeric(lazy || \"\")) {\n  \t\t\ttimeout = +lazy;\n  \t\t\tlazy = false;\n\n  \t\t\t// make sure the timeout is available to the handler\n  \t\t\tthis.element.lazy = timeout;\n  \t\t}\n\n  \t\tthis.handler = timeout ? handleDelay : handleDomEvent;\n\n  \t\tnode.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\tif (!lazy) {\n  \t\t\tnode.addEventListener(\"input\", this.handler, false);\n\n  \t\t\tif (node.attachEvent) {\n  \t\t\t\tnode.addEventListener(\"keyup\", this.handler, false);\n  \t\t\t}\n  \t\t}\n\n  \t\tnode.addEventListener(\"blur\", handleBlur, false);\n  \t},\n\n  \tunrender: function () {\n  \t\tvar node = this.element.node;\n  \t\tthis.rendered = false;\n\n  \t\tnode.removeEventListener(\"change\", handleDomEvent, false);\n  \t\tnode.removeEventListener(\"input\", this.handler, false);\n  \t\tnode.removeEventListener(\"keyup\", this.handler, false);\n  \t\tnode.removeEventListener(\"blur\", handleBlur, false);\n  \t}\n  });\n\n  var Binding_GenericBinding = GenericBinding;\n\n  function handleBlur() {\n  \tvar value;\n\n  \thandleDomEvent.call(this);\n\n  \tvalue = this._ractive.root.viewmodel.get(this._ractive.binding.keypath);\n  \tthis.value = value == undefined ? \"\" : value;\n  }\n\n  function handleDelay() {\n  \tvar binding = this._ractive.binding,\n  \t    el = this;\n\n  \tif (!!binding._timeout) clearTimeout(binding._timeout);\n\n  \tbinding._timeout = setTimeout(function () {\n  \t\tif (binding.rendered) handleDomEvent.call(el);\n  \t\tbinding._timeout = undefined;\n  \t}, binding.element.lazy);\n  }\n\n  var ContentEditableBinding = Binding_GenericBinding.extend({\n  \tgetInitialValue: function () {\n  \t\treturn this.element.fragment ? this.element.fragment.toString() : \"\";\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.element.node.innerHTML;\n  \t}\n  });\n\n  var Binding_ContentEditableBinding = ContentEditableBinding;\n\n  var shared_getSiblings = getSiblings;\n  var sets = {};\n  function getSiblings(id, group, keypath) {\n  \tvar hash = id + group + keypath;\n  \treturn sets[hash] || (sets[hash] = []);\n  }\n\n  var RadioBinding = Binding_Binding.extend({\n  \tname: \"checked\",\n\n  \tinit: function () {\n  \t\tthis.siblings = shared_getSiblings(this.root._guid, \"radio\", this.element.getAttribute(\"name\"));\n  \t\tthis.siblings.push(this);\n  \t},\n\n  \trender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\tif (node.attachEvent) {\n  \t\t\tnode.addEventListener(\"click\", handleDomEvent, false);\n  \t\t}\n  \t},\n\n  \tunrender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.removeEventListener(\"change\", handleDomEvent, false);\n  \t\tnode.removeEventListener(\"click\", handleDomEvent, false);\n  \t},\n\n  \thandleChange: function () {\n  \t\tglobal_runloop.start(this.root);\n\n  \t\tthis.siblings.forEach(function (binding) {\n  \t\t\tbinding.root.viewmodel.set(binding.keypath, binding.getValue());\n  \t\t});\n\n  \t\tglobal_runloop.end();\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.element.node.checked;\n  \t},\n\n  \tunbind: function () {\n  \t\tremoveFromArray(this.siblings, this);\n  \t}\n  });\n\n  var Binding_RadioBinding = RadioBinding;\n\n  var RadioNameBinding = Binding_Binding.extend({\n  \tname: \"name\",\n\n  \tinit: function () {\n  \t\tthis.siblings = shared_getSiblings(this.root._guid, \"radioname\", this.keypath.str);\n  \t\tthis.siblings.push(this);\n\n  \t\tthis.radioName = true; // so that ractive.updateModel() knows what to do with this\n  \t},\n\n  \tgetInitialValue: function () {\n  \t\tif (this.element.getAttribute(\"checked\")) {\n  \t\t\treturn this.element.getAttribute(\"value\");\n  \t\t}\n  \t},\n\n  \trender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.name = \"{{\" + this.keypath.str + \"}}\";\n  \t\tnode.checked = this.root.viewmodel.get(this.keypath) == this.element.getAttribute(\"value\");\n\n  \t\tnode.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\tif (node.attachEvent) {\n  \t\t\tnode.addEventListener(\"click\", handleDomEvent, false);\n  \t\t}\n  \t},\n\n  \tunrender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.removeEventListener(\"change\", handleDomEvent, false);\n  \t\tnode.removeEventListener(\"click\", handleDomEvent, false);\n  \t},\n\n  \tgetValue: function () {\n  \t\tvar node = this.element.node;\n  \t\treturn node._ractive ? node._ractive.value : node.value;\n  \t},\n\n  \thandleChange: function () {\n  \t\t// If this <input> is the one that's checked, then the value of its\n  \t\t// `name` keypath gets set to its value\n  \t\tif (this.element.node.checked) {\n  \t\t\tBinding_Binding.prototype.handleChange.call(this);\n  \t\t}\n  \t},\n\n  \trebound: function (oldKeypath, newKeypath) {\n  \t\tvar node;\n\n  \t\tBinding_Binding.prototype.rebound.call(this, oldKeypath, newKeypath);\n\n  \t\tif (node = this.element.node) {\n  \t\t\tnode.name = \"{{\" + this.keypath.str + \"}}\";\n  \t\t}\n  \t},\n\n  \tunbind: function () {\n  \t\tremoveFromArray(this.siblings, this);\n  \t}\n  });\n\n  var Binding_RadioNameBinding = RadioNameBinding;\n\n  var CheckboxNameBinding = Binding_Binding.extend({\n  \tname: \"name\",\n\n  \tgetInitialValue: function () {\n  \t\t// This only gets called once per group (of inputs that\n  \t\t// share a name), because it only gets called if there\n  \t\t// isn't an initial value. By the same token, we can make\n  \t\t// a note of that fact that there was no initial value,\n  \t\t// and populate it using any `checked` attributes that\n  \t\t// exist (which users should avoid, but which we should\n  \t\t// support anyway to avoid breaking expectations)\n  \t\tthis.noInitialValue = true;\n  \t\treturn [];\n  \t},\n\n  \tinit: function () {\n  \t\tvar existingValue, bindingValue;\n\n  \t\tthis.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n  \t\t// Each input has a reference to an array containing it and its\n  \t\t// siblings, as two-way binding depends on being able to ascertain\n  \t\t// the status of all inputs within the group\n  \t\tthis.siblings = shared_getSiblings(this.root._guid, \"checkboxes\", this.keypath.str);\n  \t\tthis.siblings.push(this);\n\n  \t\tif (this.noInitialValue) {\n  \t\t\tthis.siblings.noInitialValue = true;\n  \t\t}\n\n  \t\t// If no initial value was set, and this input is checked, we\n  \t\t// update the model\n  \t\tif (this.siblings.noInitialValue && this.element.getAttribute(\"checked\")) {\n  \t\t\texistingValue = this.root.viewmodel.get(this.keypath);\n  \t\t\tbindingValue = this.element.getAttribute(\"value\");\n\n  \t\t\texistingValue.push(bindingValue);\n  \t\t}\n  \t},\n\n  \tunbind: function () {\n  \t\tremoveFromArray(this.siblings, this);\n  \t},\n\n  \trender: function () {\n  \t\tvar node = this.element.node,\n  \t\t    existingValue,\n  \t\t    bindingValue;\n\n  \t\texistingValue = this.root.viewmodel.get(this.keypath);\n  \t\tbindingValue = this.element.getAttribute(\"value\");\n\n  \t\tif (isArray(existingValue)) {\n  \t\t\tthis.isChecked = arrayContains(existingValue, bindingValue);\n  \t\t} else {\n  \t\t\tthis.isChecked = existingValue == bindingValue;\n  \t\t}\n\n  \t\tnode.name = \"{{\" + this.keypath.str + \"}}\";\n  \t\tnode.checked = this.isChecked;\n\n  \t\tnode.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\t// in case of IE emergency, bind to click event as well\n  \t\tif (node.attachEvent) {\n  \t\t\tnode.addEventListener(\"click\", handleDomEvent, false);\n  \t\t}\n  \t},\n\n  \tunrender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.removeEventListener(\"change\", handleDomEvent, false);\n  \t\tnode.removeEventListener(\"click\", handleDomEvent, false);\n  \t},\n\n  \tchanged: function () {\n  \t\tvar wasChecked = !!this.isChecked;\n  \t\tthis.isChecked = this.element.node.checked;\n  \t\treturn this.isChecked === wasChecked;\n  \t},\n\n  \thandleChange: function () {\n  \t\tthis.isChecked = this.element.node.checked;\n  \t\tBinding_Binding.prototype.handleChange.call(this);\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.siblings.filter(isChecked).map(Binding_CheckboxNameBinding__getValue);\n  \t}\n  });\n\n  function isChecked(binding) {\n  \treturn binding.isChecked;\n  }\n\n  function Binding_CheckboxNameBinding__getValue(binding) {\n  \treturn binding.element.getAttribute(\"value\");\n  }\n\n  var Binding_CheckboxNameBinding = CheckboxNameBinding;\n\n  var CheckboxBinding = Binding_Binding.extend({\n  \tname: \"checked\",\n\n  \trender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\tif (node.attachEvent) {\n  \t\t\tnode.addEventListener(\"click\", handleDomEvent, false);\n  \t\t}\n  \t},\n\n  \tunrender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.removeEventListener(\"change\", handleDomEvent, false);\n  \t\tnode.removeEventListener(\"click\", handleDomEvent, false);\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.element.node.checked;\n  \t}\n  });\n\n  var Binding_CheckboxBinding = CheckboxBinding;\n\n  var SelectBinding = Binding_Binding.extend({\n  \tgetInitialValue: function () {\n  \t\tvar options = this.element.options,\n  \t\t    len,\n  \t\t    i,\n  \t\t    value,\n  \t\t    optionWasSelected;\n\n  \t\tif (this.element.getAttribute(\"value\") !== undefined) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\ti = len = options.length;\n\n  \t\tif (!len) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// take the final selected option...\n  \t\twhile (i--) {\n  \t\t\tif (options[i].getAttribute(\"selected\")) {\n  \t\t\t\tvalue = options[i].getAttribute(\"value\");\n  \t\t\t\toptionWasSelected = true;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n\n  \t\t// or the first non-disabled option, if none are selected\n  \t\tif (!optionWasSelected) {\n  \t\t\twhile (++i < len) {\n  \t\t\t\tif (!options[i].getAttribute(\"disabled\")) {\n  \t\t\t\t\tvalue = options[i].getAttribute(\"value\");\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// This is an optimisation (aka hack) that allows us to forgo some\n  \t\t// other more expensive work\n  \t\tif (value !== undefined) {\n  \t\t\tthis.element.attributes.value.value = value;\n  \t\t}\n\n  \t\treturn value;\n  \t},\n\n  \trender: function () {\n  \t\tthis.element.node.addEventListener(\"change\", handleDomEvent, false);\n  \t},\n\n  \tunrender: function () {\n  \t\tthis.element.node.removeEventListener(\"change\", handleDomEvent, false);\n  \t},\n\n  \t// TODO this method is an anomaly... is it necessary?\n  \tsetValue: function (value) {\n  \t\tthis.root.viewmodel.set(this.keypath, value);\n  \t},\n\n  \tgetValue: function () {\n  \t\tvar options, i, len, option, optionValue;\n\n  \t\toptions = this.element.node.options;\n  \t\tlen = options.length;\n\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\toption = options[i];\n\n  \t\t\tif (options[i].selected) {\n  \t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n  \t\t\t\treturn optionValue;\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tforceUpdate: function () {\n  \t\tvar _this = this;\n\n  \t\tvar value = this.getValue();\n\n  \t\tif (value !== undefined) {\n  \t\t\tthis.attribute.locked = true;\n  \t\t\tglobal_runloop.scheduleTask(function () {\n  \t\t\t\treturn _this.attribute.locked = false;\n  \t\t\t});\n  \t\t\tthis.root.viewmodel.set(this.keypath, value);\n  \t\t}\n  \t}\n  });\n\n  var Binding_SelectBinding = SelectBinding;\n\n  var MultipleSelectBinding = Binding_SelectBinding.extend({\n  \tgetInitialValue: function () {\n  \t\treturn this.element.options.filter(function (option) {\n  \t\t\treturn option.getAttribute(\"selected\");\n  \t\t}).map(function (option) {\n  \t\t\treturn option.getAttribute(\"value\");\n  \t\t});\n  \t},\n\n  \trender: function () {\n  \t\tvar valueFromModel;\n\n  \t\tthis.element.node.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\tvalueFromModel = this.root.viewmodel.get(this.keypath);\n\n  \t\tif (valueFromModel === undefined) {\n  \t\t\t// get value from DOM, if possible\n  \t\t\tthis.handleChange();\n  \t\t}\n  \t},\n\n  \tunrender: function () {\n  \t\tthis.element.node.removeEventListener(\"change\", handleDomEvent, false);\n  \t},\n\n  \tsetValue: function () {\n  \t\tthrow new Error(\"TODO not implemented yet\");\n  \t},\n\n  \tgetValue: function () {\n  \t\tvar selectedValues, options, i, len, option, optionValue;\n\n  \t\tselectedValues = [];\n  \t\toptions = this.element.node.options;\n  \t\tlen = options.length;\n\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\toption = options[i];\n\n  \t\t\tif (option.selected) {\n  \t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n  \t\t\t\tselectedValues.push(optionValue);\n  \t\t\t}\n  \t\t}\n\n  \t\treturn selectedValues;\n  \t},\n\n  \thandleChange: function () {\n  \t\tvar attribute, previousValue, value;\n\n  \t\tattribute = this.attribute;\n  \t\tpreviousValue = attribute.value;\n\n  \t\tvalue = this.getValue();\n\n  \t\tif (previousValue === undefined || !arrayContentsMatch(value, previousValue)) {\n  \t\t\tBinding_SelectBinding.prototype.handleChange.call(this);\n  \t\t}\n\n  \t\treturn this;\n  \t},\n\n  \tforceUpdate: function () {\n  \t\tvar _this = this;\n\n  \t\tvar value = this.getValue();\n\n  \t\tif (value !== undefined) {\n  \t\t\tthis.attribute.locked = true;\n  \t\t\tglobal_runloop.scheduleTask(function () {\n  \t\t\t\treturn _this.attribute.locked = false;\n  \t\t\t});\n  \t\t\tthis.root.viewmodel.set(this.keypath, value);\n  \t\t}\n  \t},\n\n  \tupdateModel: function () {\n  \t\tif (this.attribute.value === undefined || !this.attribute.value.length) {\n  \t\t\tthis.root.viewmodel.set(this.keypath, this.initialValue);\n  \t\t}\n  \t}\n  });\n\n  var Binding_MultipleSelectBinding = MultipleSelectBinding;\n\n  var FileListBinding = Binding_Binding.extend({\n  \trender: function () {\n  \t\tthis.element.node.addEventListener(\"change\", handleDomEvent, false);\n  \t},\n\n  \tunrender: function () {\n  \t\tthis.element.node.removeEventListener(\"change\", handleDomEvent, false);\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.element.node.files;\n  \t}\n  });\n\n  var Binding_FileListBinding = FileListBinding;\n\n  var NumericBinding = Binding_GenericBinding.extend({\n  \tgetInitialValue: function () {\n  \t\treturn undefined;\n  \t},\n\n  \tgetValue: function () {\n  \t\tvar value = parseFloat(this.element.node.value);\n  \t\treturn isNaN(value) ? undefined : value;\n  \t}\n  });\n\n  var init_createTwowayBinding = createTwowayBinding;\n\n  function createTwowayBinding(element) {\n  \tvar attributes = element.attributes,\n  \t    type,\n  \t    Binding,\n  \t    bindName,\n  \t    bindChecked,\n  \t    binding;\n\n  \t// if this is a late binding, and there's already one, it\n  \t// needs to be torn down\n  \tif (element.binding) {\n  \t\telement.binding.teardown();\n  \t\telement.binding = null;\n  \t}\n\n  \t// contenteditable\n  \tif (\n  \t// if the contenteditable attribute is true or is bindable and may thus become true\n  \t(element.getAttribute(\"contenteditable\") || !!attributes.contenteditable && isBindable(attributes.contenteditable)) && isBindable(attributes.value)) {\n  \t\tBinding = Binding_ContentEditableBinding;\n  \t}\n\n  \t// <input>\n  \telse if (element.name === \"input\") {\n  \t\ttype = element.getAttribute(\"type\");\n\n  \t\tif (type === \"radio\" || type === \"checkbox\") {\n  \t\t\tbindName = isBindable(attributes.name);\n  \t\t\tbindChecked = isBindable(attributes.checked);\n\n  \t\t\t// we can either bind the name attribute, or the checked attribute - not both\n  \t\t\tif (bindName && bindChecked) {\n  \t\t\t\twarnIfDebug(\"A radio input can have two-way binding on its name attribute, or its checked attribute - not both\", { ractive: element.root });\n  \t\t\t}\n\n  \t\t\tif (bindName) {\n  \t\t\t\tBinding = type === \"radio\" ? Binding_RadioNameBinding : Binding_CheckboxNameBinding;\n  \t\t\t} else if (bindChecked) {\n  \t\t\t\tBinding = type === \"radio\" ? Binding_RadioBinding : Binding_CheckboxBinding;\n  \t\t\t}\n  \t\t} else if (type === \"file\" && isBindable(attributes.value)) {\n  \t\t\tBinding = Binding_FileListBinding;\n  \t\t} else if (isBindable(attributes.value)) {\n  \t\t\tBinding = type === \"number\" || type === \"range\" ? NumericBinding : Binding_GenericBinding;\n  \t\t}\n  \t}\n\n  \t// <select>\n  \telse if (element.name === \"select\" && isBindable(attributes.value)) {\n  \t\tBinding = element.getAttribute(\"multiple\") ? Binding_MultipleSelectBinding : Binding_SelectBinding;\n  \t}\n\n  \t// <textarea>\n  \telse if (element.name === \"textarea\" && isBindable(attributes.value)) {\n  \t\tBinding = Binding_GenericBinding;\n  \t}\n\n  \tif (Binding && (binding = new Binding(element)) && binding.keypath) {\n  \t\treturn binding;\n  \t}\n  }\n\n  function isBindable(attribute) {\n  \treturn attribute && attribute.isBindable;\n  }\n\n  // and this element also has a value attribute to bind\n\n  var EventHandler_prototype_bubble = EventHandler$bubble;\n\n  function EventHandler$bubble() {\n  \tvar hasAction = this.getAction();\n\n  \tif (hasAction && !this.hasListener) {\n  \t\tthis.listen();\n  \t} else if (!hasAction && this.hasListener) {\n  \t\tthis.unrender();\n  \t}\n  }\n\n  // This function may be overwritten, if the event directive\n  // includes parameters\n  var EventHandler_prototype_fire = EventHandler$fire;\n  function EventHandler$fire(event) {\n  \tshared_fireEvent(this.root, this.getAction(), { event: event });\n  }\n\n  var getAction = EventHandler$getAction;\n\n  function EventHandler$getAction() {\n  \treturn this.action.toString().trim();\n  }\n\n  var EventHandler_prototype_init = EventHandler$init;\n\n  var eventPattern = /^event(?:\\.(.+))?/;\n  function EventHandler$init(element, name, template) {\n  \tvar _this = this;\n\n  \tvar action, refs, ractive;\n\n  \tthis.element = element;\n  \tthis.root = element.root;\n  \tthis.parentFragment = element.parentFragment;\n  \tthis.name = name;\n\n  \tif (name.indexOf(\"*\") !== -1) {\n  \t\tfatal(\"Only component proxy-events may contain \\\"*\\\" wildcards, <%s on-%s=\\\"...\\\"/> is not valid\", element.name, name);\n  \t\tthis.invalid = true;\n  \t}\n\n  \tif (template.m) {\n  \t\trefs = template.a.r;\n\n  \t\t// This is a method call\n  \t\tthis.method = template.m;\n  \t\tthis.keypaths = [];\n  \t\tthis.fn = shared_getFunctionFromString(template.a.s, refs.length);\n\n  \t\tthis.parentFragment = element.parentFragment;\n  \t\tractive = this.root;\n\n  \t\t// Create resolvers for each reference\n  \t\tthis.refResolvers = [];\n  \t\trefs.forEach(function (ref, i) {\n  \t\t\tvar match = undefined;\n\n  \t\t\t// special case - the `event` object\n  \t\t\tif (match = eventPattern.exec(ref)) {\n  \t\t\t\t_this.keypaths[i] = {\n  \t\t\t\t\teventObject: true,\n  \t\t\t\t\trefinements: match[1] ? match[1].split(\".\") : []\n  \t\t\t\t};\n  \t\t\t} else {\n  \t\t\t\t_this.refResolvers.push(Resolvers_createReferenceResolver(_this, ref, function (keypath) {\n  \t\t\t\t\treturn _this.resolve(i, keypath);\n  \t\t\t\t}));\n  \t\t\t}\n  \t\t});\n\n  \t\tthis.fire = fireMethodCall;\n  \t} else {\n  \t\t// Get action ('foo' in 'on-click='foo')\n  \t\taction = template.n || template;\n  \t\tif (typeof action !== \"string\") {\n  \t\t\taction = new virtualdom_Fragment({\n  \t\t\t\ttemplate: action,\n  \t\t\t\troot: this.root,\n  \t\t\t\towner: this\n  \t\t\t});\n  \t\t}\n\n  \t\tthis.action = action;\n\n  \t\t// Get parameters\n  \t\tif (template.d) {\n  \t\t\tthis.dynamicParams = new virtualdom_Fragment({\n  \t\t\t\ttemplate: template.d,\n  \t\t\t\troot: this.root,\n  \t\t\t\towner: this.element\n  \t\t\t});\n\n  \t\t\tthis.fire = fireEventWithDynamicParams;\n  \t\t} else if (template.a) {\n  \t\t\tthis.params = template.a;\n  \t\t\tthis.fire = fireEventWithParams;\n  \t\t}\n  \t}\n  }\n\n  function fireMethodCall(event) {\n  \tvar ractive, values, args;\n\n  \tractive = this.root;\n\n  \tif (typeof ractive[this.method] !== \"function\") {\n  \t\tthrow new Error(\"Attempted to call a non-existent method (\\\"\" + this.method + \"\\\")\");\n  \t}\n\n  \tvalues = this.keypaths.map(function (keypath) {\n  \t\tvar value, len, i;\n\n  \t\tif (keypath === undefined) {\n  \t\t\t// not yet resolved\n  \t\t\treturn undefined;\n  \t\t}\n\n  \t\t// TODO the refinements stuff would be better handled at parse time\n  \t\tif (keypath.eventObject) {\n  \t\t\tvalue = event;\n\n  \t\t\tif (len = keypath.refinements.length) {\n  \t\t\t\tfor (i = 0; i < len; i += 1) {\n  \t\t\t\t\tvalue = value[keypath.refinements[i]];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else {\n  \t\t\tvalue = ractive.viewmodel.get(keypath);\n  \t\t}\n\n  \t\treturn value;\n  \t});\n\n  \tshared_eventStack.enqueue(ractive, event);\n\n  \targs = this.fn.apply(null, values);\n  \tractive[this.method].apply(ractive, args);\n\n  \tshared_eventStack.dequeue(ractive);\n  }\n\n  function fireEventWithParams(event) {\n  \tshared_fireEvent(this.root, this.getAction(), { event: event, args: this.params });\n  }\n\n  function fireEventWithDynamicParams(event) {\n  \tvar args = this.dynamicParams.getArgsList();\n\n  \t// need to strip [] from ends if a string!\n  \tif (typeof args === \"string\") {\n  \t\targs = args.substr(1, args.length - 2);\n  \t}\n\n  \tshared_fireEvent(this.root, this.getAction(), { event: event, args: args });\n  }\n\n  var shared_genericHandler = genericHandler;\n  function genericHandler(event) {\n  \tvar storage,\n  \t    handler,\n  \t    indices,\n  \t    index = {};\n\n  \tstorage = this._ractive;\n  \thandler = storage.events[event.type];\n\n  \tif (indices = Resolvers_findIndexRefs(handler.element.parentFragment)) {\n  \t\tindex = Resolvers_findIndexRefs.resolve(indices);\n  \t}\n\n  \thandler.fire({\n  \t\tnode: this,\n  \t\toriginal: event,\n  \t\tindex: index,\n  \t\tkeypath: storage.keypath.str,\n  \t\tcontext: storage.root.viewmodel.get(storage.keypath)\n  \t});\n  }\n\n  var listen = EventHandler$listen;\n\n  var customHandlers = {},\n      touchEvents = {\n  \ttouchstart: true,\n  \ttouchmove: true,\n  \ttouchend: true,\n  \ttouchcancel: true,\n  \t//not w3c, but supported in some browsers\n  \ttouchleave: true\n  };\n  function EventHandler$listen() {\n  \tvar definition,\n  \t    name = this.name;\n\n  \tif (this.invalid) {\n  \t\treturn;\n  \t}\n\n  \tif (definition = findInViewHierarchy(\"events\", this.root, name)) {\n  \t\tthis.custom = definition(this.node, getCustomHandler(name));\n  \t} else {\n  \t\t// Looks like we're dealing with a standard DOM event... but let's check\n  \t\tif (!(\"on\" + name in this.node) && !(window && \"on\" + name in window) && !isJsdom) {\n\n  \t\t\t// okay to use touch events if this browser doesn't support them\n  \t\t\tif (!touchEvents[name]) {\n  \t\t\t\twarnOnceIfDebug(missingPlugin(name, \"event\"), { node: this.node });\n  \t\t\t}\n\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.node.addEventListener(name, shared_genericHandler, false);\n  \t}\n\n  \tthis.hasListener = true;\n  }\n\n  function getCustomHandler(name) {\n  \tif (!customHandlers[name]) {\n  \t\tcustomHandlers[name] = function (event) {\n  \t\t\tvar storage = event.node._ractive;\n\n  \t\t\tevent.index = storage.index;\n  \t\t\tevent.keypath = storage.keypath.str;\n  \t\t\tevent.context = storage.root.viewmodel.get(storage.keypath);\n\n  \t\t\tstorage.events[name].fire(event);\n  \t\t};\n  \t}\n\n  \treturn customHandlers[name];\n  }\n\n  var EventHandler_prototype_rebind = EventHandler$rebind;\n\n  function EventHandler$rebind(oldKeypath, newKeypath) {\n  \tvar fragment;\n  \tif (this.method) {\n  \t\tfragment = this.element.parentFragment;\n  \t\tthis.refResolvers.forEach(rebind);\n\n  \t\treturn;\n  \t}\n\n  \tif (typeof this.action !== \"string\") {\n  \t\trebind(this.action);\n  \t}\n\n  \tif (this.dynamicParams) {\n  \t\trebind(this.dynamicParams);\n  \t}\n\n  \tfunction rebind(thing) {\n  \t\tthing && thing.rebind(oldKeypath, newKeypath);\n  \t}\n  }\n\n  var EventHandler_prototype_render = EventHandler$render;\n\n  function EventHandler$render() {\n  \tthis.node = this.element.node;\n  \t// store this on the node itself, so it can be retrieved by a\n  \t// universal handler\n  \tthis.node._ractive.events[this.name] = this;\n\n  \tif (this.method || this.getAction()) {\n  \t\tthis.listen();\n  \t}\n  }\n\n  var prototype_resolve = EventHandler$resolve;\n\n  function EventHandler$resolve(index, keypath) {\n  \tthis.keypaths[index] = keypath;\n  }\n\n  var EventHandler_prototype_unbind = EventHandler$unbind;\n  function EventHandler$unbind() {\n  \tif (this.method) {\n  \t\tthis.refResolvers.forEach(methodCallers__unbind);\n  \t\treturn;\n  \t}\n\n  \t// Tear down dynamic name\n  \tif (typeof this.action !== \"string\") {\n  \t\tthis.action.unbind();\n  \t}\n\n  \t// Tear down dynamic parameters\n  \tif (this.dynamicParams) {\n  \t\tthis.dynamicParams.unbind();\n  \t}\n  }\n\n  var EventHandler_prototype_unrender = EventHandler$unrender;\n  function EventHandler$unrender() {\n\n  \tif (this.custom) {\n  \t\tthis.custom.teardown();\n  \t} else {\n  \t\tthis.node.removeEventListener(this.name, shared_genericHandler, false);\n  \t}\n\n  \tthis.hasListener = false;\n  }\n\n  var EventHandler = function (element, name, template) {\n  \tthis.init(element, name, template);\n  };\n\n  EventHandler.prototype = {\n  \tbubble: EventHandler_prototype_bubble,\n  \tfire: EventHandler_prototype_fire,\n  \tgetAction: getAction,\n  \tinit: EventHandler_prototype_init,\n  \tlisten: listen,\n  \trebind: EventHandler_prototype_rebind,\n  \trender: EventHandler_prototype_render,\n  \tresolve: prototype_resolve,\n  \tunbind: EventHandler_prototype_unbind,\n  \tunrender: EventHandler_prototype_unrender\n  };\n\n  var _EventHandler = EventHandler;\n\n  var createEventHandlers = function (element, template) {\n  \tvar i,\n  \t    name,\n  \t    names,\n  \t    handler,\n  \t    result = [];\n\n  \tfor (name in template) {\n  \t\tif (template.hasOwnProperty(name)) {\n  \t\t\tnames = name.split(\"-\");\n  \t\t\ti = names.length;\n\n  \t\t\twhile (i--) {\n  \t\t\t\thandler = new _EventHandler(element, names[i], template[name]);\n  \t\t\t\tresult.push(handler);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn result;\n  };\n\n  var Decorator = function (element, template) {\n  \tvar self = this,\n  \t    ractive,\n  \t    name,\n  \t    fragment;\n\n  \tthis.element = element;\n  \tthis.root = ractive = element.root;\n\n  \tname = template.n || template;\n\n  \tif (typeof name !== \"string\") {\n  \t\tfragment = new virtualdom_Fragment({\n  \t\t\ttemplate: name,\n  \t\t\troot: ractive,\n  \t\t\towner: element\n  \t\t});\n\n  \t\tname = fragment.toString();\n  \t\tfragment.unbind();\n\n  \t\tif (name === \"\") {\n  \t\t\t// empty string okay, just no decorator\n  \t\t\treturn;\n  \t\t}\n  \t}\n\n  \tif (template.a) {\n  \t\tthis.params = template.a;\n  \t} else if (template.d) {\n  \t\tthis.fragment = new virtualdom_Fragment({\n  \t\t\ttemplate: template.d,\n  \t\t\troot: ractive,\n  \t\t\towner: element\n  \t\t});\n\n  \t\tthis.params = this.fragment.getArgsList();\n\n  \t\tthis.fragment.bubble = function () {\n  \t\t\tthis.dirtyArgs = this.dirtyValue = true;\n  \t\t\tself.params = this.getArgsList();\n\n  \t\t\tif (self.ready) {\n  \t\t\t\tself.update();\n  \t\t\t}\n  \t\t};\n  \t}\n\n  \tthis.fn = findInViewHierarchy(\"decorators\", ractive, name);\n\n  \tif (!this.fn) {\n  \t\tfatal(missingPlugin(name, \"decorator\"));\n  \t}\n  };\n\n  Decorator.prototype = {\n  \tinit: function () {\n  \t\tvar node, result, args;\n\n  \t\tnode = this.element.node;\n\n  \t\tif (this.params) {\n  \t\t\targs = [node].concat(this.params);\n  \t\t\tresult = this.fn.apply(this.root, args);\n  \t\t} else {\n  \t\t\tresult = this.fn.call(this.root, node);\n  \t\t}\n\n  \t\tif (!result || !result.teardown) {\n  \t\t\tthrow new Error(\"Decorator definition must return an object with a teardown method\");\n  \t\t}\n\n  \t\t// TODO does this make sense?\n  \t\tthis.actual = result;\n  \t\tthis.ready = true;\n  \t},\n\n  \tupdate: function () {\n  \t\tif (this.actual.update) {\n  \t\t\tthis.actual.update.apply(this.root, this.params);\n  \t\t} else {\n  \t\t\tthis.actual.teardown(true);\n  \t\t\tthis.init();\n  \t\t}\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tif (this.fragment) {\n  \t\t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t\t}\n  \t},\n\n  \tteardown: function (updating) {\n  \t\tthis.torndown = true;\n  \t\tif (this.ready) {\n  \t\t\tthis.actual.teardown();\n  \t\t}\n\n  \t\tif (!updating && this.fragment) {\n  \t\t\tthis.fragment.unbind();\n  \t\t}\n  \t}\n  };\n\n  var _Decorator = Decorator;\n\n  function select__bubble() {\n  \tvar _this = this;\n\n  \tif (!this.dirty) {\n  \t\tthis.dirty = true;\n\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\tsync(_this);\n  \t\t\t_this.dirty = false;\n  \t\t});\n  \t}\n\n  \tthis.parentFragment.bubble(); // default behaviour\n  }\n\n  function sync(selectElement) {\n  \tvar selectNode, selectValue, isMultiple, options, optionWasSelected;\n\n  \tselectNode = selectElement.node;\n\n  \tif (!selectNode) {\n  \t\treturn;\n  \t}\n\n  \toptions = toArray(selectNode.options);\n\n  \tselectValue = selectElement.getAttribute(\"value\");\n  \tisMultiple = selectElement.getAttribute(\"multiple\");\n\n  \t// If the <select> has a specified value, that should override\n  \t// these options\n  \tif (selectValue !== undefined) {\n  \t\toptions.forEach(function (o) {\n  \t\t\tvar optionValue, shouldSelect;\n\n  \t\t\toptionValue = o._ractive ? o._ractive.value : o.value;\n  \t\t\tshouldSelect = isMultiple ? valueContains(selectValue, optionValue) : selectValue == optionValue;\n\n  \t\t\tif (shouldSelect) {\n  \t\t\t\toptionWasSelected = true;\n  \t\t\t}\n\n  \t\t\to.selected = shouldSelect;\n  \t\t});\n\n  \t\tif (!optionWasSelected) {\n  \t\t\tif (options[0]) {\n  \t\t\t\toptions[0].selected = true;\n  \t\t\t}\n\n  \t\t\tif (selectElement.binding) {\n  \t\t\t\tselectElement.binding.forceUpdate();\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// Otherwise the value should be initialised according to which\n  \t// <option> element is selected, if twoway binding is in effect\n  \telse if (selectElement.binding) {\n  \t\tselectElement.binding.forceUpdate();\n  \t}\n  }\n\n  function valueContains(selectValue, optionValue) {\n  \tvar i = selectValue.length;\n  \twhile (i--) {\n  \t\tif (selectValue[i] == optionValue) {\n  \t\t\treturn true;\n  \t\t}\n  \t}\n  }\n\n  function special_option__init(option, template) {\n  \toption.select = findParentSelect(option.parent);\n\n  \t// we might be inside a <datalist> element\n  \tif (!option.select) {\n  \t\treturn;\n  \t}\n\n  \toption.select.options.push(option);\n\n  \t// If the value attribute is missing, use the element's content\n  \tif (!template.a) {\n  \t\ttemplate.a = {};\n  \t}\n\n  \t// ...as long as it isn't disabled\n  \tif (template.a.value === undefined && !template.a.hasOwnProperty(\"disabled\")) {\n  \t\ttemplate.a.value = template.f;\n  \t}\n\n  \t// If there is a `selected` attribute, but the <select>\n  \t// already has a value, delete it\n  \tif (\"selected\" in template.a && option.select.getAttribute(\"value\") !== undefined) {\n  \t\tdelete template.a.selected;\n  \t}\n  }\n\n  function special_option__unbind(option) {\n  \tif (option.select) {\n  \t\tremoveFromArray(option.select.options, option);\n  \t}\n  }\n\n  function findParentSelect(element) {\n  \tif (!element) {\n  \t\treturn;\n  \t}\n\n  \tdo {\n  \t\tif (element.name === \"select\") {\n  \t\t\treturn element;\n  \t\t}\n  \t} while (element = element.parent);\n  }\n\n  var Element_prototype_init = Element$init;\n  function Element$init(options) {\n  \tvar parentFragment, template, ractive, binding, bindings, twoway, bindingAttrs;\n\n  \tthis.type = ELEMENT;\n\n  \t// stuff we'll need later\n  \tparentFragment = this.parentFragment = options.parentFragment;\n  \ttemplate = this.template = options.template;\n\n  \tthis.parent = options.pElement || parentFragment.pElement;\n\n  \tthis.root = ractive = parentFragment.root;\n  \tthis.index = options.index;\n  \tthis.key = options.key;\n\n  \tthis.name = enforceCase(template.e);\n\n  \t// Special case - <option> elements\n  \tif (this.name === \"option\") {\n  \t\tspecial_option__init(this, template);\n  \t}\n\n  \t// Special case - <select> elements\n  \tif (this.name === \"select\") {\n  \t\tthis.options = [];\n  \t\tthis.bubble = select__bubble; // TODO this is a kludge\n  \t}\n\n  \t// Special case - <form> elements\n  \tif (this.name === \"form\") {\n  \t\tthis.formBindings = [];\n  \t}\n\n  \t// handle binding attributes first (twoway, lazy)\n  \tbindingAttrs = processBindingAttributes(this, template);\n\n  \t// create attributes\n  \tthis.attributes = createAttributes(this, template.a);\n  \tthis.conditionalAttributes = createConditionalAttributes(this, template.m);\n\n  \t// append children, if there are any\n  \tif (template.f) {\n  \t\tthis.fragment = new virtualdom_Fragment({\n  \t\t\ttemplate: template.f,\n  \t\t\troot: ractive,\n  \t\t\towner: this,\n  \t\t\tpElement: this,\n  \t\t\tcssIds: null\n  \t\t});\n  \t}\n\n  \t// the element setting should override the ractive setting\n  \ttwoway = ractive.twoway;\n  \tif (bindingAttrs.twoway === false) twoway = false;else if (bindingAttrs.twoway === true) twoway = true;\n\n  \tthis.twoway = twoway;\n  \tthis.lazy = bindingAttrs.lazy;\n\n  \t// create twoway binding\n  \tif (twoway && (binding = init_createTwowayBinding(this, template.a))) {\n  \t\tthis.binding = binding;\n\n  \t\t// register this with the root, so that we can do ractive.updateModel()\n  \t\tbindings = this.root._twowayBindings[binding.keypath.str] || (this.root._twowayBindings[binding.keypath.str] = []);\n  \t\tbindings.push(binding);\n  \t}\n\n  \t// create event proxies\n  \tif (template.v) {\n  \t\tthis.eventHandlers = createEventHandlers(this, template.v);\n  \t}\n\n  \t// create decorator\n  \tif (template.o) {\n  \t\tthis.decorator = new _Decorator(this, template.o);\n  \t}\n\n  \t// create transitions\n  \tthis.intro = template.t0 || template.t1;\n  \tthis.outro = template.t0 || template.t2;\n  }\n\n  var Element_prototype_rebind = Element$rebind;\n  function Element$rebind(oldKeypath, newKeypath) {\n  \tvar i, storage, liveQueries, ractive;\n\n  \tif (this.attributes) {\n  \t\tthis.attributes.forEach(rebind);\n  \t}\n\n  \tif (this.conditionalAttributes) {\n  \t\tthis.conditionalAttributes.forEach(rebind);\n  \t}\n\n  \tif (this.eventHandlers) {\n  \t\tthis.eventHandlers.forEach(rebind);\n  \t}\n\n  \tif (this.decorator) {\n  \t\trebind(this.decorator);\n  \t}\n\n  \t// rebind children\n  \tif (this.fragment) {\n  \t\trebind(this.fragment);\n  \t}\n\n  \t// Update live queries, if necessary\n  \tif (liveQueries = this.liveQueries) {\n  \t\tractive = this.root;\n\n  \t\ti = liveQueries.length;\n  \t\twhile (i--) {\n  \t\t\tliveQueries[i]._makeDirty();\n  \t\t}\n  \t}\n\n  \tif (this.node && (storage = this.node._ractive)) {\n\n  \t\t// adjust keypath if needed\n  \t\tassignNewKeypath(storage, \"keypath\", oldKeypath, newKeypath);\n  \t}\n\n  \tfunction rebind(thing) {\n  \t\tthing.rebind(oldKeypath, newKeypath);\n  \t}\n  }\n\n  function special_img__render(img) {\n  \tvar loadHandler;\n\n  \t// if this is an <img>, and we're in a crap browser, we may need to prevent it\n  \t// from overriding width and height when it loads the src\n  \tif (img.attributes.width || img.attributes.height) {\n  \t\timg.node.addEventListener(\"load\", loadHandler = function () {\n  \t\t\tvar width = img.getAttribute(\"width\"),\n  \t\t\t    height = img.getAttribute(\"height\");\n\n  \t\t\tif (width !== undefined) {\n  \t\t\t\timg.node.setAttribute(\"width\", width);\n  \t\t\t}\n\n  \t\t\tif (height !== undefined) {\n  \t\t\t\timg.node.setAttribute(\"height\", height);\n  \t\t\t}\n\n  \t\t\timg.node.removeEventListener(\"load\", loadHandler, false);\n  \t\t}, false);\n  \t}\n  }\n\n  function form__render(element) {\n  \telement.node.addEventListener(\"reset\", handleReset, false);\n  }\n\n  function form__unrender(element) {\n  \telement.node.removeEventListener(\"reset\", handleReset, false);\n  }\n\n  function handleReset() {\n  \tvar element = this._ractive.proxy;\n\n  \tglobal_runloop.start();\n  \telement.formBindings.forEach(updateModel);\n  \tglobal_runloop.end();\n  }\n\n  function updateModel(binding) {\n  \tbinding.root.viewmodel.set(binding.keypath, binding.resetValue);\n  }\n\n  var Transition_prototype_init = Transition$init;\n  function Transition$init(element, template, isIntro) {\n  \tvar ractive, name, fragment;\n\n  \tthis.element = element;\n  \tthis.root = ractive = element.root;\n  \tthis.isIntro = isIntro;\n\n  \tname = template.n || template;\n\n  \tif (typeof name !== \"string\") {\n  \t\tfragment = new virtualdom_Fragment({\n  \t\t\ttemplate: name,\n  \t\t\troot: ractive,\n  \t\t\towner: element\n  \t\t});\n\n  \t\tname = fragment.toString();\n  \t\tfragment.unbind();\n\n  \t\tif (name === \"\") {\n  \t\t\t// empty string okay, just no transition\n  \t\t\treturn;\n  \t\t}\n  \t}\n\n  \tthis.name = name;\n\n  \tif (template.a) {\n  \t\tthis.params = template.a;\n  \t} else if (template.d) {\n  \t\t// TODO is there a way to interpret dynamic arguments without all the\n  \t\t// 'dependency thrashing'?\n  \t\tfragment = new virtualdom_Fragment({\n  \t\t\ttemplate: template.d,\n  \t\t\troot: ractive,\n  \t\t\towner: element\n  \t\t});\n\n  \t\tthis.params = fragment.getArgsList();\n  \t\tfragment.unbind();\n  \t}\n\n  \tthis._fn = findInViewHierarchy(\"transitions\", ractive, name);\n\n  \tif (!this._fn) {\n  \t\twarnOnceIfDebug(missingPlugin(name, \"transition\"), { ractive: this.root });\n  \t}\n  }\n\n  var camelCase = function (hyphenatedStr) {\n  \treturn hyphenatedStr.replace(/-([a-zA-Z])/g, function (match, $1) {\n  \t\treturn $1.toUpperCase();\n  \t});\n  };\n\n  var helpers_prefix__prefix, prefixCache, helpers_prefix__testStyle;\n\n  if (!isClient) {\n  \thelpers_prefix__prefix = null;\n  } else {\n  \tprefixCache = {};\n  \thelpers_prefix__testStyle = createElement(\"div\").style;\n\n  \thelpers_prefix__prefix = function (prop) {\n  \t\tvar i, vendor, capped;\n\n  \t\tprop = camelCase(prop);\n\n  \t\tif (!prefixCache[prop]) {\n  \t\t\tif (helpers_prefix__testStyle[prop] !== undefined) {\n  \t\t\t\tprefixCache[prop] = prop;\n  \t\t\t} else {\n  \t\t\t\t// test vendors...\n  \t\t\t\tcapped = prop.charAt(0).toUpperCase() + prop.substring(1);\n\n  \t\t\t\ti = vendors.length;\n  \t\t\t\twhile (i--) {\n  \t\t\t\t\tvendor = vendors[i];\n  \t\t\t\t\tif (helpers_prefix__testStyle[vendor + capped] !== undefined) {\n  \t\t\t\t\t\tprefixCache[prop] = vendor + capped;\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\treturn prefixCache[prop];\n  \t};\n  }\n\n  var helpers_prefix = helpers_prefix__prefix;\n\n  var getStyle, prototype_getStyle__getComputedStyle;\n\n  if (!isClient) {\n  \tgetStyle = null;\n  } else {\n  \tprototype_getStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n  \tgetStyle = function (props) {\n  \t\tvar computedStyle, styles, i, prop, value;\n\n  \t\tcomputedStyle = prototype_getStyle__getComputedStyle(this.node);\n\n  \t\tif (typeof props === \"string\") {\n  \t\t\tvalue = computedStyle[helpers_prefix(props)];\n  \t\t\tif (value === \"0px\") {\n  \t\t\t\tvalue = 0;\n  \t\t\t}\n  \t\t\treturn value;\n  \t\t}\n\n  \t\tif (!isArray(props)) {\n  \t\t\tthrow new Error(\"Transition$getStyle must be passed a string, or an array of strings representing CSS properties\");\n  \t\t}\n\n  \t\tstyles = {};\n\n  \t\ti = props.length;\n  \t\twhile (i--) {\n  \t\t\tprop = props[i];\n  \t\t\tvalue = computedStyle[helpers_prefix(prop)];\n  \t\t\tif (value === \"0px\") {\n  \t\t\t\tvalue = 0;\n  \t\t\t}\n  \t\t\tstyles[prop] = value;\n  \t\t}\n\n  \t\treturn styles;\n  \t};\n  }\n\n  var prototype_getStyle = getStyle;\n\n  var setStyle = function (style, value) {\n  \tvar prop;\n\n  \tif (typeof style === \"string\") {\n  \t\tthis.node.style[helpers_prefix(style)] = value;\n  \t} else {\n  \t\tfor (prop in style) {\n  \t\t\tif (style.hasOwnProperty(prop)) {\n  \t\t\t\tthis.node.style[helpers_prefix(prop)] = style[prop];\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn this;\n  };\n\n  var Ticker = function (options) {\n  \tvar easing;\n\n  \tthis.duration = options.duration;\n  \tthis.step = options.step;\n  \tthis.complete = options.complete;\n\n  \t// easing\n  \tif (typeof options.easing === \"string\") {\n  \t\teasing = options.root.easing[options.easing];\n\n  \t\tif (!easing) {\n  \t\t\twarnOnceIfDebug(missingPlugin(options.easing, \"easing\"));\n  \t\t\teasing = linear;\n  \t\t}\n  \t} else if (typeof options.easing === \"function\") {\n  \t\teasing = options.easing;\n  \t} else {\n  \t\teasing = linear;\n  \t}\n\n  \tthis.easing = easing;\n\n  \tthis.start = utils_getTime();\n  \tthis.end = this.start + this.duration;\n\n  \tthis.running = true;\n  \tshared_animations.add(this);\n  };\n\n  Ticker.prototype = {\n  \ttick: function (now) {\n  \t\tvar elapsed, eased;\n\n  \t\tif (!this.running) {\n  \t\t\treturn false;\n  \t\t}\n\n  \t\tif (now > this.end) {\n  \t\t\tif (this.step) {\n  \t\t\t\tthis.step(1);\n  \t\t\t}\n\n  \t\t\tif (this.complete) {\n  \t\t\t\tthis.complete(1);\n  \t\t\t}\n\n  \t\t\treturn false;\n  \t\t}\n\n  \t\telapsed = now - this.start;\n  \t\teased = this.easing(elapsed / this.duration);\n\n  \t\tif (this.step) {\n  \t\t\tthis.step(eased);\n  \t\t}\n\n  \t\treturn true;\n  \t},\n\n  \tstop: function () {\n  \t\tif (this.abort) {\n  \t\t\tthis.abort();\n  \t\t}\n\n  \t\tthis.running = false;\n  \t}\n  };\n\n  var shared_Ticker = Ticker;\n  function linear(t) {\n  \treturn t;\n  }\n\n  var unprefixPattern = new RegExp(\"^-(?:\" + vendors.join(\"|\") + \")-\");\n\n  var unprefix = function (prop) {\n  \treturn prop.replace(unprefixPattern, \"\");\n  };\n\n  var vendorPattern = new RegExp(\"^(?:\" + vendors.join(\"|\") + \")([A-Z])\");\n\n  var hyphenate = function (str) {\n  \tvar hyphenated;\n\n  \tif (!str) {\n  \t\treturn \"\"; // edge case\n  \t}\n\n  \tif (vendorPattern.test(str)) {\n  \t\tstr = \"-\" + str;\n  \t}\n\n  \thyphenated = str.replace(/[A-Z]/g, function (match) {\n  \t\treturn \"-\" + match.toLowerCase();\n  \t});\n\n  \treturn hyphenated;\n  };\n\n  var createTransitions,\n      animateStyle_createTransitions__testStyle,\n      TRANSITION,\n      TRANSITIONEND,\n      CSS_TRANSITIONS_ENABLED,\n      TRANSITION_DURATION,\n      TRANSITION_PROPERTY,\n      TRANSITION_TIMING_FUNCTION,\n      canUseCssTransitions = {},\n      cannotUseCssTransitions = {};\n\n  if (!isClient) {\n  \tcreateTransitions = null;\n  } else {\n  \tanimateStyle_createTransitions__testStyle = createElement(\"div\").style;\n\n  \t// determine some facts about our environment\n  \t(function () {\n  \t\tif (animateStyle_createTransitions__testStyle.transition !== undefined) {\n  \t\t\tTRANSITION = \"transition\";\n  \t\t\tTRANSITIONEND = \"transitionend\";\n  \t\t\tCSS_TRANSITIONS_ENABLED = true;\n  \t\t} else if (animateStyle_createTransitions__testStyle.webkitTransition !== undefined) {\n  \t\t\tTRANSITION = \"webkitTransition\";\n  \t\t\tTRANSITIONEND = \"webkitTransitionEnd\";\n  \t\t\tCSS_TRANSITIONS_ENABLED = true;\n  \t\t} else {\n  \t\t\tCSS_TRANSITIONS_ENABLED = false;\n  \t\t}\n  \t})();\n\n  \tif (TRANSITION) {\n  \t\tTRANSITION_DURATION = TRANSITION + \"Duration\";\n  \t\tTRANSITION_PROPERTY = TRANSITION + \"Property\";\n  \t\tTRANSITION_TIMING_FUNCTION = TRANSITION + \"TimingFunction\";\n  \t}\n\n  \tcreateTransitions = function (t, to, options, changedProperties, resolve) {\n\n  \t\t// Wait a beat (otherwise the target styles will be applied immediately)\n  \t\t// TODO use a fastdom-style mechanism?\n  \t\tsetTimeout(function () {\n\n  \t\t\tvar hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;\n\n  \t\t\tcheckComplete = function () {\n  \t\t\t\tif (jsTransitionsComplete && cssTransitionsComplete) {\n  \t\t\t\t\t// will changes to events and fire have an unexpected consequence here?\n  \t\t\t\t\tt.root.fire(t.name + \":end\", t.node, t.isIntro);\n  \t\t\t\t\tresolve();\n  \t\t\t\t}\n  \t\t\t};\n\n  \t\t\t// this is used to keep track of which elements can use CSS to animate\n  \t\t\t// which properties\n  \t\t\thashPrefix = (t.node.namespaceURI || \"\") + t.node.tagName;\n\n  \t\t\tt.node.style[TRANSITION_PROPERTY] = changedProperties.map(helpers_prefix).map(hyphenate).join(\",\");\n  \t\t\tt.node.style[TRANSITION_TIMING_FUNCTION] = hyphenate(options.easing || \"linear\");\n  \t\t\tt.node.style[TRANSITION_DURATION] = options.duration / 1000 + \"s\";\n\n  \t\t\ttransitionEndHandler = function (event) {\n  \t\t\t\tvar index;\n\n  \t\t\t\tindex = changedProperties.indexOf(camelCase(unprefix(event.propertyName)));\n  \t\t\t\tif (index !== -1) {\n  \t\t\t\t\tchangedProperties.splice(index, 1);\n  \t\t\t\t}\n\n  \t\t\t\tif (changedProperties.length) {\n  \t\t\t\t\t// still transitioning...\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tt.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n  \t\t\t\tcssTransitionsComplete = true;\n  \t\t\t\tcheckComplete();\n  \t\t\t};\n\n  \t\t\tt.node.addEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n  \t\t\tsetTimeout(function () {\n  \t\t\t\tvar i = changedProperties.length,\n  \t\t\t\t    hash,\n  \t\t\t\t    originalValue,\n  \t\t\t\t    index,\n  \t\t\t\t    propertiesToTransitionInJs = [],\n  \t\t\t\t    prop,\n  \t\t\t\t    suffix;\n\n  \t\t\t\twhile (i--) {\n  \t\t\t\t\tprop = changedProperties[i];\n  \t\t\t\t\thash = hashPrefix + prop;\n\n  \t\t\t\t\tif (CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {\n  \t\t\t\t\t\tt.node.style[helpers_prefix(prop)] = to[prop];\n\n  \t\t\t\t\t\t// If we're not sure if CSS transitions are supported for\n  \t\t\t\t\t\t// this tag/property combo, find out now\n  \t\t\t\t\t\tif (!canUseCssTransitions[hash]) {\n  \t\t\t\t\t\t\toriginalValue = t.getStyle(prop);\n\n  \t\t\t\t\t\t\t// if this property is transitionable in this browser,\n  \t\t\t\t\t\t\t// the current style will be different from the target style\n  \t\t\t\t\t\t\tcanUseCssTransitions[hash] = t.getStyle(prop) != to[prop];\n  \t\t\t\t\t\t\tcannotUseCssTransitions[hash] = !canUseCssTransitions[hash];\n\n  \t\t\t\t\t\t\t// Reset, if we're going to use timers after all\n  \t\t\t\t\t\t\tif (cannotUseCssTransitions[hash]) {\n  \t\t\t\t\t\t\t\tt.node.style[helpers_prefix(prop)] = originalValue;\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n\n  \t\t\t\t\tif (!CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {\n  \t\t\t\t\t\t// we need to fall back to timer-based stuff\n  \t\t\t\t\t\tif (originalValue === undefined) {\n  \t\t\t\t\t\t\toriginalValue = t.getStyle(prop);\n  \t\t\t\t\t\t}\n\n  \t\t\t\t\t\t// need to remove this from changedProperties, otherwise transitionEndHandler\n  \t\t\t\t\t\t// will get confused\n  \t\t\t\t\t\tindex = changedProperties.indexOf(prop);\n  \t\t\t\t\t\tif (index === -1) {\n  \t\t\t\t\t\t\twarnIfDebug(\"Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!\", { node: t.node });\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\tchangedProperties.splice(index, 1);\n  \t\t\t\t\t\t}\n\n  \t\t\t\t\t\t// TODO Determine whether this property is animatable at all\n\n  \t\t\t\t\t\tsuffix = /[^\\d]*$/.exec(to[prop])[0];\n\n  \t\t\t\t\t\t// ...then kick off a timer-based transition\n  \t\t\t\t\t\tpropertiesToTransitionInJs.push({\n  \t\t\t\t\t\t\tname: helpers_prefix(prop),\n  \t\t\t\t\t\t\tinterpolator: shared_interpolate(parseFloat(originalValue), parseFloat(to[prop])),\n  \t\t\t\t\t\t\tsuffix: suffix\n  \t\t\t\t\t\t});\n  \t\t\t\t\t}\n  \t\t\t\t}\n\n  \t\t\t\t// javascript transitions\n  \t\t\t\tif (propertiesToTransitionInJs.length) {\n  \t\t\t\t\tnew shared_Ticker({\n  \t\t\t\t\t\troot: t.root,\n  \t\t\t\t\t\tduration: options.duration,\n  \t\t\t\t\t\teasing: camelCase(options.easing || \"\"),\n  \t\t\t\t\t\tstep: function (pos) {\n  \t\t\t\t\t\t\tvar prop, i;\n\n  \t\t\t\t\t\t\ti = propertiesToTransitionInJs.length;\n  \t\t\t\t\t\t\twhile (i--) {\n  \t\t\t\t\t\t\t\tprop = propertiesToTransitionInJs[i];\n  \t\t\t\t\t\t\t\tt.node.style[prop.name] = prop.interpolator(pos) + prop.suffix;\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t},\n  \t\t\t\t\t\tcomplete: function () {\n  \t\t\t\t\t\t\tjsTransitionsComplete = true;\n  \t\t\t\t\t\t\tcheckComplete();\n  \t\t\t\t\t\t}\n  \t\t\t\t\t});\n  \t\t\t\t} else {\n  \t\t\t\t\tjsTransitionsComplete = true;\n  \t\t\t\t}\n\n  \t\t\t\tif (!changedProperties.length) {\n  \t\t\t\t\t// We need to cancel the transitionEndHandler, and deal with\n  \t\t\t\t\t// the fact that it will never fire\n  \t\t\t\t\tt.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n  \t\t\t\t\tcssTransitionsComplete = true;\n  \t\t\t\t\tcheckComplete();\n  \t\t\t\t}\n  \t\t\t}, 0);\n  \t\t}, options.delay || 0);\n  \t};\n  }\n\n  var animateStyle_createTransitions = createTransitions;\n\n  var hidden, vendor, animateStyle_visibility__prefix, animateStyle_visibility__i, visibility;\n\n  if (typeof document !== \"undefined\") {\n  \thidden = \"hidden\";\n\n  \tvisibility = {};\n\n  \tif (hidden in document) {\n  \t\tanimateStyle_visibility__prefix = \"\";\n  \t} else {\n  \t\tanimateStyle_visibility__i = vendors.length;\n  \t\twhile (animateStyle_visibility__i--) {\n  \t\t\tvendor = vendors[animateStyle_visibility__i];\n  \t\t\thidden = vendor + \"Hidden\";\n\n  \t\t\tif (hidden in document) {\n  \t\t\t\tanimateStyle_visibility__prefix = vendor;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tif (animateStyle_visibility__prefix !== undefined) {\n  \t\tdocument.addEventListener(animateStyle_visibility__prefix + \"visibilitychange\", onChange);\n\n  \t\t// initialise\n  \t\tonChange();\n  \t} else {\n  \t\t// gah, we're in an old browser\n  \t\tif (\"onfocusout\" in document) {\n  \t\t\tdocument.addEventListener(\"focusout\", onHide);\n  \t\t\tdocument.addEventListener(\"focusin\", onShow);\n  \t\t} else {\n  \t\t\twindow.addEventListener(\"pagehide\", onHide);\n  \t\t\twindow.addEventListener(\"blur\", onHide);\n\n  \t\t\twindow.addEventListener(\"pageshow\", onShow);\n  \t\t\twindow.addEventListener(\"focus\", onShow);\n  \t\t}\n\n  \t\tvisibility.hidden = false; // until proven otherwise. Not ideal but hey\n  \t}\n  }\n\n  function onChange() {\n  \tvisibility.hidden = document[hidden];\n  }\n\n  function onHide() {\n  \tvisibility.hidden = true;\n  }\n\n  function onShow() {\n  \tvisibility.hidden = false;\n  }\n\n  var animateStyle_visibility = visibility;\n\n  var animateStyle, _animateStyle__getComputedStyle, resolved;\n\n  if (!isClient) {\n  \tanimateStyle = null;\n  } else {\n  \t_animateStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n  \tanimateStyle = function (style, value, options) {\n  \t\tvar _this = this;\n\n  \t\tvar to;\n\n  \t\tif (arguments.length === 4) {\n  \t\t\tthrow new Error(\"t.animateStyle() returns a promise - use .then() instead of passing a callback\");\n  \t\t}\n\n  \t\t// Special case - page isn't visible. Don't animate anything, because\n  \t\t// that way you'll never get CSS transitionend events\n  \t\tif (animateStyle_visibility.hidden) {\n  \t\t\tthis.setStyle(style, value);\n  \t\t\treturn resolved || (resolved = utils_Promise.resolve());\n  \t\t}\n\n  \t\tif (typeof style === \"string\") {\n  \t\t\tto = {};\n  \t\t\tto[style] = value;\n  \t\t} else {\n  \t\t\tto = style;\n\n  \t\t\t// shuffle arguments\n  \t\t\toptions = value;\n  \t\t}\n\n  \t\t// As of 0.3.9, transition authors should supply an `option` object with\n  \t\t// `duration` and `easing` properties (and optional `delay`), plus a\n  \t\t// callback function that gets called after the animation completes\n\n  \t\t// TODO remove this check in a future version\n  \t\tif (!options) {\n  \t\t\twarnOnceIfDebug(\"The \\\"%s\\\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340\", this.name);\n  \t\t\toptions = this;\n  \t\t}\n\n  \t\tvar promise = new utils_Promise(function (resolve) {\n  \t\t\tvar propertyNames, changedProperties, computedStyle, current, from, i, prop;\n\n  \t\t\t// Edge case - if duration is zero, set style synchronously and complete\n  \t\t\tif (!options.duration) {\n  \t\t\t\t_this.setStyle(to);\n  \t\t\t\tresolve();\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\t// Get a list of the properties we're animating\n  \t\t\tpropertyNames = Object.keys(to);\n  \t\t\tchangedProperties = [];\n\n  \t\t\t// Store the current styles\n  \t\t\tcomputedStyle = _animateStyle__getComputedStyle(_this.node);\n\n  \t\t\tfrom = {};\n  \t\t\ti = propertyNames.length;\n  \t\t\twhile (i--) {\n  \t\t\t\tprop = propertyNames[i];\n  \t\t\t\tcurrent = computedStyle[helpers_prefix(prop)];\n\n  \t\t\t\tif (current === \"0px\") {\n  \t\t\t\t\tcurrent = 0;\n  \t\t\t\t}\n\n  \t\t\t\t// we need to know if we're actually changing anything\n  \t\t\t\tif (current != to[prop]) {\n  \t\t\t\t\t// use != instead of !==, so we can compare strings with numbers\n  \t\t\t\t\tchangedProperties.push(prop);\n\n  \t\t\t\t\t// make the computed style explicit, so we can animate where\n  \t\t\t\t\t// e.g. height='auto'\n  \t\t\t\t\t_this.node.style[helpers_prefix(prop)] = current;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\t// If we're not actually changing anything, the transitionend event\n  \t\t\t// will never fire! So we complete early\n  \t\t\tif (!changedProperties.length) {\n  \t\t\t\tresolve();\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tanimateStyle_createTransitions(_this, to, options, changedProperties, resolve);\n  \t\t});\n\n  \t\treturn promise;\n  \t};\n  }\n\n  var _animateStyle = animateStyle;\n\n  var processParams = function (params, defaults) {\n  \tif (typeof params === \"number\") {\n  \t\tparams = { duration: params };\n  \t} else if (typeof params === \"string\") {\n  \t\tif (params === \"slow\") {\n  \t\t\tparams = { duration: 600 };\n  \t\t} else if (params === \"fast\") {\n  \t\t\tparams = { duration: 200 };\n  \t\t} else {\n  \t\t\tparams = { duration: 400 };\n  \t\t}\n  \t} else if (!params) {\n  \t\tparams = {};\n  \t}\n\n  \treturn fillGaps({}, params, defaults);\n  };\n\n  var prototype_start = Transition$start;\n\n  function Transition$start() {\n  \tvar _this = this;\n\n  \tvar node, originalStyle, completed;\n\n  \tnode = this.node = this.element.node;\n  \toriginalStyle = node.getAttribute(\"style\");\n\n  \t// create t.complete() - we don't want this on the prototype,\n  \t// because we don't want `this` silliness when passing it as\n  \t// an argument\n  \tthis.complete = function (noReset) {\n  \t\tif (completed) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (!noReset && _this.isIntro) {\n  \t\t\tresetStyle(node, originalStyle);\n  \t\t}\n\n  \t\tnode._ractive.transition = null;\n  \t\t_this._manager.remove(_this);\n\n  \t\tcompleted = true;\n  \t};\n\n  \t// If the transition function doesn't exist, abort\n  \tif (!this._fn) {\n  \t\tthis.complete();\n  \t\treturn;\n  \t}\n\n  \tthis._fn.apply(this.root, [this].concat(this.params));\n  }\n\n  function resetStyle(node, style) {\n  \tif (style) {\n  \t\tnode.setAttribute(\"style\", style);\n  \t} else {\n\n  \t\t// Next line is necessary, to remove empty style attribute!\n  \t\t// See http://stackoverflow.com/a/7167553\n  \t\tnode.getAttribute(\"style\");\n  \t\tnode.removeAttribute(\"style\");\n  \t}\n  }\n\n  var Transition = function (owner, template, isIntro) {\n  \tthis.init(owner, template, isIntro);\n  };\n\n  Transition.prototype = {\n  \tinit: Transition_prototype_init,\n  \tstart: prototype_start,\n  \tgetStyle: prototype_getStyle,\n  \tsetStyle: setStyle,\n  \tanimateStyle: _animateStyle,\n  \tprocessParams: processParams\n  };\n\n  var _Transition = Transition;\n\n  var Element_prototype_render = Element$render;\n\n  var updateCss, updateScript;\n\n  updateCss = function () {\n  \tvar node = this.node,\n  \t    content = this.fragment.toString(false);\n\n  \t// IE8 has no styleSheet unless there's a type text/css\n  \tif (window && window.appearsToBeIELessEqual8) {\n  \t\tnode.type = \"text/css\";\n  \t}\n\n  \tif (node.styleSheet) {\n  \t\tnode.styleSheet.cssText = content;\n  \t} else {\n\n  \t\twhile (node.hasChildNodes()) {\n  \t\t\tnode.removeChild(node.firstChild);\n  \t\t}\n\n  \t\tnode.appendChild(document.createTextNode(content));\n  \t}\n  };\n\n  updateScript = function () {\n  \tif (!this.node.type || this.node.type === \"text/javascript\") {\n  \t\twarnIfDebug(\"Script tag was updated. This does not cause the code to be re-evaluated!\", { ractive: this.root });\n  \t\t// As it happens, we ARE in a position to re-evaluate the code if we wanted\n  \t\t// to - we could eval() it, or insert it into a fresh (temporary) script tag.\n  \t\t// But this would be a terrible idea with unpredictable results, so let's not.\n  \t}\n\n  \tthis.node.text = this.fragment.toString(false);\n  };\n  function Element$render() {\n  \tvar _this = this;\n\n  \tvar root = this.root,\n  \t    namespace,\n  \t    node,\n  \t    transition;\n\n  \tnamespace = getNamespace(this);\n  \tnode = this.node = createElement(this.name, namespace);\n\n  \t// Is this a top-level node of a component? If so, we may need to add\n  \t// a data-ractive-css attribute, for CSS encapsulation\n  \tif (this.parentFragment.cssIds) {\n  \t\tthis.node.setAttribute(\"data-ractive-css\", this.parentFragment.cssIds.map(function (x) {\n  \t\t\treturn \"{\" + x + \"}\";\n  \t\t}).join(\" \"));\n  \t}\n\n  \t// Add _ractive property to the node - we use this object to store stuff\n  \t// related to proxy events, two-way bindings etc\n  \tdefineProperty(this.node, \"_ractive\", {\n  \t\tvalue: {\n  \t\t\tproxy: this,\n  \t\t\tkeypath: getInnerContext(this.parentFragment),\n  \t\t\tevents: create(null),\n  \t\t\troot: root\n  \t\t}\n  \t});\n\n  \t// Render attributes\n  \tthis.attributes.forEach(function (a) {\n  \t\treturn a.render(node);\n  \t});\n  \tthis.conditionalAttributes.forEach(function (a) {\n  \t\treturn a.render(node);\n  \t});\n\n  \t// Render children\n  \tif (this.fragment) {\n  \t\t// Special case - <script> element\n  \t\tif (this.name === \"script\") {\n  \t\t\tthis.bubble = updateScript;\n  \t\t\tthis.node.text = this.fragment.toString(false); // bypass warning initially\n  \t\t\tthis.fragment.unrender = noop; // TODO this is a kludge\n  \t\t}\n\n  \t\t// Special case - <style> element\n  \t\telse if (this.name === \"style\") {\n  \t\t\tthis.bubble = updateCss;\n  \t\t\tthis.bubble();\n  \t\t\tthis.fragment.unrender = noop;\n  \t\t}\n\n  \t\t// Special case - contenteditable\n  \t\telse if (this.binding && this.getAttribute(\"contenteditable\")) {\n  \t\t\tthis.fragment.unrender = noop;\n  \t\t} else {\n  \t\t\tthis.node.appendChild(this.fragment.render());\n  \t\t}\n  \t}\n\n  \t// deal with two-way bindings\n  \tif (this.binding) {\n  \t\tthis.binding.render();\n  \t\tthis.node._ractive.binding = this.binding;\n  \t}\n\n  \t// Add proxy event handlers\n  \tif (this.eventHandlers) {\n  \t\tthis.eventHandlers.forEach(function (h) {\n  \t\t\treturn h.render();\n  \t\t});\n  \t}\n\n  \tif (this.name === \"option\") {\n  \t\tprocessOption(this);\n  \t}\n\n  \t// Special cases\n  \tif (this.name === \"img\") {\n  \t\t// if this is an <img>, and we're in a crap browser, we may\n  \t\t// need to prevent it from overriding width and height when\n  \t\t// it loads the src\n  \t\tspecial_img__render(this);\n  \t} else if (this.name === \"form\") {\n  \t\t// forms need to keep track of their bindings, in case of reset\n  \t\tform__render(this);\n  \t} else if (this.name === \"input\" || this.name === \"textarea\") {\n  \t\t// inputs and textareas should store their initial value as\n  \t\t// `defaultValue` in case of reset\n  \t\tthis.node.defaultValue = this.node.value;\n  \t} else if (this.name === \"option\") {\n  \t\t// similarly for option nodes\n  \t\tthis.node.defaultSelected = this.node.selected;\n  \t}\n\n  \t// apply decorator(s)\n  \tif (this.decorator && this.decorator.fn) {\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\tif (!_this.decorator.torndown) {\n  \t\t\t\t_this.decorator.init();\n  \t\t\t}\n  \t\t}, true);\n  \t}\n\n  \t// trigger intro transition\n  \tif (root.transitionsEnabled && this.intro) {\n  \t\ttransition = new _Transition(this, this.intro, true);\n  \t\tglobal_runloop.registerTransition(transition);\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\treturn transition.start();\n  \t\t}, true);\n\n  \t\tthis.transition = transition;\n  \t}\n\n  \tif (this.node.autofocus) {\n  \t\t// Special case. Some browsers (*cough* Firefix *cough*) have a problem\n  \t\t// with dynamically-generated elements having autofocus, and they won't\n  \t\t// allow you to programmatically focus the element until it's in the DOM\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\treturn _this.node.focus();\n  \t\t}, true);\n  \t}\n\n  \tupdateLiveQueries(this);\n  \treturn this.node;\n  }\n\n  function getNamespace(element) {\n  \tvar namespace, xmlns, parent;\n\n  \t// Use specified namespace...\n  \tif (xmlns = element.getAttribute(\"xmlns\")) {\n  \t\tnamespace = xmlns;\n  \t}\n\n  \t// ...or SVG namespace, if this is an <svg> element\n  \telse if (element.name === \"svg\") {\n  \t\tnamespace = namespaces.svg;\n  \t} else if (parent = element.parent) {\n  \t\t// ...or HTML, if the parent is a <foreignObject>\n  \t\tif (parent.name === \"foreignObject\") {\n  \t\t\tnamespace = namespaces.html;\n  \t\t}\n\n  \t\t// ...or inherit from the parent node\n  \t\telse {\n  \t\t\tnamespace = parent.node.namespaceURI;\n  \t\t}\n  \t} else {\n  \t\tnamespace = element.root.el.namespaceURI;\n  \t}\n\n  \treturn namespace;\n  }\n\n  function processOption(option) {\n  \tvar optionValue, selectValue, i;\n\n  \tif (!option.select) {\n  \t\treturn;\n  \t}\n\n  \tselectValue = option.select.getAttribute(\"value\");\n  \tif (selectValue === undefined) {\n  \t\treturn;\n  \t}\n\n  \toptionValue = option.getAttribute(\"value\");\n\n  \tif (option.select.node.multiple && isArray(selectValue)) {\n  \t\ti = selectValue.length;\n  \t\twhile (i--) {\n  \t\t\tif (optionValue == selectValue[i]) {\n  \t\t\t\toption.node.selected = true;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t} else {\n  \t\toption.node.selected = optionValue == selectValue;\n  \t}\n  }\n\n  function updateLiveQueries(element) {\n  \tvar instance, liveQueries, i, selector, query;\n\n  \t// Does this need to be added to any live queries?\n  \tinstance = element.root;\n\n  \tdo {\n  \t\tliveQueries = instance._liveQueries;\n\n  \t\ti = liveQueries.length;\n  \t\twhile (i--) {\n  \t\t\tselector = liveQueries[i];\n  \t\t\tquery = liveQueries[\"_\" + selector];\n\n  \t\t\tif (query._test(element)) {\n  \t\t\t\t// keep register of applicable selectors, for when we teardown\n  \t\t\t\t(element.liveQueries || (element.liveQueries = [])).push(query);\n  \t\t\t}\n  \t\t}\n  \t} while (instance = instance.parent);\n  }\n\n  var Element_prototype_toString = function () {\n  \tvar str, escape;\n\n  \tif (this.template.y) {\n  \t\t// DOCTYPE declaration\n  \t\treturn \"<!DOCTYPE\" + this.template.dd + \">\";\n  \t}\n\n  \tstr = \"<\" + this.template.e;\n\n  \tstr += this.attributes.map(stringifyAttribute).join(\"\") + this.conditionalAttributes.map(stringifyAttribute).join(\"\");\n\n  \t// Special case - selected options\n  \tif (this.name === \"option\" && optionIsSelected(this)) {\n  \t\tstr += \" selected\";\n  \t}\n\n  \t// Special case - two-way radio name bindings\n  \tif (this.name === \"input\" && inputIsCheckedRadio(this)) {\n  \t\tstr += \" checked\";\n  \t}\n\n  \tstr += \">\";\n\n  \t// Special case - textarea\n  \tif (this.name === \"textarea\" && this.getAttribute(\"value\") !== undefined) {\n  \t\tstr += escapeHtml(this.getAttribute(\"value\"));\n  \t}\n\n  \t// Special case - contenteditable\n  \telse if (this.getAttribute(\"contenteditable\") !== undefined) {\n  \t\tstr += this.getAttribute(\"value\") || \"\";\n  \t}\n\n  \tif (this.fragment) {\n  \t\tescape = this.name !== \"script\" && this.name !== \"style\";\n  \t\tstr += this.fragment.toString(escape);\n  \t}\n\n  \t// add a closing tag if this isn't a void element\n  \tif (!voidElementNames.test(this.template.e)) {\n  \t\tstr += \"</\" + this.template.e + \">\";\n  \t}\n\n  \treturn str;\n  };\n\n  function optionIsSelected(element) {\n  \tvar optionValue, selectValue, i;\n\n  \toptionValue = element.getAttribute(\"value\");\n\n  \tif (optionValue === undefined || !element.select) {\n  \t\treturn false;\n  \t}\n\n  \tselectValue = element.select.getAttribute(\"value\");\n\n  \tif (selectValue == optionValue) {\n  \t\treturn true;\n  \t}\n\n  \tif (element.select.getAttribute(\"multiple\") && isArray(selectValue)) {\n  \t\ti = selectValue.length;\n  \t\twhile (i--) {\n  \t\t\tif (selectValue[i] == optionValue) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  function inputIsCheckedRadio(element) {\n  \tvar attributes, typeAttribute, valueAttribute, nameAttribute;\n\n  \tattributes = element.attributes;\n\n  \ttypeAttribute = attributes.type;\n  \tvalueAttribute = attributes.value;\n  \tnameAttribute = attributes.name;\n\n  \tif (!typeAttribute || typeAttribute.value !== \"radio\" || !valueAttribute || !nameAttribute.interpolator) {\n  \t\treturn;\n  \t}\n\n  \tif (valueAttribute.value === nameAttribute.interpolator.value) {\n  \t\treturn true;\n  \t}\n  }\n\n  function stringifyAttribute(attribute) {\n  \tvar str = attribute.toString();\n  \treturn str ? \" \" + str : \"\";\n  }\n\n  var Element_prototype_unbind = Element$unbind;\n  function Element$unbind() {\n  \tif (this.fragment) {\n  \t\tthis.fragment.unbind();\n  \t}\n\n  \tif (this.binding) {\n  \t\tthis.binding.unbind();\n  \t}\n\n  \tif (this.eventHandlers) {\n  \t\tthis.eventHandlers.forEach(methodCallers__unbind);\n  \t}\n\n  \t// Special case - <option>\n  \tif (this.name === \"option\") {\n  \t\tspecial_option__unbind(this);\n  \t}\n\n  \tthis.attributes.forEach(methodCallers__unbind);\n  \tthis.conditionalAttributes.forEach(methodCallers__unbind);\n  }\n\n  var Element_prototype_unrender = Element$unrender;\n\n  function Element$unrender(shouldDestroy) {\n  \tvar binding, bindings, transition;\n\n  \tif (transition = this.transition) {\n  \t\ttransition.complete();\n  \t}\n\n  \t// Detach as soon as we can\n  \tif (this.name === \"option\") {\n  \t\t// <option> elements detach immediately, so that\n  \t\t// their parent <select> element syncs correctly, and\n  \t\t// since option elements can't have transitions anyway\n  \t\tthis.detach();\n  \t} else if (shouldDestroy) {\n  \t\tglobal_runloop.detachWhenReady(this);\n  \t}\n\n  \t// Children first. that way, any transitions on child elements will be\n  \t// handled by the current transitionManager\n  \tif (this.fragment) {\n  \t\tthis.fragment.unrender(false);\n  \t}\n\n  \tif (binding = this.binding) {\n  \t\tthis.binding.unrender();\n\n  \t\tthis.node._ractive.binding = null;\n  \t\tbindings = this.root._twowayBindings[binding.keypath.str];\n  \t\tbindings.splice(bindings.indexOf(binding), 1);\n  \t}\n\n  \t// Remove event handlers\n  \tif (this.eventHandlers) {\n  \t\tthis.eventHandlers.forEach(methodCallers__unrender);\n  \t}\n\n  \tif (this.decorator) {\n  \t\tglobal_runloop.registerDecorator(this.decorator);\n  \t}\n\n  \t// trigger outro transition if necessary\n  \tif (this.root.transitionsEnabled && this.outro) {\n  \t\ttransition = new _Transition(this, this.outro, false);\n  \t\tglobal_runloop.registerTransition(transition);\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\treturn transition.start();\n  \t\t});\n  \t}\n\n  \t// Remove this node from any live queries\n  \tif (this.liveQueries) {\n  \t\tremoveFromLiveQueries(this);\n  \t}\n\n  \tif (this.name === \"form\") {\n  \t\tform__unrender(this);\n  \t}\n  }\n\n  function removeFromLiveQueries(element) {\n  \tvar query, selector, i;\n\n  \ti = element.liveQueries.length;\n  \twhile (i--) {\n  \t\tquery = element.liveQueries[i];\n  \t\tselector = query.selector;\n\n  \t\tquery._remove(element.node);\n  \t}\n  }\n\n  var Element = function (options) {\n  \tthis.init(options);\n  };\n\n  Element.prototype = {\n  \tbubble: Element_prototype_bubble,\n  \tdetach: Element_prototype_detach,\n  \tfind: Element_prototype_find,\n  \tfindAll: Element_prototype_findAll,\n  \tfindAllComponents: Element_prototype_findAllComponents,\n  \tfindComponent: Element_prototype_findComponent,\n  \tfindNextNode: Element_prototype_findNextNode,\n  \tfirstNode: Element_prototype_firstNode,\n  \tgetAttribute: getAttribute,\n  \tinit: Element_prototype_init,\n  \trebind: Element_prototype_rebind,\n  \trender: Element_prototype_render,\n  \ttoString: Element_prototype_toString,\n  \tunbind: Element_prototype_unbind,\n  \tunrender: Element_prototype_unrender\n  };\n\n  var _Element = Element;\n\n  var deIndent__empty = /^\\s*$/,\n      deIndent__leadingWhitespace = /^\\s*/;\n\n  var deIndent = function (str) {\n  \tvar lines, firstLine, lastLine, minIndent;\n\n  \tlines = str.split(\"\\n\");\n\n  \t// remove first and last line, if they only contain whitespace\n  \tfirstLine = lines[0];\n  \tif (firstLine !== undefined && deIndent__empty.test(firstLine)) {\n  \t\tlines.shift();\n  \t}\n\n  \tlastLine = lastItem(lines);\n  \tif (lastLine !== undefined && deIndent__empty.test(lastLine)) {\n  \t\tlines.pop();\n  \t}\n\n  \tminIndent = lines.reduce(reducer, null);\n\n  \tif (minIndent) {\n  \t\tstr = lines.map(function (line) {\n  \t\t\treturn line.replace(minIndent, \"\");\n  \t\t}).join(\"\\n\");\n  \t}\n\n  \treturn str;\n  };\n\n  function reducer(previous, line) {\n  \tvar lineIndent = deIndent__leadingWhitespace.exec(line)[0];\n\n  \tif (previous === null || lineIndent.length < previous.length) {\n  \t\treturn lineIndent;\n  \t}\n\n  \treturn previous;\n  }\n\n  var Partial_getPartialTemplate = getPartialTemplate;\n\n  function getPartialTemplate(ractive, name, parentFragment) {\n  \tvar partial;\n\n  \t// If the partial in instance or view heirarchy instances, great\n  \tif (partial = getPartialFromRegistry(ractive, name, parentFragment || {})) {\n  \t\treturn partial;\n  \t}\n\n  \t// Does it exist on the page as a script tag?\n  \tpartial = template_parser.fromId(name, { noThrow: true });\n\n  \tif (partial) {\n  \t\t// is this necessary?\n  \t\tpartial = deIndent(partial);\n\n  \t\t// parse and register to this ractive instance\n  \t\tvar parsed = template_parser.parse(partial, template_parser.getParseOptions(ractive));\n\n  \t\t// register (and return main partial if there are others in the template)\n  \t\treturn ractive.partials[name] = parsed.t;\n  \t}\n  }\n\n  function getPartialFromRegistry(ractive, name, parentFragment) {\n  \tvar fn = undefined,\n  \t    partial = findParentPartial(name, parentFragment.owner);\n\n  \t// if there was an instance up-hierarchy, cool\n  \tif (partial) return partial;\n\n  \t// find first instance in the ractive or view hierarchy that has this partial\n  \tvar instance = findInstance(\"partials\", ractive, name);\n\n  \tif (!instance) {\n  \t\treturn;\n  \t}\n\n  \tpartial = instance.partials[name];\n\n  \t// partial is a function?\n  \tif (typeof partial === \"function\") {\n  \t\tfn = partial.bind(instance);\n  \t\tfn.isOwner = instance.partials.hasOwnProperty(name);\n  \t\tpartial = fn.call(ractive, template_parser);\n  \t}\n\n  \tif (!partial && partial !== \"\") {\n  \t\twarnIfDebug(noRegistryFunctionReturn, name, \"partial\", \"partial\", { ractive: ractive });\n  \t\treturn;\n  \t}\n\n  \t// If this was added manually to the registry,\n  \t// but hasn't been parsed, parse it now\n  \tif (!template_parser.isParsed(partial)) {\n\n  \t\t// use the parseOptions of the ractive instance on which it was found\n  \t\tvar parsed = template_parser.parse(partial, template_parser.getParseOptions(instance));\n\n  \t\t// Partials cannot contain nested partials!\n  \t\t// TODO add a test for this\n  \t\tif (parsed.p) {\n  \t\t\twarnIfDebug(\"Partials ({{>%s}}) cannot contain nested inline partials\", name, { ractive: ractive });\n  \t\t}\n\n  \t\t// if fn, use instance to store result, otherwise needs to go\n  \t\t// in the correct point in prototype chain on instance or constructor\n  \t\tvar target = fn ? instance : findOwner(instance, name);\n\n  \t\t// may be a template with partials, which need to be registered and main template extracted\n  \t\ttarget.partials[name] = partial = parsed.t;\n  \t}\n\n  \t// store for reset\n  \tif (fn) {\n  \t\tpartial._fn = fn;\n  \t}\n\n  \treturn partial.v ? partial.t : partial;\n  }\n\n  function findOwner(ractive, key) {\n  \treturn ractive.partials.hasOwnProperty(key) ? ractive : findConstructor(ractive.constructor, key);\n  }\n\n  function findConstructor(constructor, key) {\n  \tif (!constructor) {\n  \t\treturn;\n  \t}\n  \treturn constructor.partials.hasOwnProperty(key) ? constructor : findConstructor(constructor._Parent, key);\n  }\n\n  function findParentPartial(name, parent) {\n  \tif (parent) {\n  \t\tif (parent.template && parent.template.p && parent.template.p[name]) {\n  \t\t\treturn parent.template.p[name];\n  \t\t} else if (parent.parentFragment && parent.parentFragment.owner) {\n  \t\t\treturn findParentPartial(name, parent.parentFragment.owner);\n  \t\t}\n  \t}\n  }\n\n  var applyIndent = function (string, indent) {\n  \tvar indented;\n\n  \tif (!indent) {\n  \t\treturn string;\n  \t}\n\n  \tindented = string.split(\"\\n\").map(function (line, notFirstLine) {\n  \t\treturn notFirstLine ? indent + line : line;\n  \t}).join(\"\\n\");\n\n  \treturn indented;\n  };\n\n  var missingPartialMessage = \"Could not find template for partial \\\"%s\\\"\";\n\n  var Partial = function (options) {\n  \tvar parentFragment, template;\n\n  \tparentFragment = this.parentFragment = options.parentFragment;\n\n  \tthis.root = parentFragment.root;\n  \tthis.type = PARTIAL;\n  \tthis.index = options.index;\n  \tthis.name = options.template.r;\n  \tthis.rendered = false;\n\n  \tthis.fragment = this.fragmentToRender = this.fragmentToUnrender = null;\n\n  \tMustache.init(this, options);\n\n  \t// If this didn't resolve, it most likely means we have a named partial\n  \t// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial\n  \t// whose name is the value of `foo`')\n  \tif (!this.keypath) {\n  \t\tif (template = Partial_getPartialTemplate(this.root, this.name, parentFragment)) {\n  \t\t\tshared_unbind.call(this); // prevent any further changes\n  \t\t\tthis.isNamed = true;\n  \t\t\tthis.setTemplate(template);\n  \t\t} else {\n  \t\t\twarnOnceIfDebug(missingPartialMessage, this.name);\n  \t\t}\n  \t}\n  };\n\n  Partial.prototype = {\n  \tbubble: function () {\n  \t\tthis.parentFragment.bubble();\n  \t},\n\n  \tdetach: function () {\n  \t\treturn this.fragment.detach();\n  \t},\n\n  \tfind: function (selector) {\n  \t\treturn this.fragment.find(selector);\n  \t},\n\n  \tfindAll: function (selector, query) {\n  \t\treturn this.fragment.findAll(selector, query);\n  \t},\n\n  \tfindComponent: function (selector) {\n  \t\treturn this.fragment.findComponent(selector);\n  \t},\n\n  \tfindAllComponents: function (selector, query) {\n  \t\treturn this.fragment.findAllComponents(selector, query);\n  \t},\n\n  \tfirstNode: function () {\n  \t\treturn this.fragment.firstNode();\n  \t},\n\n  \tfindNextNode: function () {\n  \t\treturn this.parentFragment.findNextNode(this);\n  \t},\n\n  \tgetPartialName: function () {\n  \t\tif (this.isNamed && this.name) return this.name;else if (this.value === undefined) return this.name;else return this.value;\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.fragment.getValue();\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\t// named partials aren't bound, so don't rebind\n  \t\tif (!this.isNamed) {\n  \t\t\tMustache_rebind.call(this, oldKeypath, newKeypath);\n  \t\t}\n\n  \t\tif (this.fragment) {\n  \t\t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t\t}\n  \t},\n\n  \trender: function () {\n  \t\tthis.docFrag = document.createDocumentFragment();\n  \t\tthis.update();\n\n  \t\tthis.rendered = true;\n  \t\treturn this.docFrag;\n  \t},\n\n  \tresolve: Mustache.resolve,\n\n  \tsetValue: function (value) {\n  \t\tvar template;\n\n  \t\tif (value !== undefined && value === this.value) {\n  \t\t\t// nothing has changed, so no work to be done\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (value !== undefined) {\n  \t\t\ttemplate = Partial_getPartialTemplate(this.root, \"\" + value, this.parentFragment);\n  \t\t}\n\n  \t\t// we may be here if we have a partial like `{{>foo}}` and `foo` is the\n  \t\t// name of both a data property (whose value ISN'T the name of a partial)\n  \t\t// and a partial. In those cases, this becomes a named partial\n  \t\tif (!template && this.name && (template = Partial_getPartialTemplate(this.root, this.name, this.parentFragment))) {\n  \t\t\tshared_unbind.call(this);\n  \t\t\tthis.isNamed = true;\n  \t\t}\n\n  \t\tif (!template) {\n  \t\t\twarnOnceIfDebug(missingPartialMessage, this.name, { ractive: this.root });\n  \t\t}\n\n  \t\tthis.value = value;\n\n  \t\tthis.setTemplate(template || []);\n\n  \t\tthis.bubble();\n\n  \t\tif (this.rendered) {\n  \t\t\tglobal_runloop.addView(this);\n  \t\t}\n  \t},\n\n  \tsetTemplate: function (template) {\n  \t\tif (this.fragment) {\n  \t\t\tthis.fragment.unbind();\n  \t\t\tif (this.rendered) {\n  \t\t\t\tthis.fragmentToUnrender = this.fragment;\n  \t\t\t}\n  \t\t}\n\n  \t\tthis.fragment = new virtualdom_Fragment({\n  \t\t\ttemplate: template,\n  \t\t\troot: this.root,\n  \t\t\towner: this,\n  \t\t\tpElement: this.parentFragment.pElement\n  \t\t});\n\n  \t\tthis.fragmentToRender = this.fragment;\n  \t},\n\n  \ttoString: function (toString) {\n  \t\tvar string, previousItem, lastLine, match;\n\n  \t\tstring = this.fragment.toString(toString);\n\n  \t\tpreviousItem = this.parentFragment.items[this.index - 1];\n\n  \t\tif (!previousItem || previousItem.type !== TEXT) {\n  \t\t\treturn string;\n  \t\t}\n\n  \t\tlastLine = previousItem.text.split(\"\\n\").pop();\n\n  \t\tif (match = /^\\s+$/.exec(lastLine)) {\n  \t\t\treturn applyIndent(string, match[0]);\n  \t\t}\n\n  \t\treturn string;\n  \t},\n\n  \tunbind: function () {\n  \t\tif (!this.isNamed) {\n  \t\t\t// dynamic partial - need to unbind self\n  \t\t\tshared_unbind.call(this);\n  \t\t}\n\n  \t\tif (this.fragment) {\n  \t\t\tthis.fragment.unbind();\n  \t\t}\n  \t},\n\n  \tunrender: function (shouldDestroy) {\n  \t\tif (this.rendered) {\n  \t\t\tif (this.fragment) {\n  \t\t\t\tthis.fragment.unrender(shouldDestroy);\n  \t\t\t}\n  \t\t\tthis.rendered = false;\n  \t\t}\n  \t},\n\n  \tupdate: function () {\n  \t\tvar target, anchor;\n\n  \t\tif (this.fragmentToUnrender) {\n  \t\t\tthis.fragmentToUnrender.unrender(true);\n  \t\t\tthis.fragmentToUnrender = null;\n  \t\t}\n\n  \t\tif (this.fragmentToRender) {\n  \t\t\tthis.docFrag.appendChild(this.fragmentToRender.render());\n  \t\t\tthis.fragmentToRender = null;\n  \t\t}\n\n  \t\tif (this.rendered) {\n  \t\t\ttarget = this.parentFragment.getNode();\n  \t\t\tanchor = this.parentFragment.findNextNode(this);\n  \t\t\ttarget.insertBefore(this.docFrag, anchor);\n  \t\t}\n  \t}\n  };\n\n  var _Partial = Partial;\n\n  // finds the component constructor in the registry or view hierarchy registries\n\n  var Component_getComponent = getComponent;\n  function getComponent(ractive, name) {\n\n  \tvar Component,\n  \t    instance = findInstance(\"components\", ractive, name);\n\n  \tif (instance) {\n  \t\tComponent = instance.components[name];\n\n  \t\t// best test we have for not Ractive.extend\n  \t\tif (!Component._Parent) {\n  \t\t\t// function option, execute and store for reset\n  \t\t\tvar fn = Component.bind(instance);\n  \t\t\tfn.isOwner = instance.components.hasOwnProperty(name);\n  \t\t\tComponent = fn();\n\n  \t\t\tif (!Component) {\n  \t\t\t\twarnIfDebug(noRegistryFunctionReturn, name, \"component\", \"component\", { ractive: ractive });\n\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tif (typeof Component === \"string\") {\n  \t\t\t\t// allow string lookup\n  \t\t\t\tComponent = getComponent(ractive, Component);\n  \t\t\t}\n\n  \t\t\tComponent._fn = fn;\n  \t\t\tinstance.components[name] = Component;\n  \t\t}\n  \t}\n\n  \treturn Component;\n  }\n\n  var Component_prototype_detach = Component$detach;\n  var Component_prototype_detach__detachHook = new hooks_Hook(\"detach\");\n  function Component$detach() {\n  \tvar detached = this.instance.fragment.detach();\n  \tComponent_prototype_detach__detachHook.fire(this.instance);\n  \treturn detached;\n  }\n\n  var Component_prototype_find = Component$find;\n\n  function Component$find(selector) {\n  \treturn this.instance.fragment.find(selector);\n  }\n\n  var Component_prototype_findAll = Component$findAll;\n\n  function Component$findAll(selector, query) {\n  \treturn this.instance.fragment.findAll(selector, query);\n  }\n\n  var Component_prototype_findAllComponents = Component$findAllComponents;\n\n  function Component$findAllComponents(selector, query) {\n  \tquery._test(this, true);\n\n  \tif (this.instance.fragment) {\n  \t\tthis.instance.fragment.findAllComponents(selector, query);\n  \t}\n  }\n\n  var Component_prototype_findComponent = Component$findComponent;\n\n  function Component$findComponent(selector) {\n  \tif (!selector || selector === this.name) {\n  \t\treturn this.instance;\n  \t}\n\n  \tif (this.instance.fragment) {\n  \t\treturn this.instance.fragment.findComponent(selector);\n  \t}\n\n  \treturn null;\n  }\n\n  var Component_prototype_findNextNode = Component$findNextNode;\n\n  function Component$findNextNode() {\n  \treturn this.parentFragment.findNextNode(this);\n  }\n\n  var Component_prototype_firstNode = Component$firstNode;\n\n  function Component$firstNode() {\n  \tif (this.rendered) {\n  \t\treturn this.instance.fragment.firstNode();\n  \t}\n\n  \treturn null;\n  }\n\n  var processWrapper = function (wrapper, array, methodName, newIndices) {\n  \tvar root = wrapper.root;\n  \tvar keypath = wrapper.keypath;\n\n  \tif (!!newIndices) {\n  \t\troot.viewmodel.smartUpdate(keypath, array, newIndices);\n  \t} else {\n  \t\t// If this is a sort or reverse, we just do root.set()...\n  \t\t// TODO use merge logic?\n  \t\troot.viewmodel.mark(keypath);\n  \t}\n  };\n\n  var patchedArrayProto = [],\n      mutatorMethods = [\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"],\n      testObj,\n      patchArrayMethods,\n      unpatchArrayMethods;\n\n  mutatorMethods.forEach(function (methodName) {\n  \tvar method = function () {\n  \t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n  \t\t\targs[_key] = arguments[_key];\n  \t\t}\n\n  \t\tvar newIndices, result, wrapper, i;\n\n  \t\tnewIndices = shared_getNewIndices(this, methodName, args);\n\n  \t\t// apply the underlying method\n  \t\tresult = Array.prototype[methodName].apply(this, arguments);\n\n  \t\t// trigger changes\n  \t\tglobal_runloop.start();\n\n  \t\tthis._ractive.setting = true;\n  \t\ti = this._ractive.wrappers.length;\n  \t\twhile (i--) {\n  \t\t\twrapper = this._ractive.wrappers[i];\n\n  \t\t\tglobal_runloop.addRactive(wrapper.root);\n  \t\t\tprocessWrapper(wrapper, this, methodName, newIndices);\n  \t\t}\n\n  \t\tglobal_runloop.end();\n\n  \t\tthis._ractive.setting = false;\n  \t\treturn result;\n  \t};\n\n  \tdefineProperty(patchedArrayProto, methodName, {\n  \t\tvalue: method\n  \t});\n  });\n\n  // can we use prototype chain injection?\n  // http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\n  testObj = {};\n\n  if (testObj.__proto__) {\n  \t// yes, we can\n  \tpatchArrayMethods = function (array) {\n  \t\tarray.__proto__ = patchedArrayProto;\n  \t};\n\n  \tunpatchArrayMethods = function (array) {\n  \t\tarray.__proto__ = Array.prototype;\n  \t};\n  } else {\n  \t// no, we can't\n  \tpatchArrayMethods = function (array) {\n  \t\tvar i, methodName;\n\n  \t\ti = mutatorMethods.length;\n  \t\twhile (i--) {\n  \t\t\tmethodName = mutatorMethods[i];\n  \t\t\tdefineProperty(array, methodName, {\n  \t\t\t\tvalue: patchedArrayProto[methodName],\n  \t\t\t\tconfigurable: true\n  \t\t\t});\n  \t\t}\n  \t};\n\n  \tunpatchArrayMethods = function (array) {\n  \t\tvar i;\n\n  \t\ti = mutatorMethods.length;\n  \t\twhile (i--) {\n  \t\t\tdelete array[mutatorMethods[i]];\n  \t\t}\n  \t};\n  }\n\n  patchArrayMethods.unpatch = unpatchArrayMethods;\n  var patch = patchArrayMethods;\n\n  var arrayAdaptor,\n\n  // helpers\n  ArrayWrapper, array_index__errorMessage;\n\n  arrayAdaptor = {\n  \tfilter: function (object) {\n  \t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n  \t\t// or the array didn't trigger the get() itself\n  \t\treturn isArray(object) && (!object._ractive || !object._ractive.setting);\n  \t},\n  \twrap: function (ractive, array, keypath) {\n  \t\treturn new ArrayWrapper(ractive, array, keypath);\n  \t}\n  };\n\n  ArrayWrapper = function (ractive, array, keypath) {\n  \tthis.root = ractive;\n  \tthis.value = array;\n  \tthis.keypath = getKeypath(keypath);\n\n  \t// if this array hasn't already been ractified, ractify it\n  \tif (!array._ractive) {\n\n  \t\t// define a non-enumerable _ractive property to store the wrappers\n  \t\tdefineProperty(array, \"_ractive\", {\n  \t\t\tvalue: {\n  \t\t\t\twrappers: [],\n  \t\t\t\tinstances: [],\n  \t\t\t\tsetting: false\n  \t\t\t},\n  \t\t\tconfigurable: true\n  \t\t});\n\n  \t\tpatch(array);\n  \t}\n\n  \t// store the ractive instance, so we can handle transitions later\n  \tif (!array._ractive.instances[ractive._guid]) {\n  \t\tarray._ractive.instances[ractive._guid] = 0;\n  \t\tarray._ractive.instances.push(ractive);\n  \t}\n\n  \tarray._ractive.instances[ractive._guid] += 1;\n  \tarray._ractive.wrappers.push(this);\n  };\n\n  ArrayWrapper.prototype = {\n  \tget: function () {\n  \t\treturn this.value;\n  \t},\n  \tteardown: function () {\n  \t\tvar array, storage, wrappers, instances, index;\n\n  \t\tarray = this.value;\n  \t\tstorage = array._ractive;\n  \t\twrappers = storage.wrappers;\n  \t\tinstances = storage.instances;\n\n  \t\t// if teardown() was invoked because we're clearing the cache as a result of\n  \t\t// a change that the array itself triggered, we can save ourselves the teardown\n  \t\t// and immediate setup\n  \t\tif (storage.setting) {\n  \t\t\treturn false; // so that we don't remove it from this.root.viewmodel.wrapped\n  \t\t}\n\n  \t\tindex = wrappers.indexOf(this);\n  \t\tif (index === -1) {\n  \t\t\tthrow new Error(array_index__errorMessage);\n  \t\t}\n\n  \t\twrappers.splice(index, 1);\n\n  \t\t// if nothing else depends on this array, we can revert it to its\n  \t\t// natural state\n  \t\tif (!wrappers.length) {\n  \t\t\tdelete array._ractive;\n  \t\t\tpatch.unpatch(this.value);\n  \t\t} else {\n  \t\t\t// remove ractive instance if possible\n  \t\t\tinstances[this.root._guid] -= 1;\n  \t\t\tif (!instances[this.root._guid]) {\n  \t\t\t\tindex = instances.indexOf(this.root);\n\n  \t\t\t\tif (index === -1) {\n  \t\t\t\t\tthrow new Error(array_index__errorMessage);\n  \t\t\t\t}\n\n  \t\t\t\tinstances.splice(index, 1);\n  \t\t\t}\n  \t\t}\n  \t}\n  };\n\n  array_index__errorMessage = \"Something went wrong in a rather interesting way\";\n  var array_index = arrayAdaptor;\n\n  var numeric = /^\\s*[0-9]+\\s*$/;\n\n  var createBranch = function (key) {\n  \treturn numeric.test(key) ? [] : {};\n  };\n\n  var magicAdaptor, MagicWrapper;\n\n  try {\n  \tObject.defineProperty({}, \"test\", { value: 0 });\n\n  \tmagicAdaptor = {\n  \t\tfilter: function (object, keypath, ractive) {\n  \t\t\tvar parentWrapper, parentValue;\n\n  \t\t\tif (!keypath) {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\tkeypath = getKeypath(keypath);\n\n  \t\t\t// If the parent value is a wrapper, other than a magic wrapper,\n  \t\t\t// we shouldn't wrap this property\n  \t\t\tif ((parentWrapper = ractive.viewmodel.wrapped[keypath.parent.str]) && !parentWrapper.magic) {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\tparentValue = ractive.viewmodel.get(keypath.parent);\n\n  \t\t\t// if parentValue is an array that doesn't include this member,\n  \t\t\t// we should return false otherwise lengths will get messed up\n  \t\t\tif (isArray(parentValue) && /^[0-9]+$/.test(keypath.lastKey)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\treturn parentValue && (typeof parentValue === \"object\" || typeof parentValue === \"function\");\n  \t\t},\n  \t\twrap: function (ractive, property, keypath) {\n  \t\t\treturn new MagicWrapper(ractive, property, keypath);\n  \t\t}\n  \t};\n\n  \tMagicWrapper = function (ractive, value, keypath) {\n  \t\tvar objKeypath, template, siblings;\n\n  \t\tkeypath = getKeypath(keypath);\n\n  \t\tthis.magic = true;\n\n  \t\tthis.ractive = ractive;\n  \t\tthis.keypath = keypath;\n  \t\tthis.value = value;\n\n  \t\tthis.prop = keypath.lastKey;\n\n  \t\tobjKeypath = keypath.parent;\n  \t\tthis.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get(objKeypath);\n\n  \t\ttemplate = this.originalDescriptor = Object.getOwnPropertyDescriptor(this.obj, this.prop);\n\n  \t\t// Has this property already been wrapped?\n  \t\tif (template && template.set && (siblings = template.set._ractiveWrappers)) {\n\n  \t\t\t// Yes. Register this wrapper to this property, if it hasn't been already\n  \t\t\tif (siblings.indexOf(this) === -1) {\n  \t\t\t\tsiblings.push(this);\n  \t\t\t}\n\n  \t\t\treturn; // already wrapped\n  \t\t}\n\n  \t\t// No, it hasn't been wrapped\n  \t\tcreateAccessors(this, value, template);\n  \t};\n\n  \tMagicWrapper.prototype = {\n  \t\tget: function () {\n  \t\t\treturn this.value;\n  \t\t},\n  \t\treset: function (value) {\n  \t\t\tif (this.updating) {\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tthis.updating = true;\n  \t\t\tthis.obj[this.prop] = value; // trigger set() accessor\n  \t\t\tglobal_runloop.addRactive(this.ractive);\n  \t\t\tthis.ractive.viewmodel.mark(this.keypath, { keepExistingWrapper: true });\n  \t\t\tthis.updating = false;\n  \t\t\treturn true;\n  \t\t},\n  \t\tset: function (key, value) {\n  \t\t\tif (this.updating) {\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tif (!this.obj[this.prop]) {\n  \t\t\t\tthis.updating = true;\n  \t\t\t\tthis.obj[this.prop] = createBranch(key);\n  \t\t\t\tthis.updating = false;\n  \t\t\t}\n\n  \t\t\tthis.obj[this.prop][key] = value;\n  \t\t},\n  \t\tteardown: function () {\n  \t\t\tvar template, set, value, wrappers, index;\n\n  \t\t\t// If this method was called because the cache was being cleared as a\n  \t\t\t// result of a set()/update() call made by this wrapper, we return false\n  \t\t\t// so that it doesn't get torn down\n  \t\t\tif (this.updating) {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\ttemplate = Object.getOwnPropertyDescriptor(this.obj, this.prop);\n  \t\t\tset = template && template.set;\n\n  \t\t\tif (!set) {\n  \t\t\t\t// most likely, this was an array member that was spliced out\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\twrappers = set._ractiveWrappers;\n\n  \t\t\tindex = wrappers.indexOf(this);\n  \t\t\tif (index !== -1) {\n  \t\t\t\twrappers.splice(index, 1);\n  \t\t\t}\n\n  \t\t\t// Last one out, turn off the lights\n  \t\t\tif (!wrappers.length) {\n  \t\t\t\tvalue = this.obj[this.prop];\n\n  \t\t\t\tObject.defineProperty(this.obj, this.prop, this.originalDescriptor || {\n  \t\t\t\t\twritable: true,\n  \t\t\t\t\tenumerable: true,\n  \t\t\t\t\tconfigurable: true\n  \t\t\t\t});\n\n  \t\t\t\tthis.obj[this.prop] = value;\n  \t\t\t}\n  \t\t}\n  \t};\n  } catch (err) {\n  \tmagicAdaptor = false; // no magic in this browser\n  }\n\n  var adaptors_magic = magicAdaptor;\n\n  function createAccessors(originalWrapper, value, template) {\n\n  \tvar object, property, oldGet, oldSet, get, set;\n\n  \tobject = originalWrapper.obj;\n  \tproperty = originalWrapper.prop;\n\n  \t// Is this template configurable?\n  \tif (template && !template.configurable) {\n  \t\t// Special case - array length\n  \t\tif (property === \"length\") {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthrow new Error(\"Cannot use magic mode with property \\\"\" + property + \"\\\" - object is not configurable\");\n  \t}\n\n  \t// Time to wrap this property\n  \tif (template) {\n  \t\toldGet = template.get;\n  \t\toldSet = template.set;\n  \t}\n\n  \tget = oldGet || function () {\n  \t\treturn value;\n  \t};\n\n  \tset = function (v) {\n  \t\tif (oldSet) {\n  \t\t\toldSet(v);\n  \t\t}\n\n  \t\tvalue = oldGet ? oldGet() : v;\n  \t\tset._ractiveWrappers.forEach(updateWrapper);\n  \t};\n\n  \tfunction updateWrapper(wrapper) {\n  \t\tvar keypath, ractive;\n\n  \t\twrapper.value = value;\n\n  \t\tif (wrapper.updating) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tractive = wrapper.ractive;\n  \t\tkeypath = wrapper.keypath;\n\n  \t\twrapper.updating = true;\n  \t\tglobal_runloop.start(ractive);\n\n  \t\tractive.viewmodel.mark(keypath);\n\n  \t\tglobal_runloop.end();\n  \t\twrapper.updating = false;\n  \t}\n\n  \t// Create an array of wrappers, in case other keypaths/ractives depend on this property.\n  \t// Handily, we can store them as a property of the set function. Yay JavaScript.\n  \tset._ractiveWrappers = [originalWrapper];\n  \tObject.defineProperty(object, property, { get: get, set: set, enumerable: true, configurable: true });\n  }\n\n  var magicArrayAdaptor, MagicArrayWrapper;\n\n  if (adaptors_magic) {\n  \tmagicArrayAdaptor = {\n  \t\tfilter: function (object, keypath, ractive) {\n  \t\t\treturn adaptors_magic.filter(object, keypath, ractive) && array_index.filter(object);\n  \t\t},\n\n  \t\twrap: function (ractive, array, keypath) {\n  \t\t\treturn new MagicArrayWrapper(ractive, array, keypath);\n  \t\t}\n  \t};\n\n  \tMagicArrayWrapper = function (ractive, array, keypath) {\n  \t\tthis.value = array;\n\n  \t\tthis.magic = true;\n\n  \t\tthis.magicWrapper = adaptors_magic.wrap(ractive, array, keypath);\n  \t\tthis.arrayWrapper = array_index.wrap(ractive, array, keypath);\n  \t};\n\n  \tMagicArrayWrapper.prototype = {\n  \t\tget: function () {\n  \t\t\treturn this.value;\n  \t\t},\n  \t\tteardown: function () {\n  \t\t\tthis.arrayWrapper.teardown();\n  \t\t\tthis.magicWrapper.teardown();\n  \t\t},\n  \t\treset: function (value) {\n  \t\t\treturn this.magicWrapper.reset(value);\n  \t\t}\n  \t};\n  }\n\n  var magicArray = magicArrayAdaptor;\n\n  var prototype_adapt = Viewmodel$adapt;\n\n  var prefixers = {};\n  function Viewmodel$adapt(keypath, value) {\n  \tvar len, i, adaptor, wrapped;\n\n  \tif (!this.adaptors) return;\n\n  \t// Do we have an adaptor for this value?\n  \tlen = this.adaptors.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tadaptor = this.adaptors[i];\n\n  \t\tif (adaptor.filter(value, keypath, this.ractive)) {\n  \t\t\twrapped = this.wrapped[keypath] = adaptor.wrap(this.ractive, value, keypath, getPrefixer(keypath));\n  \t\t\twrapped.value = value;\n  \t\t\treturn;\n  \t\t}\n  \t}\n  }\n\n  function prefixKeypath(obj, prefix) {\n  \tvar prefixed = {},\n  \t    key;\n\n  \tif (!prefix) {\n  \t\treturn obj;\n  \t}\n\n  \tprefix += \".\";\n\n  \tfor (key in obj) {\n  \t\tif (obj.hasOwnProperty(key)) {\n  \t\t\tprefixed[prefix + key] = obj[key];\n  \t\t}\n  \t}\n\n  \treturn prefixed;\n  }\n\n  function getPrefixer(rootKeypath) {\n  \tvar rootDot;\n\n  \tif (!prefixers[rootKeypath]) {\n  \t\trootDot = rootKeypath ? rootKeypath + \".\" : \"\";\n\n  \t\tprefixers[rootKeypath] = function (relativeKeypath, value) {\n  \t\t\tvar obj;\n\n  \t\t\tif (typeof relativeKeypath === \"string\") {\n  \t\t\t\tobj = {};\n  \t\t\t\tobj[rootDot + relativeKeypath] = value;\n  \t\t\t\treturn obj;\n  \t\t\t}\n\n  \t\t\tif (typeof relativeKeypath === \"object\") {\n  \t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n  \t\t\t\treturn rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;\n  \t\t\t}\n  \t\t};\n  \t}\n\n  \treturn prefixers[rootKeypath];\n  }\n\n  // TEMP\n\n  var helpers_getUpstreamChanges = getUpstreamChanges;\n  function getUpstreamChanges(changes) {\n  \tvar upstreamChanges = [rootKeypath],\n  \t    i,\n  \t    keypath;\n\n  \ti = changes.length;\n  \twhile (i--) {\n  \t\tkeypath = changes[i].parent;\n\n  \t\twhile (keypath && !keypath.isRoot) {\n  \t\t\tif (changes.indexOf(keypath) === -1) {\n  \t\t\t\taddToArray(upstreamChanges, keypath);\n  \t\t\t}\n  \t\t\tkeypath = keypath.parent;\n  \t\t}\n  \t}\n\n  \treturn upstreamChanges;\n  }\n\n  var applyChanges_notifyPatternObservers = notifyPatternObservers;\n\n  function notifyPatternObservers(viewmodel, keypath, onlyDirect) {\n  \tvar potentialWildcardMatches;\n\n  \tupdateMatchingPatternObservers(viewmodel, keypath);\n\n  \tif (onlyDirect) {\n  \t\treturn;\n  \t}\n\n  \tpotentialWildcardMatches = keypath.wildcardMatches();\n  \tpotentialWildcardMatches.forEach(function (upstreamPattern) {\n  \t\tcascade(viewmodel, upstreamPattern, keypath);\n  \t});\n  }\n\n  function cascade(viewmodel, upstreamPattern, keypath) {\n  \tvar group, map, actualChildKeypath;\n\n  \t// TODO should be one or the other\n  \tupstreamPattern = upstreamPattern.str || upstreamPattern;\n\n  \tgroup = viewmodel.depsMap.patternObservers;\n  \tmap = group && group[upstreamPattern];\n\n  \tif (!map) {\n  \t\treturn;\n  \t}\n\n  \tmap.forEach(function (childKeypath) {\n  \t\tactualChildKeypath = keypath.join(childKeypath.lastKey); // 'foo.bar.baz'\n\n  \t\tupdateMatchingPatternObservers(viewmodel, actualChildKeypath);\n  \t\tcascade(viewmodel, childKeypath, actualChildKeypath);\n  \t});\n  }\n\n  function updateMatchingPatternObservers(viewmodel, keypath) {\n  \tviewmodel.patternObservers.forEach(function (observer) {\n  \t\tif (observer.regex.test(keypath.str)) {\n  \t\t\tobserver.update(keypath);\n  \t\t}\n  \t});\n  }\n\n  var applyChanges = Viewmodel$applyChanges;\n\n  function Viewmodel$applyChanges() {\n  \tvar _this = this;\n\n  \tvar self = this,\n  \t    changes,\n  \t    upstreamChanges,\n  \t    hash = {},\n  \t    bindings;\n\n  \tchanges = this.changes;\n\n  \tif (!changes.length) {\n  \t\t// TODO we end up here on initial render. Perhaps we shouldn't?\n  \t\treturn;\n  \t}\n\n  \tfunction invalidateComputation(computation) {\n  \t\tvar key = computation.key;\n\n  \t\tif (computation.viewmodel === self) {\n  \t\t\tself.clearCache(key.str);\n  \t\t\tcomputation.invalidate();\n\n  \t\t\tchanges.push(key);\n  \t\t\tcascade(key);\n  \t\t} else {\n  \t\t\tcomputation.viewmodel.mark(key);\n  \t\t}\n  \t}\n\n  \tfunction cascade(keypath) {\n  \t\tvar map, computations;\n\n  \t\tif (self.noCascade.hasOwnProperty(keypath.str)) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (computations = self.deps.computed[keypath.str]) {\n  \t\t\tcomputations.forEach(invalidateComputation);\n  \t\t}\n\n  \t\tif (map = self.depsMap.computed[keypath.str]) {\n  \t\t\tmap.forEach(cascade);\n  \t\t}\n  \t}\n\n  \tchanges.slice().forEach(cascade);\n\n  \tupstreamChanges = helpers_getUpstreamChanges(changes);\n  \tupstreamChanges.forEach(function (keypath) {\n  \t\tvar computations;\n\n  \t\t// make sure we haven't already been down this particular keypath in this turn\n  \t\tif (changes.indexOf(keypath) === -1 && (computations = self.deps.computed[keypath.str])) {\n  \t\t\tcomputations.forEach(invalidateComputation);\n  \t\t}\n  \t});\n\n  \tthis.changes = [];\n\n  \t// Pattern observers are a weird special case\n  \tif (this.patternObservers.length) {\n  \t\tupstreamChanges.forEach(function (keypath) {\n  \t\t\treturn applyChanges_notifyPatternObservers(_this, keypath, true);\n  \t\t});\n  \t\tchanges.forEach(function (keypath) {\n  \t\t\treturn applyChanges_notifyPatternObservers(_this, keypath);\n  \t\t});\n  \t}\n\n  \tif (this.deps.observers) {\n  \t\tupstreamChanges.forEach(function (keypath) {\n  \t\t\treturn notifyUpstreamDependants(_this, null, keypath, \"observers\");\n  \t\t});\n  \t\tnotifyAllDependants(this, changes, \"observers\");\n  \t}\n\n  \tif (this.deps[\"default\"]) {\n  \t\tbindings = [];\n  \t\tupstreamChanges.forEach(function (keypath) {\n  \t\t\treturn notifyUpstreamDependants(_this, bindings, keypath, \"default\");\n  \t\t});\n\n  \t\tif (bindings.length) {\n  \t\t\tnotifyBindings(this, bindings, changes);\n  \t\t}\n\n  \t\tnotifyAllDependants(this, changes, \"default\");\n  \t}\n\n  \t// Return a hash of keypaths to updated values\n  \tchanges.forEach(function (keypath) {\n  \t\thash[keypath.str] = _this.get(keypath);\n  \t});\n\n  \tthis.implicitChanges = {};\n  \tthis.noCascade = {};\n\n  \treturn hash;\n  }\n\n  function notifyUpstreamDependants(viewmodel, bindings, keypath, groupName) {\n  \tvar dependants, value;\n\n  \tif (dependants = findDependants(viewmodel, keypath, groupName)) {\n  \t\tvalue = viewmodel.get(keypath);\n\n  \t\tdependants.forEach(function (d) {\n  \t\t\t// don't \"set\" the parent value, refine it\n  \t\t\t// i.e. not data = value, but data[foo] = fooValue\n  \t\t\tif (bindings && d.refineValue) {\n  \t\t\t\tbindings.push(d);\n  \t\t\t} else {\n  \t\t\t\td.setValue(value);\n  \t\t\t}\n  \t\t});\n  \t}\n  }\n\n  function notifyBindings(viewmodel, bindings, changes) {\n\n  \tbindings.forEach(function (binding) {\n  \t\tvar useSet = false,\n  \t\t    i = 0,\n  \t\t    length = changes.length,\n  \t\t    refinements = [];\n\n  \t\twhile (i < length) {\n  \t\t\tvar keypath = changes[i];\n\n  \t\t\tif (keypath === binding.keypath) {\n  \t\t\t\tuseSet = true;\n  \t\t\t\tbreak;\n  \t\t\t}\n\n  \t\t\tif (keypath.slice(0, binding.keypath.length) === binding.keypath) {\n  \t\t\t\trefinements.push(keypath);\n  \t\t\t}\n\n  \t\t\ti++;\n  \t\t}\n\n  \t\tif (useSet) {\n  \t\t\tbinding.setValue(viewmodel.get(binding.keypath));\n  \t\t}\n\n  \t\tif (refinements.length) {\n  \t\t\tbinding.refineValue(refinements);\n  \t\t}\n  \t});\n  }\n\n  function notifyAllDependants(viewmodel, keypaths, groupName) {\n  \tvar queue = [];\n\n  \taddKeypaths(keypaths);\n  \tqueue.forEach(dispatch);\n\n  \tfunction addKeypaths(keypaths) {\n  \t\tkeypaths.forEach(addKeypath);\n  \t\tkeypaths.forEach(cascade);\n  \t}\n\n  \tfunction addKeypath(keypath) {\n  \t\tvar deps = findDependants(viewmodel, keypath, groupName);\n\n  \t\tif (deps) {\n  \t\t\tqueue.push({\n  \t\t\t\tkeypath: keypath,\n  \t\t\t\tdeps: deps\n  \t\t\t});\n  \t\t}\n  \t}\n\n  \tfunction cascade(keypath) {\n  \t\tvar childDeps;\n\n  \t\tif (childDeps = viewmodel.depsMap[groupName][keypath.str]) {\n  \t\t\taddKeypaths(childDeps);\n  \t\t}\n  \t}\n\n  \tfunction dispatch(set) {\n  \t\tvar value = viewmodel.get(set.keypath);\n  \t\tset.deps.forEach(function (d) {\n  \t\t\treturn d.setValue(value);\n  \t\t});\n  \t}\n  }\n\n  function findDependants(viewmodel, keypath, groupName) {\n  \tvar group = viewmodel.deps[groupName];\n  \treturn group ? group[keypath.str] : null;\n  }\n\n  var capture = Viewmodel$capture;\n\n  function Viewmodel$capture() {\n  \tthis.captureGroups.push([]);\n  }\n\n  var clearCache = Viewmodel$clearCache;\n\n  function Viewmodel$clearCache(keypath, keepExistingWrapper) {\n  \tvar cacheMap, wrapper;\n\n  \tif (!keepExistingWrapper) {\n  \t\t// Is there a wrapped property at this keypath?\n  \t\tif (wrapper = this.wrapped[keypath]) {\n  \t\t\t// Did we unwrap it?\n  \t\t\tif (wrapper.teardown() !== false) {\n  \t\t\t\t// Is this right?\n  \t\t\t\t// What's the meaning of returning false from teardown?\n  \t\t\t\t// Could there be a GC ramification if this is a \"real\" ractive.teardown()?\n  \t\t\t\tthis.wrapped[keypath] = null;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tthis.cache[keypath] = undefined;\n\n  \tif (cacheMap = this.cacheMap[keypath]) {\n  \t\twhile (cacheMap.length) {\n  \t\t\tthis.clearCache(cacheMap.pop());\n  \t\t}\n  \t}\n  }\n\n  var UnresolvedDependency = function (computation, ref) {\n  \tthis.computation = computation;\n  \tthis.viewmodel = computation.viewmodel;\n  \tthis.ref = ref;\n\n  \t// TODO this seems like a red flag!\n  \tthis.root = this.viewmodel.ractive;\n  \tthis.parentFragment = this.root.component && this.root.component.parentFragment;\n  };\n\n  UnresolvedDependency.prototype = {\n  \tresolve: function (keypath) {\n  \t\tthis.computation.softDeps.push(keypath);\n  \t\tthis.computation.unresolvedDeps[keypath.str] = null;\n  \t\tthis.viewmodel.register(keypath, this.computation, \"computed\");\n  \t}\n  };\n\n  var Computation_UnresolvedDependency = UnresolvedDependency;\n\n  var Computation = function (key, signature) {\n  \tthis.key = key;\n\n  \tthis.getter = signature.getter;\n  \tthis.setter = signature.setter;\n\n  \tthis.hardDeps = signature.deps || [];\n  \tthis.softDeps = [];\n  \tthis.unresolvedDeps = {};\n\n  \tthis.depValues = {};\n\n  \tthis._dirty = this._firstRun = true;\n  };\n\n  Computation.prototype = {\n  \tconstructor: Computation,\n\n  \tinit: function (viewmodel) {\n  \t\tvar _this = this;\n\n  \t\tvar initial;\n\n  \t\tthis.viewmodel = viewmodel;\n  \t\tthis.bypass = true;\n\n  \t\tinitial = viewmodel.get(this.key);\n  \t\tviewmodel.clearCache(this.key.str);\n\n  \t\tthis.bypass = false;\n\n  \t\tif (this.setter && initial !== undefined) {\n  \t\t\tthis.set(initial);\n  \t\t}\n\n  \t\tif (this.hardDeps) {\n  \t\t\tthis.hardDeps.forEach(function (d) {\n  \t\t\t\treturn viewmodel.register(d, _this, \"computed\");\n  \t\t\t});\n  \t\t}\n  \t},\n\n  \tinvalidate: function () {\n  \t\tthis._dirty = true;\n  \t},\n\n  \tget: function () {\n  \t\tvar _this = this;\n\n  \t\tvar newDeps,\n  \t\t    dependenciesChanged,\n  \t\t    dependencyValuesChanged = false;\n\n  \t\tif (this.getting) {\n  \t\t\t// prevent double-computation (e.g. caused by array mutation inside computation)\n  \t\t\tvar msg = \"The \" + this.key.str + \" computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by `array.sort(...)` - if that's the case, clone the array first with `array.slice().sort(...)`\";\n  \t\t\twarnOnce(msg);\n  \t\t\treturn this.value;\n  \t\t}\n\n  \t\tthis.getting = true;\n\n  \t\tif (this._dirty) {\n  \t\t\t// determine whether the inputs have changed, in case this depends on\n  \t\t\t// other computed values\n  \t\t\tif (this._firstRun || !this.hardDeps.length && !this.softDeps.length) {\n  \t\t\t\tdependencyValuesChanged = true;\n  \t\t\t} else {\n  \t\t\t\t[this.hardDeps, this.softDeps].forEach(function (deps) {\n  \t\t\t\t\tvar keypath, value, i;\n\n  \t\t\t\t\tif (dependencyValuesChanged) {\n  \t\t\t\t\t\treturn;\n  \t\t\t\t\t}\n\n  \t\t\t\t\ti = deps.length;\n  \t\t\t\t\twhile (i--) {\n  \t\t\t\t\t\tkeypath = deps[i];\n  \t\t\t\t\t\tvalue = _this.viewmodel.get(keypath);\n\n  \t\t\t\t\t\tif (!isEqual(value, _this.depValues[keypath.str])) {\n  \t\t\t\t\t\t\t_this.depValues[keypath.str] = value;\n  \t\t\t\t\t\t\tdependencyValuesChanged = true;\n\n  \t\t\t\t\t\t\treturn;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t});\n  \t\t\t}\n\n  \t\t\tif (dependencyValuesChanged) {\n  \t\t\t\tthis.viewmodel.capture();\n\n  \t\t\t\ttry {\n  \t\t\t\t\tthis.value = this.getter();\n  \t\t\t\t} catch (err) {\n  \t\t\t\t\twarnIfDebug(\"Failed to compute \\\"%s\\\"\", this.key.str);\n  \t\t\t\t\tlogIfDebug(err.stack || err);\n\n  \t\t\t\t\tthis.value = void 0;\n  \t\t\t\t}\n\n  \t\t\t\tnewDeps = this.viewmodel.release();\n  \t\t\t\tdependenciesChanged = this.updateDependencies(newDeps);\n\n  \t\t\t\tif (dependenciesChanged) {\n  \t\t\t\t\t[this.hardDeps, this.softDeps].forEach(function (deps) {\n  \t\t\t\t\t\tdeps.forEach(function (keypath) {\n  \t\t\t\t\t\t\t_this.depValues[keypath.str] = _this.viewmodel.get(keypath);\n  \t\t\t\t\t\t});\n  \t\t\t\t\t});\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tthis._dirty = false;\n  \t\t}\n\n  \t\tthis.getting = this._firstRun = false;\n  \t\treturn this.value;\n  \t},\n\n  \tset: function (value) {\n  \t\tif (this.setting) {\n  \t\t\tthis.value = value;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (!this.setter) {\n  \t\t\tthrow new Error(\"Computed properties without setters are read-only. (This may change in a future version of Ractive!)\");\n  \t\t}\n\n  \t\tthis.setter(value);\n  \t},\n\n  \tupdateDependencies: function (newDeps) {\n  \t\tvar i, oldDeps, keypath, dependenciesChanged, unresolved;\n\n  \t\toldDeps = this.softDeps;\n\n  \t\t// remove dependencies that are no longer used\n  \t\ti = oldDeps.length;\n  \t\twhile (i--) {\n  \t\t\tkeypath = oldDeps[i];\n\n  \t\t\tif (newDeps.indexOf(keypath) === -1) {\n  \t\t\t\tdependenciesChanged = true;\n  \t\t\t\tthis.viewmodel.unregister(keypath, this, \"computed\");\n  \t\t\t}\n  \t\t}\n\n  \t\t// create references for any new dependencies\n  \t\ti = newDeps.length;\n  \t\twhile (i--) {\n  \t\t\tkeypath = newDeps[i];\n\n  \t\t\tif (oldDeps.indexOf(keypath) === -1 && (!this.hardDeps || this.hardDeps.indexOf(keypath) === -1)) {\n  \t\t\t\tdependenciesChanged = true;\n\n  \t\t\t\t// if this keypath is currently unresolved, we need to mark\n  \t\t\t\t// it as such. TODO this is a bit muddy...\n  \t\t\t\tif (isUnresolved(this.viewmodel, keypath) && !this.unresolvedDeps[keypath.str]) {\n  \t\t\t\t\tunresolved = new Computation_UnresolvedDependency(this, keypath.str);\n  \t\t\t\t\tnewDeps.splice(i, 1);\n\n  \t\t\t\t\tthis.unresolvedDeps[keypath.str] = unresolved;\n  \t\t\t\t\tglobal_runloop.addUnresolved(unresolved);\n  \t\t\t\t} else {\n  \t\t\t\t\tthis.viewmodel.register(keypath, this, \"computed\");\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tif (dependenciesChanged) {\n  \t\t\tthis.softDeps = newDeps.slice();\n  \t\t}\n\n  \t\treturn dependenciesChanged;\n  \t}\n  };\n\n  function isUnresolved(viewmodel, keypath) {\n  \tvar key = keypath.firstKey;\n\n  \treturn !(key in viewmodel.data) && !(key in viewmodel.computations) && !(key in viewmodel.mappings);\n  }\n\n  var Computation_Computation = Computation;\n\n  var compute = Viewmodel$compute;\n  function Viewmodel$compute(key, signature) {\n  \tvar computation = new Computation_Computation(key, signature);\n\n  \tif (this.ready) {\n  \t\tcomputation.init(this);\n  \t}\n\n  \treturn this.computations[key.str] = computation;\n  }\n\n  var FAILED_LOOKUP = { FAILED_LOOKUP: true };\n\n  var viewmodel_prototype_get = Viewmodel$get;\n\n  var viewmodel_prototype_get__empty = {};\n  function Viewmodel$get(keypath, options) {\n  \tvar cache = this.cache,\n  \t    value,\n  \t    computation,\n  \t    wrapped,\n  \t    captureGroup,\n  \t    keypathStr = keypath.str,\n  \t    key;\n\n  \toptions = options || viewmodel_prototype_get__empty;\n\n  \t// capture the keypath, if we're inside a computation\n  \tif (options.capture && (captureGroup = lastItem(this.captureGroups))) {\n  \t\tif (! ~captureGroup.indexOf(keypath)) {\n  \t\t\tcaptureGroup.push(keypath);\n  \t\t}\n  \t}\n\n  \tif (hasOwn.call(this.mappings, keypath.firstKey)) {\n  \t\treturn this.mappings[keypath.firstKey].get(keypath, options);\n  \t}\n\n  \tif (keypath.isSpecial) {\n  \t\treturn keypath.value;\n  \t}\n\n  \tif (cache[keypathStr] === undefined) {\n\n  \t\t// Is this a computed property?\n  \t\tif ((computation = this.computations[keypathStr]) && !computation.bypass) {\n  \t\t\tvalue = computation.get();\n  \t\t\tthis.adapt(keypathStr, value);\n  \t\t}\n\n  \t\t// Is this a wrapped property?\n  \t\telse if (wrapped = this.wrapped[keypathStr]) {\n  \t\t\tvalue = wrapped.value;\n  \t\t}\n\n  \t\t// Is it the root?\n  \t\telse if (keypath.isRoot) {\n  \t\t\tthis.adapt(\"\", this.data);\n  \t\t\tvalue = this.data;\n  \t\t}\n\n  \t\t// No? Then we need to retrieve the value one key at a time\n  \t\telse {\n  \t\t\tvalue = retrieve(this, keypath);\n  \t\t}\n\n  \t\tcache[keypathStr] = value;\n  \t} else {\n  \t\tvalue = cache[keypathStr];\n  \t}\n\n  \tif (!options.noUnwrap && (wrapped = this.wrapped[keypathStr])) {\n  \t\tvalue = wrapped.get();\n  \t}\n\n  \tif (keypath.isRoot && options.fullRootGet) {\n  \t\tfor (key in this.mappings) {\n  \t\t\tvalue[key] = this.mappings[key].getValue();\n  \t\t}\n  \t}\n\n  \treturn value === FAILED_LOOKUP ? void 0 : value;\n  }\n\n  function retrieve(viewmodel, keypath) {\n\n  \tvar parentValue, cacheMap, value, wrapped;\n\n  \tparentValue = viewmodel.get(keypath.parent);\n\n  \tif (wrapped = viewmodel.wrapped[keypath.parent.str]) {\n  \t\tparentValue = wrapped.get();\n  \t}\n\n  \tif (parentValue === null || parentValue === undefined) {\n  \t\treturn;\n  \t}\n\n  \t// update cache map\n  \tif (!(cacheMap = viewmodel.cacheMap[keypath.parent.str])) {\n  \t\tviewmodel.cacheMap[keypath.parent.str] = [keypath.str];\n  \t} else {\n  \t\tif (cacheMap.indexOf(keypath.str) === -1) {\n  \t\t\tcacheMap.push(keypath.str);\n  \t\t}\n  \t}\n\n  \t// If this property doesn't exist, we return a sentinel value\n  \t// so that we know to query parent scope (if such there be)\n  \tif (typeof parentValue === \"object\" && !(keypath.lastKey in parentValue)) {\n  \t\treturn viewmodel.cache[keypath.str] = FAILED_LOOKUP;\n  \t}\n\n  \tvalue = parentValue[keypath.lastKey];\n\n  \t// Do we have an adaptor for this value?\n  \tviewmodel.adapt(keypath.str, value, false);\n\n  \t// Update cache\n  \tviewmodel.cache[keypath.str] = value;\n  \treturn value;\n  }\n\n  var viewmodel_prototype_init = Viewmodel$init;\n\n  function Viewmodel$init() {\n  \tvar key;\n\n  \tfor (key in this.computations) {\n  \t\tthis.computations[key].init(this);\n  \t}\n  }\n\n  var prototype_map = Viewmodel$map;\n\n  function Viewmodel$map(key, options) {\n  \tvar mapping = this.mappings[key.str] = new Mapping(key, options);\n  \tmapping.initViewmodel(this);\n  \treturn mapping;\n  }\n\n  var Mapping = function (localKey, options) {\n  \tthis.localKey = localKey;\n  \tthis.keypath = options.keypath;\n  \tthis.origin = options.origin;\n\n  \tthis.deps = [];\n  \tthis.unresolved = [];\n\n  \tthis.resolved = false;\n  };\n\n  Mapping.prototype = {\n  \tforceResolution: function () {\n  \t\t// TODO warn, as per #1692?\n  \t\tthis.keypath = this.localKey;\n  \t\tthis.setup();\n  \t},\n\n  \tget: function (keypath, options) {\n  \t\tif (!this.resolved) {\n  \t\t\treturn undefined;\n  \t\t}\n  \t\treturn this.origin.get(this.map(keypath), options);\n  \t},\n\n  \tgetValue: function () {\n  \t\tif (!this.keypath) {\n  \t\t\treturn undefined;\n  \t\t}\n  \t\treturn this.origin.get(this.keypath);\n  \t},\n\n  \tinitViewmodel: function (viewmodel) {\n  \t\tthis.local = viewmodel;\n  \t\tthis.setup();\n  \t},\n\n  \tmap: function (keypath) {\n  \t\tif (typeof this.keypath === undefined) {\n  \t\t\treturn this.localKey;\n  \t\t}\n  \t\treturn keypath.replace(this.localKey, this.keypath);\n  \t},\n\n  \tregister: function (keypath, dependant, group) {\n  \t\tthis.deps.push({ keypath: keypath, dep: dependant, group: group });\n\n  \t\tif (this.resolved) {\n  \t\t\tthis.origin.register(this.map(keypath), dependant, group);\n  \t\t}\n  \t},\n\n  \tresolve: function (keypath) {\n  \t\tif (this.keypath !== undefined) {\n  \t\t\tthis.unbind(true);\n  \t\t}\n\n  \t\tthis.keypath = keypath;\n  \t\tthis.setup();\n  \t},\n\n  \tset: function (keypath, value) {\n  \t\tif (!this.resolved) {\n  \t\t\tthis.forceResolution();\n  \t\t}\n\n  \t\tthis.origin.set(this.map(keypath), value);\n  \t},\n\n  \tsetup: function () {\n  \t\tvar _this = this;\n\n  \t\tif (this.keypath === undefined) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.resolved = true;\n\n  \t\t// accumulated dependants can now be registered\n  \t\tif (this.deps.length) {\n  \t\t\tthis.deps.forEach(function (d) {\n  \t\t\t\tvar keypath = _this.map(d.keypath);\n  \t\t\t\t_this.origin.register(keypath, d.dep, d.group);\n\n  \t\t\t\t// TODO this is a bit of a red flag... all deps should be the same?\n  \t\t\t\tif (d.dep.setValue) {\n  \t\t\t\t\td.dep.setValue(_this.origin.get(keypath));\n  \t\t\t\t} else if (d.dep.invalidate) {\n  \t\t\t\t\td.dep.invalidate();\n  \t\t\t\t} else {\n  \t\t\t\t\tthrow new Error(\"An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!\");\n  \t\t\t\t}\n  \t\t\t});\n\n  \t\t\tthis.origin.mark(this.keypath);\n  \t\t}\n  \t},\n\n  \tsetValue: function (value) {\n  \t\tif (!this.keypath) {\n  \t\t\tthrow new Error(\"Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!\");\n  \t\t}\n\n  \t\tthis.origin.set(this.keypath, value);\n  \t},\n\n  \tunbind: function (keepLocal) {\n  \t\tvar _this = this;\n\n  \t\tif (!keepLocal) {\n  \t\t\tdelete this.local.mappings[this.localKey];\n  \t\t}\n\n  \t\tif (!this.resolved) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.deps.forEach(function (d) {\n  \t\t\t_this.origin.unregister(_this.map(d.keypath), d.dep, d.group);\n  \t\t});\n\n  \t\tif (this.tracker) {\n  \t\t\tthis.origin.unregister(this.keypath, this.tracker);\n  \t\t}\n  \t},\n\n  \tunregister: function (keypath, dependant, group) {\n  \t\tvar deps, i;\n\n  \t\tif (!this.resolved) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tdeps = this.deps;\n  \t\ti = deps.length;\n\n  \t\twhile (i--) {\n  \t\t\tif (deps[i].dep === dependant) {\n  \t\t\t\tdeps.splice(i, 1);\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t\tthis.origin.unregister(this.map(keypath), dependant, group);\n  \t}\n  };\n\n  var mark = Viewmodel$mark;\n\n  function Viewmodel$mark(keypath, options) {\n  \tvar computation,\n  \t    keypathStr = keypath.str;\n\n  \t// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)\n  \t// should not be picked up by pattern observers\n  \tif (options) {\n  \t\tif (options.implicit) {\n  \t\t\tthis.implicitChanges[keypathStr] = true;\n  \t\t}\n  \t\tif (options.noCascade) {\n  \t\t\tthis.noCascade[keypathStr] = true;\n  \t\t}\n  \t}\n\n  \tif (computation = this.computations[keypathStr]) {\n  \t\tcomputation.invalidate();\n  \t}\n\n  \tif (this.changes.indexOf(keypath) === -1) {\n  \t\tthis.changes.push(keypath);\n  \t}\n\n  \t// pass on keepExistingWrapper, if we can\n  \tvar keepExistingWrapper = options ? options.keepExistingWrapper : false;\n\n  \tthis.clearCache(keypathStr, keepExistingWrapper);\n\n  \tif (this.ready) {\n  \t\tthis.onchange();\n  \t}\n  }\n\n  var mapOldToNewIndex = function (oldArray, newArray) {\n  \tvar usedIndices, firstUnusedIndex, newIndices, changed;\n\n  \tusedIndices = {};\n  \tfirstUnusedIndex = 0;\n\n  \tnewIndices = oldArray.map(function (item, i) {\n  \t\tvar index, start, len;\n\n  \t\tstart = firstUnusedIndex;\n  \t\tlen = newArray.length;\n\n  \t\tdo {\n  \t\t\tindex = newArray.indexOf(item, start);\n\n  \t\t\tif (index === -1) {\n  \t\t\t\tchanged = true;\n  \t\t\t\treturn -1;\n  \t\t\t}\n\n  \t\t\tstart = index + 1;\n  \t\t} while (usedIndices[index] && start < len);\n\n  \t\t// keep track of the first unused index, so we don't search\n  \t\t// the whole of newArray for each item in oldArray unnecessarily\n  \t\tif (index === firstUnusedIndex) {\n  \t\t\tfirstUnusedIndex += 1;\n  \t\t}\n\n  \t\tif (index !== i) {\n  \t\t\tchanged = true;\n  \t\t}\n\n  \t\tusedIndices[index] = true;\n  \t\treturn index;\n  \t});\n\n  \treturn newIndices;\n  };\n\n  var merge = Viewmodel$merge;\n\n  var comparators = {};\n  function Viewmodel$merge(keypath, currentArray, array, options) {\n  \tvar oldArray, newArray, comparator, newIndices;\n\n  \tthis.mark(keypath);\n\n  \tif (options && options.compare) {\n\n  \t\tcomparator = getComparatorFunction(options.compare);\n\n  \t\ttry {\n  \t\t\toldArray = currentArray.map(comparator);\n  \t\t\tnewArray = array.map(comparator);\n  \t\t} catch (err) {\n  \t\t\t// fallback to an identity check - worst case scenario we have\n  \t\t\t// to do more DOM manipulation than we thought...\n  \t\t\twarnIfDebug(\"merge(): \\\"%s\\\" comparison failed. Falling back to identity checking\", keypath);\n\n  \t\t\toldArray = currentArray;\n  \t\t\tnewArray = array;\n  \t\t}\n  \t} else {\n  \t\toldArray = currentArray;\n  \t\tnewArray = array;\n  \t}\n\n  \t// find new indices for members of oldArray\n  \tnewIndices = mapOldToNewIndex(oldArray, newArray);\n\n  \tthis.smartUpdate(keypath, array, newIndices, currentArray.length !== array.length);\n  }\n\n  function stringify(item) {\n  \treturn JSON.stringify(item);\n  }\n\n  function getComparatorFunction(comparator) {\n  \t// If `compare` is `true`, we use JSON.stringify to compare\n  \t// objects that are the same shape, but non-identical - i.e.\n  \t// { foo: 'bar' } !== { foo: 'bar' }\n  \tif (comparator === true) {\n  \t\treturn stringify;\n  \t}\n\n  \tif (typeof comparator === \"string\") {\n  \t\tif (!comparators[comparator]) {\n  \t\t\tcomparators[comparator] = function (item) {\n  \t\t\t\treturn item[comparator];\n  \t\t\t};\n  \t\t}\n\n  \t\treturn comparators[comparator];\n  \t}\n\n  \tif (typeof comparator === \"function\") {\n  \t\treturn comparator;\n  \t}\n\n  \tthrow new Error(\"The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)\");\n  }\n\n  var register = Viewmodel$register;\n\n  function Viewmodel$register(keypath, dependant) {\n  \tvar group = arguments[2] === undefined ? \"default\" : arguments[2];\n\n  \tvar mapping, depsByKeypath, deps;\n\n  \tif (dependant.isStatic) {\n  \t\treturn; // TODO we should never get here if a dependant is static...\n  \t}\n\n  \tif (mapping = this.mappings[keypath.firstKey]) {\n  \t\tmapping.register(keypath, dependant, group);\n  \t} else {\n  \t\tdepsByKeypath = this.deps[group] || (this.deps[group] = {});\n  \t\tdeps = depsByKeypath[keypath.str] || (depsByKeypath[keypath.str] = []);\n\n  \t\tdeps.push(dependant);\n\n  \t\tif (!this.depsMap[group]) {\n  \t\t\tthis.depsMap[group] = {};\n  \t\t}\n\n  \t\tif (!keypath.isRoot) {\n  \t\t\tregister__updateDependantsMap(this, keypath, group);\n  \t\t}\n  \t}\n  }\n\n  function register__updateDependantsMap(viewmodel, keypath, group) {\n  \tvar map, parent, keypathStr;\n\n  \t// update dependants map\n  \twhile (!keypath.isRoot) {\n  \t\tmap = viewmodel.depsMap[group];\n  \t\tparent = map[keypath.parent.str] || (map[keypath.parent.str] = []);\n\n  \t\tkeypathStr = keypath.str;\n\n  \t\t// TODO find an alternative to this nasty approach\n  \t\tif (parent[\"_\" + keypathStr] === undefined) {\n  \t\t\tparent[\"_\" + keypathStr] = 0;\n  \t\t\tparent.push(keypath);\n  \t\t}\n\n  \t\tparent[\"_\" + keypathStr] += 1;\n  \t\tkeypath = keypath.parent;\n  \t}\n  }\n\n  var release = Viewmodel$release;\n\n  function Viewmodel$release() {\n  \treturn this.captureGroups.pop();\n  }\n\n  var reset = Viewmodel$reset;\n\n  function Viewmodel$reset(data) {\n  \tthis.data = data;\n  \tthis.clearCache(\"\");\n  }\n\n  var prototype_set = Viewmodel$set;\n\n  function Viewmodel$set(keypath, value) {\n  \tvar options = arguments[2] === undefined ? {} : arguments[2];\n\n  \tvar mapping, computation, wrapper, keepExistingWrapper;\n\n  \t// unless data is being set for data tracking purposes\n  \tif (!options.noMapping) {\n  \t\t// If this data belongs to a different viewmodel,\n  \t\t// pass the change along\n  \t\tif (mapping = this.mappings[keypath.firstKey]) {\n  \t\t\treturn mapping.set(keypath, value);\n  \t\t}\n  \t}\n\n  \tcomputation = this.computations[keypath.str];\n  \tif (computation) {\n  \t\tif (computation.setting) {\n  \t\t\t// let the other computation set() handle things...\n  \t\t\treturn;\n  \t\t}\n  \t\tcomputation.set(value);\n  \t\tvalue = computation.get();\n  \t}\n\n  \tif (isEqual(this.cache[keypath.str], value)) {\n  \t\treturn;\n  \t}\n\n  \twrapper = this.wrapped[keypath.str];\n\n  \t// If we have a wrapper with a `reset()` method, we try and use it. If the\n  \t// `reset()` method returns false, the wrapper should be torn down, and\n  \t// (most likely) a new one should be created later\n  \tif (wrapper && wrapper.reset) {\n  \t\tkeepExistingWrapper = wrapper.reset(value) !== false;\n\n  \t\tif (keepExistingWrapper) {\n  \t\t\tvalue = wrapper.get();\n  \t\t}\n  \t}\n\n  \tif (!computation && !keepExistingWrapper) {\n  \t\tresolveSet(this, keypath, value);\n  \t}\n\n  \tif (!options.silent) {\n  \t\tthis.mark(keypath);\n  \t} else {\n  \t\t// We're setting a parent of the original target keypath (i.e.\n  \t\t// creating a fresh branch) - we need to clear the cache, but\n  \t\t// not mark it as a change\n  \t\tthis.clearCache(keypath.str);\n  \t}\n  }\n\n  function resolveSet(viewmodel, keypath, value) {\n  \tvar wrapper, parentValue, wrapperSet, valueSet;\n\n  \twrapperSet = function () {\n  \t\tif (wrapper.set) {\n  \t\t\twrapper.set(keypath.lastKey, value);\n  \t\t} else {\n  \t\t\tparentValue = wrapper.get();\n  \t\t\tvalueSet();\n  \t\t}\n  \t};\n\n  \tvalueSet = function () {\n  \t\tif (!parentValue) {\n  \t\t\tparentValue = createBranch(keypath.lastKey);\n  \t\t\tviewmodel.set(keypath.parent, parentValue, { silent: true });\n  \t\t}\n  \t\tparentValue[keypath.lastKey] = value;\n  \t};\n\n  \twrapper = viewmodel.wrapped[keypath.parent.str];\n\n  \tif (wrapper) {\n  \t\twrapperSet();\n  \t} else {\n  \t\tparentValue = viewmodel.get(keypath.parent);\n\n  \t\t// may have been wrapped via the above .get()\n  \t\t// call on viewmodel if this is first access via .set()!\n  \t\tif (wrapper = viewmodel.wrapped[keypath.parent.str]) {\n  \t\t\twrapperSet();\n  \t\t} else {\n  \t\t\tvalueSet();\n  \t\t}\n  \t}\n  }\n\n  var smartUpdate = Viewmodel$smartUpdate;\n\n  var implicitOption = { implicit: true },\n      noCascadeOption = { noCascade: true };\n  function Viewmodel$smartUpdate(keypath, array, newIndices) {\n  \tvar _this = this;\n\n  \tvar dependants, oldLength, i;\n\n  \toldLength = newIndices.length;\n\n  \t// Indices that are being removed should be marked as dirty\n  \tnewIndices.forEach(function (newIndex, oldIndex) {\n  \t\tif (newIndex === -1) {\n  \t\t\t_this.mark(keypath.join(oldIndex), noCascadeOption);\n  \t\t}\n  \t});\n\n  \t// Update the model\n  \t// TODO allow existing array to be updated in place, rather than replaced?\n  \tthis.set(keypath, array, { silent: true });\n\n  \tif (dependants = this.deps[\"default\"][keypath.str]) {\n  \t\tdependants.filter(canShuffle).forEach(function (d) {\n  \t\t\treturn d.shuffle(newIndices, array);\n  \t\t});\n  \t}\n\n  \tif (oldLength !== array.length) {\n  \t\tthis.mark(keypath.join(\"length\"), implicitOption);\n\n  \t\tfor (i = newIndices.touchedFrom; i < array.length; i += 1) {\n  \t\t\tthis.mark(keypath.join(i));\n  \t\t}\n\n  \t\t// don't allow removed indexes beyond end of new array to trigger recomputations\n  \t\t// TODO is this still necessary, now that computations are lazy?\n  \t\tfor (i = array.length; i < oldLength; i += 1) {\n  \t\t\tthis.mark(keypath.join(i), noCascadeOption);\n  \t\t}\n  \t}\n  }\n\n  function canShuffle(dependant) {\n  \treturn typeof dependant.shuffle === \"function\";\n  }\n\n  var prototype_teardown = Viewmodel$teardown;\n\n  function Viewmodel$teardown() {\n  \tvar _this = this;\n\n  \tvar unresolvedImplicitDependency;\n\n  \t// Clear entire cache - this has the desired side-effect\n  \t// of unwrapping adapted values (e.g. arrays)\n  \tObject.keys(this.cache).forEach(function (keypath) {\n  \t\treturn _this.clearCache(keypath);\n  \t});\n\n  \t// Teardown any failed lookups - we don't need them to resolve any more\n  \twhile (unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop()) {\n  \t\tunresolvedImplicitDependency.teardown();\n  \t}\n  }\n\n  var unregister = Viewmodel$unregister;\n\n  function Viewmodel$unregister(keypath, dependant) {\n  \tvar group = arguments[2] === undefined ? \"default\" : arguments[2];\n\n  \tvar mapping, deps, index;\n\n  \tif (dependant.isStatic) {\n  \t\treturn;\n  \t}\n\n  \tif (mapping = this.mappings[keypath.firstKey]) {\n  \t\treturn mapping.unregister(keypath, dependant, group);\n  \t}\n\n  \tdeps = this.deps[group][keypath.str];\n  \tindex = deps.indexOf(dependant);\n\n  \tif (index === -1) {\n  \t\tthrow new Error(\"Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks\");\n  \t}\n\n  \tdeps.splice(index, 1);\n\n  \tif (keypath.isRoot) {\n  \t\treturn;\n  \t}\n\n  \tunregister__updateDependantsMap(this, keypath, group);\n  }\n\n  function unregister__updateDependantsMap(viewmodel, keypath, group) {\n  \tvar map, parent;\n\n  \t// update dependants map\n  \twhile (!keypath.isRoot) {\n  \t\tmap = viewmodel.depsMap[group];\n  \t\tparent = map[keypath.parent.str];\n\n  \t\tparent[\"_\" + keypath.str] -= 1;\n\n  \t\tif (!parent[\"_\" + keypath.str]) {\n  \t\t\t// remove from parent deps map\n  \t\t\tremoveFromArray(parent, keypath);\n  \t\t\tparent[\"_\" + keypath.str] = undefined;\n  \t\t}\n\n  \t\tkeypath = keypath.parent;\n  \t}\n  }\n\n  var Viewmodel = function (options) {\n  \tvar adapt = options.adapt;\n  \tvar data = options.data;\n  \tvar ractive = options.ractive;\n  \tvar computed = options.computed;\n  \tvar mappings = options.mappings;\n  \tvar key;\n  \tvar mapping;\n\n  \t// TODO is it possible to remove this reference?\n  \tthis.ractive = ractive;\n\n  \tthis.adaptors = adapt;\n  \tthis.onchange = options.onchange;\n\n  \tthis.cache = {}; // we need to be able to use hasOwnProperty, so can't inherit from null\n  \tthis.cacheMap = create(null);\n\n  \tthis.deps = {\n  \t\tcomputed: create(null),\n  \t\t\"default\": create(null)\n  \t};\n  \tthis.depsMap = {\n  \t\tcomputed: create(null),\n  \t\t\"default\": create(null)\n  \t};\n\n  \tthis.patternObservers = [];\n\n  \tthis.specials = create(null);\n\n  \tthis.wrapped = create(null);\n  \tthis.computations = create(null);\n\n  \tthis.captureGroups = [];\n  \tthis.unresolvedImplicitDependencies = [];\n\n  \tthis.changes = [];\n  \tthis.implicitChanges = {};\n  \tthis.noCascade = {};\n\n  \tthis.data = data;\n\n  \t// set up explicit mappings\n  \tthis.mappings = create(null);\n  \tfor (key in mappings) {\n  \t\tthis.map(getKeypath(key), mappings[key]);\n  \t}\n\n  \tif (data) {\n  \t\t// if data exists locally, but is missing on the parent,\n  \t\t// we transfer ownership to the parent\n  \t\tfor (key in data) {\n  \t\t\tif ((mapping = this.mappings[key]) && mapping.getValue() === undefined) {\n  \t\t\t\tmapping.setValue(data[key]);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tfor (key in computed) {\n  \t\tif (mappings && key in mappings) {\n  \t\t\tfatal(\"Cannot map to a computed property ('%s')\", key);\n  \t\t}\n\n  \t\tthis.compute(getKeypath(key), computed[key]);\n  \t}\n\n  \tthis.ready = true;\n  };\n\n  Viewmodel.prototype = {\n  \tadapt: prototype_adapt,\n  \tapplyChanges: applyChanges,\n  \tcapture: capture,\n  \tclearCache: clearCache,\n  \tcompute: compute,\n  \tget: viewmodel_prototype_get,\n  \tinit: viewmodel_prototype_init,\n  \tmap: prototype_map,\n  \tmark: mark,\n  \tmerge: merge,\n  \tregister: register,\n  \trelease: release,\n  \treset: reset,\n  \tset: prototype_set,\n  \tsmartUpdate: smartUpdate,\n  \tteardown: prototype_teardown,\n  \tunregister: unregister\n  };\n\n  var viewmodel_Viewmodel = Viewmodel;\n\n  function HookQueue(event) {\n  \tthis.hook = new hooks_Hook(event);\n  \tthis.inProcess = {};\n  \tthis.queue = {};\n  }\n\n  HookQueue.prototype = {\n\n  \tconstructor: HookQueue,\n\n  \tbegin: function (ractive) {\n  \t\tthis.inProcess[ractive._guid] = true;\n  \t},\n\n  \tend: function (ractive) {\n\n  \t\tvar parent = ractive.parent;\n\n  \t\t// If this is *isn't* a child of a component that's in process,\n  \t\t// it should call methods or fire at this point\n  \t\tif (!parent || !this.inProcess[parent._guid]) {\n  \t\t\tfire(this, ractive);\n  \t\t}\n  \t\t// elsewise, handoff to parent to fire when ready\n  \t\telse {\n  \t\t\tgetChildQueue(this.queue, parent).push(ractive);\n  \t\t}\n\n  \t\tdelete this.inProcess[ractive._guid];\n  \t}\n  };\n\n  function getChildQueue(queue, ractive) {\n  \treturn queue[ractive._guid] || (queue[ractive._guid] = []);\n  }\n\n  function fire(hookQueue, ractive) {\n\n  \tvar childQueue = getChildQueue(hookQueue.queue, ractive);\n\n  \thookQueue.hook.fire(ractive);\n\n  \t// queue is \"live\" because components can end up being\n  \t// added while hooks fire on parents that modify data values.\n  \twhile (childQueue.length) {\n  \t\tfire(hookQueue, childQueue.shift());\n  \t}\n\n  \tdelete hookQueue.queue[ractive._guid];\n  }\n\n  var hooks_HookQueue = HookQueue;\n\n  var helpers_getComputationSignatures = getComputationSignatures;\n\n  var helpers_getComputationSignatures__pattern = /\\$\\{([^\\}]+)\\}/g;\n  function getComputationSignatures(ractive, computed) {\n  \tvar signatures = {},\n  \t    key;\n\n  \tfor (key in computed) {\n  \t\tsignatures[key] = getComputationSignature(ractive, key, computed[key]);\n  \t}\n\n  \treturn signatures;\n  }\n\n  function getComputationSignature(ractive, key, signature) {\n  \tvar getter, setter;\n\n  \tif (typeof signature === \"function\") {\n  \t\tgetter = helpers_getComputationSignatures__bind(signature, ractive);\n  \t}\n\n  \tif (typeof signature === \"string\") {\n  \t\tgetter = createFunctionFromString(ractive, signature);\n  \t}\n\n  \tif (typeof signature === \"object\") {\n  \t\tif (typeof signature.get === \"string\") {\n  \t\t\tgetter = createFunctionFromString(ractive, signature.get);\n  \t\t} else if (typeof signature.get === \"function\") {\n  \t\t\tgetter = helpers_getComputationSignatures__bind(signature.get, ractive);\n  \t\t} else {\n  \t\t\tfatal(\"`%s` computation must have a `get()` method\", key);\n  \t\t}\n\n  \t\tif (typeof signature.set === \"function\") {\n  \t\t\tsetter = helpers_getComputationSignatures__bind(signature.set, ractive);\n  \t\t}\n  \t}\n\n  \treturn { getter: getter, setter: setter };\n  }\n\n  function createFunctionFromString(ractive, str) {\n  \tvar functionBody, hasThis, fn;\n\n  \tfunctionBody = \"return (\" + str.replace(helpers_getComputationSignatures__pattern, function (match, keypath) {\n  \t\thasThis = true;\n  \t\treturn \"__ractive.get(\\\"\" + keypath + \"\\\")\";\n  \t}) + \");\";\n\n  \tif (hasThis) {\n  \t\tfunctionBody = \"var __ractive = this; \" + functionBody;\n  \t}\n\n  \tfn = new Function(functionBody);\n  \treturn hasThis ? fn.bind(ractive) : fn;\n  }\n\n  function helpers_getComputationSignatures__bind(fn, context) {\n  \treturn /this/.test(fn.toString()) ? fn.bind(context) : fn;\n  }\n\n  var constructHook = new hooks_Hook(\"construct\");\n  var configHook = new hooks_Hook(\"config\");\n  var initHook = new hooks_HookQueue(\"init\");\n  var initialise__uid = 0;\n\n  var initialise__registryNames = [\"adaptors\", \"components\", \"decorators\", \"easing\", \"events\", \"interpolators\", \"partials\", \"transitions\"];\n\n  var initialise = initialiseRactiveInstance;\n\n  function initialiseRactiveInstance(ractive) {\n  \tvar userOptions = arguments[1] === undefined ? {} : arguments[1];\n  \tvar options = arguments[2] === undefined ? {} : arguments[2];\n\n  \tvar el, viewmodel;\n\n  \tif (_Ractive.DEBUG) {\n  \t\twelcome();\n  \t}\n\n  \tinitialiseProperties(ractive, options);\n\n  \t// TODO remove this, eventually\n  \tdefineProperty(ractive, \"data\", { get: deprecateRactiveData });\n\n  \t// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it\n  \tconstructHook.fire(ractive, userOptions);\n\n  \t// Add registries\n  \tinitialise__registryNames.forEach(function (name) {\n  \t\tractive[name] = utils_object__extend(create(ractive.constructor[name] || null), userOptions[name]);\n  \t});\n\n  \t// Create a viewmodel\n  \tviewmodel = new viewmodel_Viewmodel({\n  \t\tadapt: getAdaptors(ractive, ractive.adapt, userOptions),\n  \t\tdata: custom_data.init(ractive.constructor, ractive, userOptions),\n  \t\tcomputed: helpers_getComputationSignatures(ractive, utils_object__extend(create(ractive.constructor.prototype.computed), userOptions.computed)),\n  \t\tmappings: options.mappings,\n  \t\tractive: ractive,\n  \t\tonchange: function () {\n  \t\t\treturn global_runloop.addRactive(ractive);\n  \t\t}\n  \t});\n\n  \tractive.viewmodel = viewmodel;\n\n  \t// This can't happen earlier, because computed properties may call `ractive.get()`, etc\n  \tviewmodel.init();\n\n  \t// init config from Parent and options\n  \tconfig_config.init(ractive.constructor, ractive, userOptions);\n\n  \tconfigHook.fire(ractive);\n  \tinitHook.begin(ractive);\n\n  \t// // If this is a component with a function `data` property, call the function\n  \t// // with `ractive` as context (unless the child was also a function)\n  \t// if ( typeof ractive.constructor.prototype.data === 'function' && typeof userOptions.data !== 'function' ) {\n  \t// \tviewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( '`data` functions must return a data object' ) );\n  \t// }\n\n  \t// Render virtual DOM\n  \tif (ractive.template) {\n  \t\tvar cssIds = undefined;\n\n  \t\tif (options.cssIds || ractive.cssId) {\n  \t\t\tcssIds = options.cssIds ? options.cssIds.slice() : [];\n\n  \t\t\tif (ractive.cssId) {\n  \t\t\t\tcssIds.push(ractive.cssId);\n  \t\t\t}\n  \t\t}\n\n  \t\tractive.fragment = new virtualdom_Fragment({\n  \t\t\ttemplate: ractive.template,\n  \t\t\troot: ractive,\n  \t\t\towner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on\n  \t\t\tcssIds: cssIds\n  \t\t});\n  \t}\n\n  \tinitHook.end(ractive);\n\n  \t// render automatically ( if `el` is specified )\n  \tif (el = getElement(ractive.el)) {\n  \t\tvar promise = ractive.render(el, ractive.append);\n\n  \t\tif (_Ractive.DEBUG_PROMISES) {\n  \t\t\tpromise[\"catch\"](function (err) {\n  \t\t\t\twarnOnceIfDebug(\"Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;\");\n  \t\t\t\twarnIfDebug(\"An error happened during rendering\", { ractive: ractive });\n  \t\t\t\terr.stack && logIfDebug(err.stack);\n\n  \t\t\t\tthrow err;\n  \t\t\t});\n  \t\t}\n  \t}\n  }\n\n  function getAdaptors(ractive, protoAdapt, userOptions) {\n  \tvar adapt, magic, modifyArrays;\n\n  \tprotoAdapt = protoAdapt.map(lookup);\n  \tadapt = ensureArray(userOptions.adapt).map(lookup);\n\n  \tadapt = initialise__combine(protoAdapt, adapt);\n\n  \tmagic = \"magic\" in userOptions ? userOptions.magic : ractive.magic;\n  \tmodifyArrays = \"modifyArrays\" in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;\n\n  \tif (magic) {\n  \t\tif (!environment__magic) {\n  \t\t\tthrow new Error(\"Getters and setters (magic mode) are not supported in this browser\");\n  \t\t}\n\n  \t\tif (modifyArrays) {\n  \t\t\tadapt.push(magicArray);\n  \t\t}\n\n  \t\tadapt.push(adaptors_magic);\n  \t}\n\n  \tif (modifyArrays) {\n  \t\tadapt.push(array_index);\n  \t}\n\n  \treturn adapt;\n\n  \tfunction lookup(adaptor) {\n  \t\tif (typeof adaptor === \"string\") {\n  \t\t\tadaptor = findInViewHierarchy(\"adaptors\", ractive, adaptor);\n\n  \t\t\tif (!adaptor) {\n  \t\t\t\tfatal(missingPlugin(adaptor, \"adaptor\"));\n  \t\t\t}\n  \t\t}\n\n  \t\treturn adaptor;\n  \t}\n  }\n\n  function initialise__combine(a, b) {\n  \tvar c = a.slice(),\n  \t    i = b.length;\n\n  \twhile (i--) {\n  \t\tif (! ~c.indexOf(b[i])) {\n  \t\t\tc.push(b[i]);\n  \t\t}\n  \t}\n\n  \treturn c;\n  }\n\n  function initialiseProperties(ractive, options) {\n  \t// Generate a unique identifier, for places where you'd use a weak map if it\n  \t// existed\n  \tractive._guid = \"r-\" + initialise__uid++;\n\n  \t// events\n  \tractive._subs = create(null);\n\n  \t// storage for item configuration from instantiation to reset,\n  \t// like dynamic functions or original values\n  \tractive._config = {};\n\n  \t// two-way bindings\n  \tractive._twowayBindings = create(null);\n\n  \t// animations (so we can stop any in progress at teardown)\n  \tractive._animations = [];\n\n  \t// nodes registry\n  \tractive.nodes = {};\n\n  \t// live queries\n  \tractive._liveQueries = [];\n  \tractive._liveComponentQueries = [];\n\n  \t// bound data functions\n  \tractive._boundFunctions = [];\n\n  \t// observers\n  \tractive._observers = [];\n\n  \t// properties specific to inline components\n  \tif (options.component) {\n  \t\tractive.parent = options.parent;\n  \t\tractive.container = options.container || null;\n  \t\tractive.root = ractive.parent.root;\n\n  \t\tractive.component = options.component;\n  \t\toptions.component.instance = ractive;\n\n  \t\t// for hackability, this could be an open option\n  \t\t// for any ractive instance, but for now, just\n  \t\t// for components and just for ractive...\n  \t\tractive._inlinePartials = options.inlinePartials;\n  \t} else {\n  \t\tractive.root = ractive;\n  \t\tractive.parent = ractive.container = null;\n  \t}\n  }\n\n  function deprecateRactiveData() {\n  \tthrow new Error(\"Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead\");\n  }\n\n  function ComplexParameter(component, template, callback) {\n  \tthis.parentFragment = component.parentFragment;\n  \tthis.callback = callback;\n\n  \tthis.fragment = new virtualdom_Fragment({\n  \t\ttemplate: template,\n  \t\troot: component.root,\n  \t\towner: this\n  \t});\n\n  \tthis.update();\n  }\n\n  var initialise_ComplexParameter = ComplexParameter;\n\n  ComplexParameter.prototype = {\n  \tbubble: function () {\n  \t\tif (!this.dirty) {\n  \t\t\tthis.dirty = true;\n  \t\t\tglobal_runloop.addView(this);\n  \t\t}\n  \t},\n\n  \tupdate: function () {\n  \t\tthis.callback(this.fragment.getValue());\n  \t\tthis.dirty = false;\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t},\n\n  \tunbind: function () {\n  \t\tthis.fragment.unbind();\n  \t}\n  };\n\n  var createInstance = function (component, Component, attributes, yieldTemplate, partials) {\n  \tvar instance,\n  \t    parentFragment,\n  \t    ractive,\n  \t    fragment,\n  \t    container,\n  \t    inlinePartials = {},\n  \t    data = {},\n  \t    mappings = {},\n  \t    ready,\n  \t    resolvers = [];\n\n  \tparentFragment = component.parentFragment;\n  \tractive = component.root;\n\n  \tpartials = partials || {};\n  \tutils_object__extend(inlinePartials, partials);\n\n  \t// Make contents available as a {{>content}} partial\n  \tpartials.content = yieldTemplate || [];\n\n  \t// set a default partial for yields with no name\n  \tinlinePartials[\"\"] = partials.content;\n\n  \tif (Component.defaults.el) {\n  \t\twarnIfDebug(\"The <%s/> component has a default `el` property; it has been disregarded\", component.name);\n  \t}\n\n  \t// find container\n  \tfragment = parentFragment;\n  \twhile (fragment) {\n  \t\tif (fragment.owner.type === YIELDER) {\n  \t\t\tcontainer = fragment.owner.container;\n  \t\t\tbreak;\n  \t\t}\n\n  \t\tfragment = fragment.parent;\n  \t}\n\n  \t// each attribute represents either a) data or b) a mapping\n  \tif (attributes) {\n  \t\tObject.keys(attributes).forEach(function (key) {\n  \t\t\tvar attribute = attributes[key],\n  \t\t\t    parsed,\n  \t\t\t    resolver;\n\n  \t\t\tif (typeof attribute === \"string\") {\n  \t\t\t\t// it's static data\n  \t\t\t\tparsed = parseJSON(attribute);\n  \t\t\t\tdata[key] = parsed ? parsed.value : attribute;\n  \t\t\t} else if (attribute === 0) {\n  \t\t\t\t// it had no '=', so we'll call it true\n  \t\t\t\tdata[key] = true;\n  \t\t\t} else if (isArray(attribute)) {\n  \t\t\t\t// this represents dynamic data\n  \t\t\t\tif (isSingleInterpolator(attribute)) {\n  \t\t\t\t\tmappings[key] = {\n  \t\t\t\t\t\torigin: component.root.viewmodel,\n  \t\t\t\t\t\tkeypath: undefined\n  \t\t\t\t\t};\n\n  \t\t\t\t\tresolver = createResolver(component, attribute[0], function (keypath) {\n  \t\t\t\t\t\tif (keypath.isSpecial) {\n  \t\t\t\t\t\t\tif (ready) {\n  \t\t\t\t\t\t\t\tinstance.set(key, keypath.value); // TODO use viewmodel?\n  \t\t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\t\tdata[key] = keypath.value;\n\n  \t\t\t\t\t\t\t\t// TODO errr.... would be better if we didn't have to do this\n  \t\t\t\t\t\t\t\tdelete mappings[key];\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\tif (ready) {\n  \t\t\t\t\t\t\t\tinstance.viewmodel.mappings[key].resolve(keypath);\n  \t\t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\t\t// resolved immediately\n  \t\t\t\t\t\t\t\tmappings[key].keypath = keypath;\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t}\n  \t\t\t\t\t});\n  \t\t\t\t} else {\n  \t\t\t\t\tresolver = new initialise_ComplexParameter(component, attribute, function (value) {\n  \t\t\t\t\t\tif (ready) {\n  \t\t\t\t\t\t\tinstance.set(key, value); // TODO use viewmodel?\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\tdata[key] = value;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t});\n  \t\t\t\t}\n\n  \t\t\t\tresolvers.push(resolver);\n  \t\t\t} else {\n  \t\t\t\tthrow new Error(\"erm wut\");\n  \t\t\t}\n  \t\t});\n  \t}\n\n  \tinstance = create(Component.prototype);\n\n  \tinitialise(instance, {\n  \t\tel: null,\n  \t\tappend: true,\n  \t\tdata: data,\n  \t\tpartials: partials,\n  \t\tmagic: ractive.magic || Component.defaults.magic,\n  \t\tmodifyArrays: ractive.modifyArrays,\n  \t\t// need to inherit runtime parent adaptors\n  \t\tadapt: ractive.adapt\n  \t}, {\n  \t\tparent: ractive,\n  \t\tcomponent: component,\n  \t\tcontainer: container,\n  \t\tmappings: mappings,\n  \t\tinlinePartials: inlinePartials,\n  \t\tcssIds: parentFragment.cssIds\n  \t});\n\n  \tready = true;\n  \tcomponent.resolvers = resolvers;\n\n  \treturn instance;\n  };\n\n  function createResolver(component, template, callback) {\n  \tvar resolver;\n\n  \tif (template.r) {\n  \t\tresolver = Resolvers_createReferenceResolver(component, template.r, callback);\n  \t} else if (template.x) {\n  \t\tresolver = new Resolvers_ExpressionResolver(component, component.parentFragment, template.x, callback);\n  \t} else if (template.rx) {\n  \t\tresolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(component, template.rx, callback);\n  \t}\n\n  \treturn resolver;\n  }\n\n  function isSingleInterpolator(template) {\n  \treturn template.length === 1 && template[0].t === INTERPOLATOR;\n  }\n\n  // TODO how should event arguments be handled? e.g.\n  // <widget on-foo='bar:1,2,3'/>\n  // The event 'bar' will be fired on the parent instance\n  // when 'foo' fires on the child, but the 1,2,3 arguments\n  // will be lost\n\n  var initialise_propagateEvents = propagateEvents;\n\n  function propagateEvents(component, eventsDescriptor) {\n  \tvar eventName;\n\n  \tfor (eventName in eventsDescriptor) {\n  \t\tif (eventsDescriptor.hasOwnProperty(eventName)) {\n  \t\t\tpropagateEvent(component.instance, component.root, eventName, eventsDescriptor[eventName]);\n  \t\t}\n  \t}\n  }\n\n  function propagateEvent(childInstance, parentInstance, eventName, proxyEventName) {\n  \tif (typeof proxyEventName !== \"string\") {\n  \t\tfatal(\"Components currently only support simple events - you cannot include arguments. Sorry!\");\n  \t}\n\n  \tchildInstance.on(eventName, function () {\n  \t\tvar event, args;\n\n  \t\t// semi-weak test, but what else? tag the event obj ._isEvent ?\n  \t\tif (arguments.length && arguments[0] && arguments[0].node) {\n  \t\t\tevent = Array.prototype.shift.call(arguments);\n  \t\t}\n\n  \t\targs = Array.prototype.slice.call(arguments);\n\n  \t\tshared_fireEvent(parentInstance, proxyEventName, { event: event, args: args });\n\n  \t\t// cancel bubbling\n  \t\treturn false;\n  \t});\n  }\n\n  var initialise_updateLiveQueries = function (component) {\n  \tvar ancestor, query;\n\n  \t// If there's a live query for this component type, add it\n  \tancestor = component.root;\n  \twhile (ancestor) {\n  \t\tif (query = ancestor._liveComponentQueries[\"_\" + component.name]) {\n  \t\t\tquery.push(component.instance);\n  \t\t}\n\n  \t\tancestor = ancestor.parent;\n  \t}\n  };\n\n  var Component_prototype_init = Component$init;\n  function Component$init(options, Component) {\n  \tvar parentFragment, root;\n\n  \tif (!Component) {\n  \t\tthrow new Error(\"Component \\\"\" + this.name + \"\\\" not found\");\n  \t}\n\n  \tparentFragment = this.parentFragment = options.parentFragment;\n  \troot = parentFragment.root;\n\n  \tthis.root = root;\n  \tthis.type = COMPONENT;\n  \tthis.name = options.template.e;\n  \tthis.index = options.index;\n  \tthis.indexRefBindings = {};\n  \tthis.yielders = {};\n  \tthis.resolvers = [];\n\n  \tcreateInstance(this, Component, options.template.a, options.template.f, options.template.p);\n  \tinitialise_propagateEvents(this, options.template.v);\n\n  \t// intro, outro and decorator directives have no effect\n  \tif (options.template.t0 || options.template.t1 || options.template.t2 || options.template.o) {\n  \t\twarnIfDebug(\"The \\\"intro\\\", \\\"outro\\\" and \\\"decorator\\\" directives have no effect on components\", { ractive: this.instance });\n  \t}\n\n  \tinitialise_updateLiveQueries(this);\n  }\n\n  var Component_prototype_rebind = Component$rebind;\n\n  function Component$rebind(oldKeypath, newKeypath) {\n  \tvar query;\n\n  \tthis.resolvers.forEach(rebind);\n\n  \tfor (var k in this.yielders) {\n  \t\tif (this.yielders[k][0]) {\n  \t\t\trebind(this.yielders[k][0]);\n  \t\t}\n  \t}\n\n  \tif (query = this.root._liveComponentQueries[\"_\" + this.name]) {\n  \t\tquery._makeDirty();\n  \t}\n\n  \tfunction rebind(x) {\n  \t\tx.rebind(oldKeypath, newKeypath);\n  \t}\n  }\n\n  var Component_prototype_render = Component$render;\n\n  function Component$render() {\n  \tvar instance = this.instance;\n\n  \tinstance.render(this.parentFragment.getNode());\n\n  \tthis.rendered = true;\n  \treturn instance.fragment.detach();\n  }\n\n  var Component_prototype_toString = Component$toString;\n\n  function Component$toString() {\n  \treturn this.instance.fragment.toString();\n  }\n\n  var Component_prototype_unbind = Component$unbind;\n\n  var Component_prototype_unbind__teardownHook = new hooks_Hook(\"teardown\");\n  function Component$unbind() {\n  \tvar instance = this.instance;\n\n  \tthis.resolvers.forEach(methodCallers__unbind);\n\n  \tremoveFromLiveComponentQueries(this);\n\n  \tinstance._observers.forEach(cancel);\n\n  \t// teardown the instance\n  \tinstance.fragment.unbind();\n  \tinstance.viewmodel.teardown();\n\n  \tif (instance.fragment.rendered && instance.el.__ractive_instances__) {\n  \t\tremoveFromArray(instance.el.__ractive_instances__, instance);\n  \t}\n\n  \tComponent_prototype_unbind__teardownHook.fire(instance);\n  }\n\n  function removeFromLiveComponentQueries(component) {\n  \tvar instance, query;\n\n  \tinstance = component.root;\n\n  \tdo {\n  \t\tif (query = instance._liveComponentQueries[\"_\" + component.name]) {\n  \t\t\tquery._remove(component);\n  \t\t}\n  \t} while (instance = instance.parent);\n  }\n\n  var Component_prototype_unrender = Component$unrender;\n\n  function Component$unrender(shouldDestroy) {\n  \tthis.shouldDestroy = shouldDestroy;\n  \tthis.instance.unrender();\n  }\n\n  var Component = function (options, Constructor) {\n  \tthis.init(options, Constructor);\n  };\n\n  Component.prototype = {\n  \tdetach: Component_prototype_detach,\n  \tfind: Component_prototype_find,\n  \tfindAll: Component_prototype_findAll,\n  \tfindAllComponents: Component_prototype_findAllComponents,\n  \tfindComponent: Component_prototype_findComponent,\n  \tfindNextNode: Component_prototype_findNextNode,\n  \tfirstNode: Component_prototype_firstNode,\n  \tinit: Component_prototype_init,\n  \trebind: Component_prototype_rebind,\n  \trender: Component_prototype_render,\n  \ttoString: Component_prototype_toString,\n  \tunbind: Component_prototype_unbind,\n  \tunrender: Component_prototype_unrender\n  };\n\n  var _Component = Component;\n\n  var Comment = function (options) {\n  \tthis.type = COMMENT;\n  \tthis.value = options.template.c;\n  };\n\n  Comment.prototype = {\n  \tdetach: shared_detach,\n\n  \tfirstNode: function () {\n  \t\treturn this.node;\n  \t},\n\n  \trender: function () {\n  \t\tif (!this.node) {\n  \t\t\tthis.node = document.createComment(this.value);\n  \t\t}\n\n  \t\treturn this.node;\n  \t},\n\n  \ttoString: function () {\n  \t\treturn \"<!--\" + this.value + \"-->\";\n  \t},\n\n  \tunrender: function (shouldDestroy) {\n  \t\tif (shouldDestroy) {\n  \t\t\tthis.node.parentNode.removeChild(this.node);\n  \t\t}\n  \t}\n  };\n\n  var items_Comment = Comment;\n\n  var Yielder = function (options) {\n  \tvar container, component;\n\n  \tthis.type = YIELDER;\n\n  \tthis.container = container = options.parentFragment.root;\n  \tthis.component = component = container.component;\n\n  \tthis.container = container;\n  \tthis.containerFragment = options.parentFragment;\n  \tthis.parentFragment = component.parentFragment;\n\n  \tvar name = this.name = options.template.n || \"\";\n\n  \tvar template = container._inlinePartials[name];\n\n  \tif (!template) {\n  \t\twarnIfDebug(\"Could not find template for partial \\\"\" + name + \"\\\"\", { ractive: options.root });\n  \t\ttemplate = [];\n  \t}\n\n  \tthis.fragment = new virtualdom_Fragment({\n  \t\towner: this,\n  \t\troot: container.parent,\n  \t\ttemplate: template,\n  \t\tpElement: this.containerFragment.pElement\n  \t});\n\n  \t// even though only one yielder is allowed, we need to have an array of them\n  \t// as it's possible to cause a yielder to be created before the last one\n  \t// was destroyed in the same turn of the runloop\n  \tif (!isArray(component.yielders[name])) {\n  \t\tcomponent.yielders[name] = [this];\n  \t} else {\n  \t\tcomponent.yielders[name].push(this);\n  \t}\n\n  \tglobal_runloop.scheduleTask(function () {\n  \t\tif (component.yielders[name].length > 1) {\n  \t\t\tthrow new Error(\"A component template can only have one {{yield\" + (name ? \" \" + name : \"\") + \"}} declaration at a time\");\n  \t\t}\n  \t});\n  };\n\n  Yielder.prototype = {\n  \tdetach: function () {\n  \t\treturn this.fragment.detach();\n  \t},\n\n  \tfind: function (selector) {\n  \t\treturn this.fragment.find(selector);\n  \t},\n\n  \tfindAll: function (selector, query) {\n  \t\treturn this.fragment.findAll(selector, query);\n  \t},\n\n  \tfindComponent: function (selector) {\n  \t\treturn this.fragment.findComponent(selector);\n  \t},\n\n  \tfindAllComponents: function (selector, query) {\n  \t\treturn this.fragment.findAllComponents(selector, query);\n  \t},\n\n  \tfindNextNode: function () {\n  \t\treturn this.containerFragment.findNextNode(this);\n  \t},\n\n  \tfirstNode: function () {\n  \t\treturn this.fragment.firstNode();\n  \t},\n\n  \tgetValue: function (options) {\n  \t\treturn this.fragment.getValue(options);\n  \t},\n\n  \trender: function () {\n  \t\treturn this.fragment.render();\n  \t},\n\n  \tunbind: function () {\n  \t\tthis.fragment.unbind();\n  \t},\n\n  \tunrender: function (shouldDestroy) {\n  \t\tthis.fragment.unrender(shouldDestroy);\n  \t\tremoveFromArray(this.component.yielders[this.name], this);\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t},\n\n  \ttoString: function () {\n  \t\treturn this.fragment.toString();\n  \t}\n  };\n\n  var items_Yielder = Yielder;\n\n  var Doctype = function (options) {\n  \tthis.declaration = options.template.a;\n  };\n\n  Doctype.prototype = {\n  \tinit: noop,\n  \trender: noop,\n  \tunrender: noop,\n  \tteardown: noop,\n  \ttoString: function () {\n  \t\treturn \"<!DOCTYPE\" + this.declaration + \">\";\n  \t}\n  };\n\n  var items_Doctype = Doctype;\n\n  var Fragment_prototype_init = Fragment$init;\n\n  function Fragment$init(options) {\n  \tvar _this = this;\n\n  \tthis.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n  \tthis.parent = this.owner.parentFragment;\n\n  \t// inherited properties\n  \tthis.root = options.root;\n  \tthis.pElement = options.pElement;\n  \tthis.context = options.context;\n  \tthis.index = options.index;\n  \tthis.key = options.key;\n  \tthis.registeredIndexRefs = [];\n\n  \t// encapsulated styles should be inherited until they get applied by an element\n  \tthis.cssIds = \"cssIds\" in options ? options.cssIds : this.parent ? this.parent.cssIds : null;\n\n  \tthis.items = options.template.map(function (template, i) {\n  \t\treturn createItem({\n  \t\t\tparentFragment: _this,\n  \t\t\tpElement: options.pElement,\n  \t\t\ttemplate: template,\n  \t\t\tindex: i\n  \t\t});\n  \t});\n\n  \tthis.value = this.argsList = null;\n  \tthis.dirtyArgs = this.dirtyValue = true;\n\n  \tthis.bound = true;\n  }\n\n  function createItem(options) {\n  \tif (typeof options.template === \"string\") {\n  \t\treturn new items_Text(options);\n  \t}\n\n  \tswitch (options.template.t) {\n  \t\tcase YIELDER:\n  \t\t\treturn new items_Yielder(options);\n  \t\tcase INTERPOLATOR:\n  \t\t\treturn new items_Interpolator(options);\n  \t\tcase SECTION:\n  \t\t\treturn new _Section(options);\n  \t\tcase TRIPLE:\n  \t\t\treturn new _Triple(options);\n  \t\tcase ELEMENT:\n  \t\t\tvar constructor = undefined;\n  \t\t\tif (constructor = Component_getComponent(options.parentFragment.root, options.template.e)) {\n  \t\t\t\treturn new _Component(options, constructor);\n  \t\t\t}\n  \t\t\treturn new _Element(options);\n  \t\tcase PARTIAL:\n  \t\t\treturn new _Partial(options);\n  \t\tcase COMMENT:\n  \t\t\treturn new items_Comment(options);\n  \t\tcase DOCTYPE:\n  \t\t\treturn new items_Doctype(options);\n\n  \t\tdefault:\n  \t\t\tthrow new Error(\"Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!\");\n  \t}\n  }\n\n  var Fragment_prototype_rebind = Fragment$rebind;\n  function Fragment$rebind(oldKeypath, newKeypath) {\n\n  \t// assign new context keypath if needed\n  \tif (!this.owner || this.owner.hasContext) {\n  \t\tassignNewKeypath(this, \"context\", oldKeypath, newKeypath);\n  \t}\n\n  \tthis.items.forEach(function (item) {\n  \t\tif (item.rebind) {\n  \t\t\titem.rebind(oldKeypath, newKeypath);\n  \t\t}\n  \t});\n  }\n\n  var Fragment_prototype_render = Fragment$render;\n\n  function Fragment$render() {\n  \tvar result;\n\n  \tif (this.items.length === 1) {\n  \t\tresult = this.items[0].render();\n  \t} else {\n  \t\tresult = document.createDocumentFragment();\n\n  \t\tthis.items.forEach(function (item) {\n  \t\t\tresult.appendChild(item.render());\n  \t\t});\n  \t}\n\n  \tthis.rendered = true;\n  \treturn result;\n  }\n\n  var Fragment_prototype_toString = Fragment$toString;\n\n  function Fragment$toString(escape) {\n  \tif (!this.items) {\n  \t\treturn \"\";\n  \t}\n\n  \treturn this.items.map(escape ? toEscapedString : Fragment_prototype_toString__toString).join(\"\");\n  }\n\n  function Fragment_prototype_toString__toString(item) {\n  \treturn item.toString();\n  }\n\n  function toEscapedString(item) {\n  \treturn item.toString(true);\n  }\n\n  var Fragment_prototype_unbind = Fragment$unbind;\n\n  function Fragment$unbind() {\n  \tif (!this.bound) {\n  \t\treturn;\n  \t}\n\n  \tthis.items.forEach(unbindItem);\n  \tthis.bound = false;\n  }\n\n  function unbindItem(item) {\n  \tif (item.unbind) {\n  \t\titem.unbind();\n  \t}\n  }\n\n  var Fragment_prototype_unrender = Fragment$unrender;\n\n  function Fragment$unrender(shouldDestroy) {\n  \tif (!this.rendered) {\n  \t\tthrow new Error(\"Attempted to unrender a fragment that was not rendered\");\n  \t}\n\n  \tthis.items.forEach(function (i) {\n  \t\treturn i.unrender(shouldDestroy);\n  \t});\n  \tthis.rendered = false;\n  }\n\n  var Fragment = function (options) {\n  \tthis.init(options);\n  };\n\n  Fragment.prototype = {\n  \tbubble: prototype_bubble,\n  \tdetach: Fragment_prototype_detach,\n  \tfind: Fragment_prototype_find,\n  \tfindAll: Fragment_prototype_findAll,\n  \tfindAllComponents: Fragment_prototype_findAllComponents,\n  \tfindComponent: Fragment_prototype_findComponent,\n  \tfindNextNode: prototype_findNextNode,\n  \tfirstNode: prototype_firstNode,\n  \tgetArgsList: getArgsList,\n  \tgetNode: getNode,\n  \tgetValue: prototype_getValue,\n  \tinit: Fragment_prototype_init,\n  \trebind: Fragment_prototype_rebind,\n  \tregisterIndexRef: function (idx) {\n  \t\tvar idxs = this.registeredIndexRefs;\n  \t\tif (idxs.indexOf(idx) === -1) {\n  \t\t\tidxs.push(idx);\n  \t\t}\n  \t},\n  \trender: Fragment_prototype_render,\n  \ttoString: Fragment_prototype_toString,\n  \tunbind: Fragment_prototype_unbind,\n  \tunregisterIndexRef: function (idx) {\n  \t\tvar idxs = this.registeredIndexRefs;\n  \t\tidxs.splice(idxs.indexOf(idx), 1);\n  \t},\n  \tunrender: Fragment_prototype_unrender\n  };\n\n  var virtualdom_Fragment = Fragment;\n\n  var prototype_reset = Ractive$reset;\n  var shouldRerender = [\"template\", \"partials\", \"components\", \"decorators\", \"events\"],\n      resetHook = new hooks_Hook(\"reset\");\n  function Ractive$reset(data) {\n  \tvar promise, wrapper, changes, i, rerender;\n\n  \tdata = data || {};\n\n  \tif (typeof data !== \"object\") {\n  \t\tthrow new Error(\"The reset method takes either no arguments, or an object containing new data\");\n  \t}\n\n  \t// If the root object is wrapped, try and use the wrapper's reset value\n  \tif ((wrapper = this.viewmodel.wrapped[\"\"]) && wrapper.reset) {\n  \t\tif (wrapper.reset(data) === false) {\n  \t\t\t// reset was rejected, we need to replace the object\n  \t\t\tthis.viewmodel.reset(data);\n  \t\t}\n  \t} else {\n  \t\tthis.viewmodel.reset(data);\n  \t}\n\n  \t// reset config items and track if need to rerender\n  \tchanges = config_config.reset(this);\n\n  \ti = changes.length;\n  \twhile (i--) {\n  \t\tif (shouldRerender.indexOf(changes[i]) > -1) {\n  \t\t\trerender = true;\n  \t\t\tbreak;\n  \t\t}\n  \t}\n\n  \tif (rerender) {\n  \t\tvar component = undefined;\n\n  \t\tthis.viewmodel.mark(rootKeypath);\n\n  \t\t// Is this is a component, we need to set the `shouldDestroy`\n  \t\t// flag, otherwise it will assume by default that a parent node\n  \t\t// will be detached, and therefore it doesn't need to bother\n  \t\t// detaching its own nodes\n  \t\tif (component = this.component) {\n  \t\t\tcomponent.shouldDestroy = true;\n  \t\t}\n\n  \t\tthis.unrender();\n\n  \t\tif (component) {\n  \t\t\tcomponent.shouldDestroy = false;\n  \t\t}\n\n  \t\t// If the template changed, we need to destroy the parallel DOM\n  \t\t// TODO if we're here, presumably it did?\n  \t\tif (this.fragment.template !== this.template) {\n  \t\t\tthis.fragment.unbind();\n\n  \t\t\tthis.fragment = new virtualdom_Fragment({\n  \t\t\t\ttemplate: this.template,\n  \t\t\t\troot: this,\n  \t\t\t\towner: this\n  \t\t\t});\n  \t\t}\n\n  \t\tpromise = this.render(this.el, this.anchor);\n  \t} else {\n  \t\tpromise = global_runloop.start(this, true);\n  \t\tthis.viewmodel.mark(rootKeypath);\n  \t\tglobal_runloop.end();\n  \t}\n\n  \tresetHook.fire(this, data);\n\n  \treturn promise;\n  }\n\n  var resetPartial = function (name, partial) {\n  \tvar promise,\n  \t    collection = [];\n\n  \tfunction collect(source, dest, ractive) {\n  \t\t// if this is a component and it has its own partial, bail\n  \t\tif (ractive && ractive.partials[name]) return;\n\n  \t\tsource.forEach(function (item) {\n  \t\t\t// queue to rerender if the item is a partial and the current name matches\n  \t\t\tif (item.type === PARTIAL && item.getPartialName() === name) {\n  \t\t\t\tdest.push(item);\n  \t\t\t}\n\n  \t\t\t// if it has a fragment, process its items\n  \t\t\tif (item.fragment) {\n  \t\t\t\tcollect(item.fragment.items, dest, ractive);\n  \t\t\t}\n\n  \t\t\t// or if it has fragments\n  \t\t\tif (isArray(item.fragments)) {\n  \t\t\t\tcollect(item.fragments, dest, ractive);\n  \t\t\t}\n\n  \t\t\t// or if it is itself a fragment, process its items\n  \t\t\telse if (isArray(item.items)) {\n  \t\t\t\tcollect(item.items, dest, ractive);\n  \t\t\t}\n\n  \t\t\t// or if it is a component, step in and process its items\n  \t\t\telse if (item.type === COMPONENT && item.instance) {\n  \t\t\t\tcollect(item.instance.fragment.items, dest, item.instance);\n  \t\t\t}\n\n  \t\t\t// if the item is an element, process its attributes too\n  \t\t\tif (item.type === ELEMENT) {\n  \t\t\t\tif (isArray(item.attributes)) {\n  \t\t\t\t\tcollect(item.attributes, dest, ractive);\n  \t\t\t\t}\n\n  \t\t\t\tif (isArray(item.conditionalAttributes)) {\n  \t\t\t\t\tcollect(item.conditionalAttributes, dest, ractive);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t});\n  \t}\n\n  \tcollect(this.fragment.items, collection);\n  \tthis.partials[name] = partial;\n\n  \tpromise = global_runloop.start(this, true);\n\n  \tcollection.forEach(function (item) {\n  \t\titem.value = undefined;\n  \t\titem.setValue(name);\n  \t});\n\n  \tglobal_runloop.end();\n\n  \treturn promise;\n  };\n\n  // TODO should resetTemplate be asynchronous? i.e. should it be a case\n  // of outro, update template, intro? I reckon probably not, since that\n  // could be achieved with unrender-resetTemplate-render. Also, it should\n  // conceptually be similar to resetPartial, which couldn't be async\n\n  var resetTemplate = Ractive$resetTemplate;\n  function Ractive$resetTemplate(template) {\n  \tvar transitionsEnabled, component;\n\n  \ttemplate_template.init(null, this, { template: template });\n\n  \ttransitionsEnabled = this.transitionsEnabled;\n  \tthis.transitionsEnabled = false;\n\n  \t// Is this is a component, we need to set the `shouldDestroy`\n  \t// flag, otherwise it will assume by default that a parent node\n  \t// will be detached, and therefore it doesn't need to bother\n  \t// detaching its own nodes\n  \tif (component = this.component) {\n  \t\tcomponent.shouldDestroy = true;\n  \t}\n\n  \tthis.unrender();\n\n  \tif (component) {\n  \t\tcomponent.shouldDestroy = false;\n  \t}\n\n  \t// remove existing fragment and create new one\n  \tthis.fragment.unbind();\n  \tthis.fragment = new virtualdom_Fragment({\n  \t\ttemplate: this.template,\n  \t\troot: this,\n  \t\towner: this\n  \t});\n\n  \tthis.render(this.el, this.anchor);\n\n  \tthis.transitionsEnabled = transitionsEnabled;\n  }\n\n  var reverse = makeArrayMethod(\"reverse\");\n\n  var Ractive_prototype_set = Ractive$set;\n\n  function Ractive$set(keypath, value) {\n  \tvar map, promise;\n\n  \tpromise = global_runloop.start(this, true);\n\n  \t// Set multiple keypaths in one go\n  \tif (isObject(keypath)) {\n  \t\tmap = keypath;\n\n  \t\tfor (keypath in map) {\n  \t\t\tif (map.hasOwnProperty(keypath)) {\n  \t\t\t\tvalue = map[keypath];\n  \t\t\t\tset(this, keypath, value);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// Set a single keypath\n  \telse {\n  \t\tset(this, keypath, value);\n  \t}\n\n  \tglobal_runloop.end();\n\n  \treturn promise;\n  }\n\n  function set(ractive, keypath, value) {\n  \tkeypath = getKeypath(normalise(keypath));\n\n  \tif (keypath.isPattern) {\n  \t\tgetMatchingKeypaths(ractive, keypath).forEach(function (keypath) {\n  \t\t\tractive.viewmodel.set(keypath, value);\n  \t\t});\n  \t} else {\n  \t\tractive.viewmodel.set(keypath, value);\n  \t}\n  }\n\n  var shift = makeArrayMethod(\"shift\");\n\n  var prototype_sort = makeArrayMethod(\"sort\");\n\n  var splice = makeArrayMethod(\"splice\");\n\n  var subtract = Ractive$subtract;\n  function Ractive$subtract(keypath, d) {\n  \treturn shared_add(this, keypath, d === undefined ? -1 : -d);\n  }\n\n  // Teardown. This goes through the root fragment and all its children, removing observers\n  // and generally cleaning up after itself\n\n  var Ractive_prototype_teardown = Ractive$teardown;\n\n  var Ractive_prototype_teardown__teardownHook = new hooks_Hook(\"teardown\");\n  function Ractive$teardown() {\n  \tvar promise;\n\n  \tthis.fragment.unbind();\n  \tthis.viewmodel.teardown();\n\n  \tthis._observers.forEach(cancel);\n\n  \tif (this.fragment.rendered && this.el.__ractive_instances__) {\n  \t\tremoveFromArray(this.el.__ractive_instances__, this);\n  \t}\n\n  \tthis.shouldDestroy = true;\n  \tpromise = this.fragment.rendered ? this.unrender() : utils_Promise.resolve();\n\n  \tRactive_prototype_teardown__teardownHook.fire(this);\n\n  \tthis._boundFunctions.forEach(deleteFunctionCopy);\n\n  \treturn promise;\n  }\n\n  function deleteFunctionCopy(bound) {\n  \tdelete bound.fn[bound.prop];\n  }\n\n  var toggle = Ractive$toggle;\n  function Ractive$toggle(keypath) {\n  \tvar _this = this;\n\n  \tif (typeof keypath !== \"string\") {\n  \t\tthrow new TypeError(badArguments);\n  \t}\n\n  \tvar changes = undefined;\n\n  \tif (/\\*/.test(keypath)) {\n  \t\tchanges = {};\n\n  \t\tgetMatchingKeypaths(this, getKeypath(normalise(keypath))).forEach(function (keypath) {\n  \t\t\tchanges[keypath.str] = !_this.viewmodel.get(keypath);\n  \t\t});\n\n  \t\treturn this.set(changes);\n  \t}\n\n  \treturn this.set(keypath, !this.get(keypath));\n  }\n\n  var toHTML = Ractive$toHTML;\n\n  function Ractive$toHTML() {\n  \treturn this.fragment.toString(true);\n  }\n\n  var Ractive_prototype_unrender = Ractive$unrender;\n  var unrenderHook = new hooks_Hook(\"unrender\");\n  function Ractive$unrender() {\n  \tvar promise, shouldDestroy;\n\n  \tif (!this.fragment.rendered) {\n  \t\twarnIfDebug(\"ractive.unrender() was called on a Ractive instance that was not rendered\");\n  \t\treturn utils_Promise.resolve();\n  \t}\n\n  \tpromise = global_runloop.start(this, true);\n\n  \t// If this is a component, and the component isn't marked for destruction,\n  \t// don't detach nodes from the DOM unnecessarily\n  \tshouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\n  \t// Cancel any animations in progress\n  \twhile (this._animations[0]) {\n  \t\tthis._animations[0].stop(); // it will remove itself from the index\n  \t}\n\n  \tthis.fragment.unrender(shouldDestroy);\n\n  \tremoveFromArray(this.el.__ractive_instances__, this);\n\n  \tunrenderHook.fire(this);\n\n  \tglobal_runloop.end();\n  \treturn promise;\n  }\n\n  var unshift = makeArrayMethod(\"unshift\");\n\n  var Ractive_prototype_update = Ractive$update;\n  var updateHook = new hooks_Hook(\"update\");\n  function Ractive$update(keypath) {\n  \tvar promise;\n\n  \tkeypath = getKeypath(keypath) || rootKeypath;\n\n  \tpromise = global_runloop.start(this, true);\n  \tthis.viewmodel.mark(keypath);\n  \tglobal_runloop.end();\n\n  \tupdateHook.fire(this, keypath);\n\n  \treturn promise;\n  }\n\n  var prototype_updateModel = Ractive$updateModel;\n\n  function Ractive$updateModel(keypath, cascade) {\n  \tvar values, key, bindings;\n\n  \tif (typeof keypath === \"string\" && !cascade) {\n  \t\tbindings = this._twowayBindings[keypath];\n  \t} else {\n  \t\tbindings = [];\n\n  \t\tfor (key in this._twowayBindings) {\n  \t\t\tif (!keypath || getKeypath(key).equalsOrStartsWith(keypath)) {\n  \t\t\t\t// TODO is this right?\n  \t\t\t\tbindings.push.apply(bindings, this._twowayBindings[key]);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tvalues = consolidate(this, bindings);\n  \treturn this.set(values);\n  }\n\n  function consolidate(ractive, bindings) {\n  \tvar values = {},\n  \t    checkboxGroups = [];\n\n  \tbindings.forEach(function (b) {\n  \t\tvar oldValue, newValue;\n\n  \t\t// special case - radio name bindings\n  \t\tif (b.radioName && !b.element.node.checked) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// special case - checkbox name bindings come in groups, so\n  \t\t// we want to get the value once at most\n  \t\tif (b.checkboxName) {\n  \t\t\tif (!checkboxGroups[b.keypath.str] && !b.changed()) {\n  \t\t\t\tcheckboxGroups.push(b.keypath);\n  \t\t\t\tcheckboxGroups[b.keypath.str] = b;\n  \t\t\t}\n\n  \t\t\treturn;\n  \t\t}\n\n  \t\toldValue = b.attribute.value;\n  \t\tnewValue = b.getValue();\n\n  \t\tif (arrayContentsMatch(oldValue, newValue)) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (!isEqual(oldValue, newValue)) {\n  \t\t\tvalues[b.keypath.str] = newValue;\n  \t\t}\n  \t});\n\n  \t// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`\n  \tif (checkboxGroups.length) {\n  \t\tcheckboxGroups.forEach(function (keypath) {\n  \t\t\tvar binding, oldValue, newValue;\n\n  \t\t\tbinding = checkboxGroups[keypath.str]; // one to represent the entire group\n  \t\t\toldValue = binding.attribute.value;\n  \t\t\tnewValue = binding.getValue();\n\n  \t\t\tif (!arrayContentsMatch(oldValue, newValue)) {\n  \t\t\t\tvalues[keypath.str] = newValue;\n  \t\t\t}\n  \t\t});\n  \t}\n\n  \treturn values;\n  }\n\n  var prototype = {\n  \tadd: prototype_add,\n  \tanimate: prototype_animate,\n  \tdetach: prototype_detach,\n  \tfind: prototype_find,\n  \tfindAll: prototype_findAll,\n  \tfindAllComponents: prototype_findAllComponents,\n  \tfindComponent: prototype_findComponent,\n  \tfindContainer: findContainer,\n  \tfindParent: findParent,\n  \tfire: prototype_fire,\n  \tget: prototype_get,\n  \tinsert: insert,\n  \tmerge: prototype_merge,\n  \tobserve: observe,\n  \tobserveOnce: observeOnce,\n  \toff: off,\n  \ton: on,\n  \tonce: once,\n  \tpop: pop,\n  \tpush: push,\n  \trender: prototype_render,\n  \treset: prototype_reset,\n  \tresetPartial: resetPartial,\n  \tresetTemplate: resetTemplate,\n  \treverse: reverse,\n  \tset: Ractive_prototype_set,\n  \tshift: shift,\n  \tsort: prototype_sort,\n  \tsplice: splice,\n  \tsubtract: subtract,\n  \tteardown: Ractive_prototype_teardown,\n  \ttoggle: toggle,\n  \ttoHTML: toHTML,\n  \ttoHtml: toHTML,\n  \tunrender: Ractive_prototype_unrender,\n  \tunshift: unshift,\n  \tupdate: Ractive_prototype_update,\n  \tupdateModel: prototype_updateModel\n  };\n\n  var wrapMethod = function (method, superMethod, force) {\n\n  \tif (force || needsSuper(method, superMethod)) {\n\n  \t\treturn function () {\n\n  \t\t\tvar hasSuper = (\"_super\" in this),\n  \t\t\t    _super = this._super,\n  \t\t\t    result;\n\n  \t\t\tthis._super = superMethod;\n\n  \t\t\tresult = method.apply(this, arguments);\n\n  \t\t\tif (hasSuper) {\n  \t\t\t\tthis._super = _super;\n  \t\t\t}\n\n  \t\t\treturn result;\n  \t\t};\n  \t} else {\n  \t\treturn method;\n  \t}\n  };\n\n  function needsSuper(method, superMethod) {\n  \treturn typeof superMethod === \"function\" && /_super/.test(method);\n  }\n\n  var unwrapExtended = unwrap;\n\n  function unwrap(Child) {\n  \tvar options = {};\n\n  \twhile (Child) {\n  \t\taddRegistries(Child, options);\n  \t\taddOtherOptions(Child, options);\n\n  \t\tif (Child._Parent !== _Ractive) {\n  \t\t\tChild = Child._Parent;\n  \t\t} else {\n  \t\t\tChild = false;\n  \t\t}\n  \t}\n\n  \treturn options;\n  }\n\n  function addRegistries(Child, options) {\n  \tconfig_registries.forEach(function (r) {\n  \t\taddRegistry(r.useDefaults ? Child.prototype : Child, options, r.name);\n  \t});\n  }\n\n  function addRegistry(target, options, name) {\n  \tvar registry,\n  \t    keys = Object.keys(target[name]);\n\n  \tif (!keys.length) {\n  \t\treturn;\n  \t}\n\n  \tif (!(registry = options[name])) {\n  \t\tregistry = options[name] = {};\n  \t}\n\n  \tkeys.filter(function (key) {\n  \t\treturn !(key in registry);\n  \t}).forEach(function (key) {\n  \t\treturn registry[key] = target[name][key];\n  \t});\n  }\n\n  function addOtherOptions(Child, options) {\n  \tObject.keys(Child.prototype).forEach(function (key) {\n  \t\tif (key === \"computed\") {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar value = Child.prototype[key];\n\n  \t\tif (!(key in options)) {\n  \t\t\toptions[key] = value._method ? value._method : value;\n  \t\t}\n\n  \t\t// is it a wrapped function?\n  \t\telse if (typeof options[key] === \"function\" && typeof value === \"function\" && options[key]._method) {\n\n  \t\t\tvar result = undefined,\n  \t\t\t    needsSuper = value._method;\n\n  \t\t\tif (needsSuper) {\n  \t\t\t\tvalue = value._method;\n  \t\t\t}\n\n  \t\t\t// rewrap bound directly to parent fn\n  \t\t\tresult = wrapMethod(options[key]._method, value);\n\n  \t\t\tif (needsSuper) {\n  \t\t\t\tresult._method = result;\n  \t\t\t}\n\n  \t\t\toptions[key] = result;\n  \t\t}\n  \t});\n  }\n\n  var _extend = _extend__extend;\n\n  function _extend__extend() {\n  \tfor (var _len = arguments.length, options = Array(_len), _key = 0; _key < _len; _key++) {\n  \t\toptions[_key] = arguments[_key];\n  \t}\n\n  \tif (!options.length) {\n  \t\treturn extendOne(this);\n  \t} else {\n  \t\treturn options.reduce(extendOne, this);\n  \t}\n  }\n\n  function extendOne(Parent) {\n  \tvar options = arguments[1] === undefined ? {} : arguments[1];\n\n  \tvar Child, proto;\n\n  \t// if we're extending with another Ractive instance...\n  \t//\n  \t//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);\n  \t//   var Spiderman = Human.extend( Spider );\n  \t//\n  \t// ...inherit prototype methods and default options as well\n  \tif (options.prototype instanceof _Ractive) {\n  \t\toptions = unwrapExtended(options);\n  \t}\n\n  \tChild = function (options) {\n  \t\tif (!(this instanceof Child)) return new Child(options);\n  \t\tinitialise(this, options);\n  \t};\n\n  \tproto = create(Parent.prototype);\n  \tproto.constructor = Child;\n\n  \t// Static properties\n  \tdefineProperties(Child, {\n  \t\t// alias prototype as defaults\n  \t\tdefaults: { value: proto },\n\n  \t\t// extendable\n  \t\textend: { value: _extend__extend, writable: true, configurable: true },\n\n  \t\t// Parent - for IE8, can't use Object.getPrototypeOf\n  \t\t_Parent: { value: Parent }\n  \t});\n\n  \t// extend configuration\n  \tconfig_config.extend(Parent, proto, options);\n\n  \tcustom_data.extend(Parent, proto, options);\n\n  \tif (options.computed) {\n  \t\tproto.computed = utils_object__extend(create(Parent.prototype.computed), options.computed);\n  \t}\n\n  \tChild.prototype = proto;\n\n  \treturn Child;\n  }\n\n  var getNodeInfo = function (node) {\n  \tvar info = {},\n  \t    priv,\n  \t    indices;\n\n  \tif (!node || !(priv = node._ractive)) {\n  \t\treturn info;\n  \t}\n\n  \tinfo.ractive = priv.root;\n  \tinfo.keypath = priv.keypath.str;\n  \tinfo.index = {};\n\n  \t// find all index references and resolve them\n  \tif (indices = Resolvers_findIndexRefs(priv.proxy.parentFragment)) {\n  \t\tinfo.index = Resolvers_findIndexRefs.resolve(indices);\n  \t}\n\n  \treturn info;\n  };\n\n  var Ractive, properties;\n\n  // Main Ractive required object\n  Ractive = function (options) {\n  \tif (!(this instanceof Ractive)) return new Ractive(options);\n  \tinitialise(this, options);\n  };\n\n  // Ractive properties\n  properties = {\n\n  \t// debug flag\n  \tDEBUG: { writable: true, value: true },\n  \tDEBUG_PROMISES: { writable: true, value: true },\n\n  \t// static methods:\n  \textend: { value: _extend },\n  \tgetNodeInfo: { value: getNodeInfo },\n  \tparse: { value: _parse },\n\n  \t// Namespaced constructors\n  \tPromise: { value: utils_Promise },\n\n  \t// support\n  \tsvg: { value: svg },\n  \tmagic: { value: environment__magic },\n\n  \t// version\n  \tVERSION: { value: \"0.7.3\" },\n\n  \t// Plugins\n  \tadaptors: { writable: true, value: {} },\n  \tcomponents: { writable: true, value: {} },\n  \tdecorators: { writable: true, value: {} },\n  \teasing: { writable: true, value: static_easing },\n  \tevents: { writable: true, value: {} },\n  \tinterpolators: { writable: true, value: static_interpolators },\n  \tpartials: { writable: true, value: {} },\n  \ttransitions: { writable: true, value: {} }\n  };\n\n  // Ractive properties\n  defineProperties(Ractive, properties);\n\n  Ractive.prototype = utils_object__extend(prototype, config_defaults);\n\n  Ractive.prototype.constructor = Ractive;\n\n  // alias prototype as defaults\n  Ractive.defaults = Ractive.prototype;\n\n  // Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n  // older browsers, these are made available via a shim - here, we do a quick\n  // pre-flight check to make sure that either a) we're not in a shit browser,\n  // or b) we're using a Ractive-legacy.js build\n  var FUNCTION = \"function\";\n\n  if (typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== \"undefined\" && typeof window.addEventListener !== FUNCTION) {\n  \tthrow new Error(\"It looks like you're attempting to use Ractive.js in an older browser. You'll need to use one of the 'legacy builds' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.\");\n  }\n\n  var _Ractive = Ractive;\n\n  return _Ractive;\n\n}));\n//# sourceMappingURL=ractive.js.map\n",
    "import Controller from './Controller';\nimport Command from './Command';\nimport User from './data-objects/User';\nimport ItemRecord from './data-objects/ItemRecord';\nimport Loan from './data-objects/Loan';\nimport app from './app';\n\nvar log = console.log.bind(console);\n\n/**\n * Borrow Library Items\n * Based on this use case by Andreas Sderlund (with some modifications):\n * https://docs.google.com/spreadsheets/d/1TSpjKUhjvP9pMRukt_mInHVbdQWsXHzFjSymQ3VyGmE/edit#gid=2\n */\nexport default function BorrowLibraryItems(borrower: User, firstItemId: number, controller) {\n\tBorrower = borrower;\n\tScreen = controller;\n\tDatabase = app.objectStore;\n\tPrinter = window;\n\t\n\tlet borrowedItems: Map<number, ItemRecord> = new Map();\n\t\n\tBorrower.borrowLoanItem(firstItemId);\n\t\n\trole Borrower {\n\t\tborrowLoanItem(itemId: number) {\n\t\t\tlet loanItem: ItemRecord = Database.getById(itemId);\n\t\t\tlet error;\n\t\t\t\n\t\t\tif (!loanItem.isAvailable()) {\n\t\t\t\terror = 'Sorry, this item is not available to be checked out at this time.';\n\t\t\t\t//(in a real system this would also explain why it's not available)\n\t\t\t}\n\t\t\telse if (borrowedItems.has(loanItem.id)) {\n\t\t\t\terror = 'The item \"' + loanItem.title + '\" was already scanned.';\n\t\t\t}\n\t\t\t\n\t\t\tif (error) {\n\t\t\t\tScreen.showScannedItem(loanItem, false);\n\t\t\t\tScreen.showError(error);\n\t\t\t}\n\t\t\telse {\t\t\t\n\t\t\t\tlet loan = new Loan(Borrower, loanItem);\n\t\t\t\tDatabase.save(loan);\n\t\t\t\t//add to local map of borrowed items (indexed by item ID)\n\t\t\t\tborrowedItems.set(loanItem.id, loanItem);\n\t\t\t\tScreen.showScannedItem(loanItem, true);\n\t\t\t}\n\t\t\tScreen.askForNextItem();\n\t\t}\n\t}\n\tcontract {\n\t\tid: number;\n\t}\n\t\n\trole Screen {\n\t\tasync askForNextItem() {\n\t\t\tself.showNextSteps();\n\t\t\tlet cmd = await Screen.nextCommand();\n\t\t\tswitch (cmd.name) {\n                case \"scanAnother\":\n                    Borrower.borrowLoanItem((cmd.arguments[0]: number));\n                    break;\n\t\t\t\tcase \"finishWithReceipt\":\n                case \"finishWithoutReceipt\":\n\t\t\t\t\tlet arrBorrowedItems = Array.from(borrowedItems.values());\n\t\t\t\t\tScreen.showConfirmation(arrBorrowedItems);\n\t\t\t\t\tif (cmd.name == \"finishWithReceipt\") {\n\t\t\t\t\t\tScreen.showReceipt(Borrower, arrBorrowedItems, new Date());\n\t\t\t\t\t\tPrinter.print();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow Error('Invalid command: \"' + cmd.name + '\"');\n            }\n\t\t}\n\t}\n\tcontract {\n\t\tshowScannedItem(item: ItemRecord, successfullyBorrowed: boolean): void;\n\t\tshowNextSteps(): void;\n\t\tnextCommand(): Promise<Command>;\n\t\tshowConfirmation(loanItems: Array<ItemRecord>): void;\n\t\tshowReceipt(borrower:User, loanItems: Array<ItemRecord>, date: Date): void;\n\t\tshowError(err: string): void;\n\t}\n\t\n\trole Database {\n\t\tgetItemRecordById(id: number): ItemRecord {\n\t\t\treturn (self.getById(id): ItemRecord);\n\t\t}\n\t}\n\tcontract {\n\t\tgetById(id: number): Object;\n\t\tsave(entity: Object): void;\n\t}\n\t\n\trole Printer {} contract {\n\t\tprint(): void;\n\t}\n}",
    "export default function Command(name: string, args: ?Array<any>) {\n\tthis._name = name;\n\tthis._args = args;\n}\n\nCommand.prototype = {\n\tconstructor: Command,\n\tget name() {return this._name},\n\tget arguments() {return this._args}\n};",
    "import BorrowLibraryItems from './BorrowLibraryItems';\nimport app from './app';\nimport User from './data-objects/User';\nimport Deferred from './Deferred';\nimport Command from './Command';\nimport Ractive from 'ractive';\n\nvar log = console.log.bind(console);\n\n/**\n * MVC Controller\n */\nexport default context Controller {\n\t_panel: Ractive;\n\t_menuView: Ractive;\n\t_confirmationView: Ractive;\n\t_receiptView: Ractive;\n\t_deferredNextCommand: Deferred;\n\n\tconstructor() {\n\t\tScanner = null;\n\t\tthis._deferredNextCommand = new Deferred();\n\t}\n\t\n\tinit() {\n\t\tthis._renderPanel();\n\t\tthis._renderMenu();\n\t\tthis._initEventHandlers();\n\t}\n\t\n\trole Scanner {\n\t\t//generate random item number (mock scanner)\n\t\tgetItemId(): number {\n\t\t\tlet min = 1, max = 7;\n\t\t\treturn Math.floor(Math.random() * (max - min + 1)) + min;\n\t\t}\n\t}\n\t\n\tshowScannedItem(item: ItemRecord, successfullyBorrowed: boolean) {\n\t\tthis._panel.set('scannedItem', item);\n\t\tthis._panel.set('successfullyBorrowed', successfullyBorrowed);\n\t}\n\t\n\tshowNextSteps() {\n\t\tthis._menuView.set('firstItemWasScanned', true);\n\t}\n\t\n\tshowError(errMsg: string) {\n\t\talert(errMsg);\n\t}\n\t\n\t_initEventHandlers() {\n\t\tlet self = this,\n\t\t\tmenu = self._menuView;\n\t\t\n\t\tmenu.on('scanFirstItem', function() {\n\t\t\t/*\n\t\t\t * Start the use case\n\t\t\t */\n\t\t\tBorrowLibraryItems(app.session.user, Scanner.getItemId(), self);\n\t\t});\n\t\t\n\t\tmenu.on('scanAnother', function() {\n\t\t\tself._emitCommand('scanAnother', [Scanner.getItemId()]);\n\t\t});\n\t\t\n\t\tmenu.on('finishWithReceipt', function() {\n\t\t\tself._emitCommand('finishWithReceipt');\n\t\t});\n\t\t\n\t\tmenu.on('finishWithoutReceipt', function() {\n\t\t\tself._emitCommand('finishWithoutReceipt');\n\t\t});\n\t}\n\t\n\t_emitCommand(commandName: string, args: ?Array<any>) {\n\t\tthis._deferredNextCommand.resolve(new Command(commandName, args));\n\t\tthis._deferredNextCommand = new Deferred();\n\t}\n\n\tasync nextCommand() {\n\t\t//setTimeout(() => deferred.resolve(\"test\"), 100);\n\t\treturn this._deferredNextCommand.promise;\n\t}\n\t\n\t_renderPanel() {\n\t\tthis._panel = new Ractive({\n\t\t\tel: 'container',\n\t\t\ttemplate: '#panelTemplate'\n\t\t});\n\t}\n\t\n\t_renderMenu() {\n\t\tthis._menuView = new Ractive({\n\t\t\tel: 'menu',\n\t\t\ttemplate: '#menuTemplate',\n\t\t\tdata: {\n\t\t\t\tfirstItemScanned: false\n\t\t\t}\n\t\t});\n\t}\n\t\n\tshowConfirmation(loanItems: Array<ItemRecord>) {\n\t\tthis._confirmationView = new Ractive({\n\t\t\tel: 'container',\n\t\t\ttemplate: '#confirmationTemplate',\n\t\t\tdata: {\n\t\t\t\tloanItems\n\t\t\t}\n\t\t});\n\t}\n\t\n\tshowReceipt(borrower:User, loanItems: Array<ItemRecord>, date: Date) {\n\t\tthis._receiptView = new Ractive({\n\t\t\tel: 'receipt',\n\t\t\ttemplate: '#receiptTemplate',\n\t\t\tdata: {\n\t\t\t\tborrower,\n\t\t\t\tloanItems,\n\t\t\t\tdate\n\t\t\t}\n\t\t});\n\t}\n}",
    "/**\n  Creates a wrapper for a promise that can be resolved or rejected via public methods\n  (similar to jQuery's `$.Deferred`)\n  \n  * promise - a Promise object\n  * reject - a function that causes the `promise` property on this object to\n    become rejected\n  * resolve - a function that causes the `promise` property on this object to\n    become fulfilled.\n \n   Example:\n   ```javascript\n   var deferred = new Deferred();\n   deferred.resolve(\"Success!\");\n   deferred.promise.then(function(value){\n     // value here is \"Success!\"\n   });\n   ```\n */\nexport default function Deferred(label: ?string) {\n\tlet self = this;\n\tself.promise = new Promise(function(resolve, reject) {\n\t\tself.resolve = resolve;\n\t\tself.reject = reject;\n\t}, label);\n}",
    "/**\n * In-memory object storage (used as a mock database object)\n */\nexport default context ObjectStore {\n\tentities_: Map<string, Object>;\n\n\tconstructor() {\n\t\tthis._entities = new Map();\n\t}\n\t\n\tsave(entity: Object) {\n\t\tif (!this._entities.has(entity))\n\t\t\tthis._entities.set((entity.id: string), entity);\n\t}\n\t\n\tgetById(id: string | number): Object {\n\t\treturn this._entities.get((id: string));\n\t}\n\t\n\tremove(item: string | number | Object) {\n\t\tif (typeof item === 'object') {\n\t\t\tfor (let entity of this._entities.values()) {\n\t\t\t\tif (item === entity) {\n\t\t\t\t\tthis.removeById(item.id);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse this.removeById(item);\n\t}\n\t\n\tremoveById(id: string | number) {\n\t\tthis._entities.delete((id: string));\n\t}\n}",
    "import User from './data-objects/User';\nimport ObjectStore from './ObjectStore';\n\nvar app = {};\nexport default app;\n\napp.session = {\n\tuser: new User(12345, 'Test', 'User')\n};\n\t\napp.objectStore = new ObjectStore();",
    "import ItemRecord from './ItemRecord';\n\nexport default function Book(id: number, title: string) {\n\tItemRecord.call(this, id, title);\n}\n\nBook.prototype = Object.create(ItemRecord.prototype);\nBook.prototype.constructor = Book;",
    "import ItemRecord from './ItemRecord';\n\nexport default function DVD(id: number, title: string) {\n\tItemRecord.call(this, id, title);\n}\n\nDVD.prototype = Object.create(ItemRecord.prototype);\nDVD.prototype.constructor = DVD;",
    "export default function ItemRecord(id: number, title: string) {\n\tthis._id = id;\n\tthis._title = title;\n}\n\nItemRecord.prototype = {\n\tconstructor: ItemRecord,\n\t\n\t//available for loan?\n\tisAvailable() {\n\t\treturn GetLoanItemAvailability(this);\n\t},\n\t\n\tget id(): number {return this._id},\n\tget title(): string {return this._title}\n};\n\n//In a real app, this would probably be a Context\nfunction GetLoanItemAvailability(loanItem: ItemRecord) {\n\t//just make all items available for the sake of this simple example\n\treturn true;\n}",
    "export default function Loan(borrower: User, itemRecord: itemRecord, numDays: number) {\n\tthis._id = null; //This should be auto-generated somehow\n\tthis._borrower = borrower;\n\tthis._itemRecord = itemRecord;\n\tthis._numDays = numDays;\n}\n\nLoan.prototype = {\n\tconstructor: Loan,\n\tget id(): number {return this._id},\n\tget borrower(): User {return this._borrower},\n\tget itemRecord(): ItemRecord {return this._itemRecord},\n\tget numDays(): number {return this._numDays}\n};",
    "export default function User(cardNumber: number, firstName: string, lastName: string) {\n\tthis._cardNumber = cardNumber;\n\tthis.firstName = firstName;\n\tthis.lastName = lastName;\n}\n\nUser.prototype = {\n\tconstructor: User,\n\tget name(): string {\n\t\treturn this.firstName + ' ' + this.lastName;\n\t},\n\tget cardNumber(): number {return this._cardNumber}\n};",
    "import \"babel-polyfill\";\n\n//import BorrowLibraryItems from './BorrowLibraryItems';\nimport Controller from './Controller';\nimport app from './app';\nimport loadDemoData from './loadDemoData';\n\nloadDemoData();\n\n//session.user = new User(12345, 'Test', 'User');\n\nnew Controller().init();\n\n//BorrowLibraryItems(new Controller());",
    "import app from './app';\nimport Book from './data-objects/Book';\nimport DVD from './data-objects/DVD';\n\nexport default function loadDemoData() {\n\tlet items = [\n\t\tnew Book(1, 'The Brothers Karamazov'),\n\t\tnew Book(2, \"A Midsummer Night's Dream\"),\n\t\tnew Book(3, 'The Prophet'),\n\t\tnew Book(4, 'Leaves of Grass'),\n\t\tnew DVD(5, 'Curb Your Enthusiasm - Season 6'),\n\t\tnew DVD(6, 'Breaking Away'),\n\t\tnew DVD(7, 'The Shawshank Redemption')\n\t];\n\n\tfor (let item of items) {\n\t\tapp.objectStore.save(item);\n\t}\n}",
    "\"use strict\";\n\nrequire(\"core-js/shim\");\n\nrequire(\"babel-regenerator-runtime\");\n\nif (global._babelPolyfill) {\n  throw new Error(\"only one instance of babel-polyfill is allowed\");\n}\nglobal._babelPolyfill = true;",
    "/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var iteratorSymbol =\n    typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided, then outerFn.prototype instanceof Generator.\n    var generator = Object.create((outerFn || Generator).prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `value instanceof AwaitArgument` to determine if the yielded value is\n  // meant to be awaited. Some may consider the name of this method too\n  // cutesy, but they are curmudgeons.\n  runtime.awrap = function(arg) {\n    return new AwaitArgument(arg);\n  };\n\n  function AwaitArgument(arg) {\n    this.arg = arg;\n  }\n\n  function AsyncIterator(generator) {\n    // This invoke function is written in a style that assumes some\n    // calling function (or Promise) will handle exceptions.\n    function invoke(method, arg) {\n      var result = generator[method](arg);\n      var value = result.value;\n      return value instanceof AwaitArgument\n        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)\n        : Promise.resolve(value).then(function(unwrapped) {\n            // When a yielded Promise is resolved, its final value becomes\n            // the .value of the Promise<{value,done}> result for the\n            // current iteration. If the Promise is rejected, however, the\n            // result for this iteration will be rejected with the same\n            // reason. Note that rejections of yielded Promises are not\n            // thrown back into the generator function, as is the case\n            // when an awaited Promise is rejected. This difference in\n            // behavior between yield and await is important, because it\n            // allows the consumer to decide what to do with the yielded\n            // rejection (swallow it and continue, manually .throw it back\n            // into the generator, abandon iteration, whatever). With\n            // await, by contrast, there is no opportunity to examine the\n            // rejection reason outside the generator function, so the\n            // only option is to throw it from the await expression, and\n            // let the generator function handle the exception.\n            result.value = unwrapped;\n            return result;\n          });\n    }\n\n    if (typeof process === \"object\" && process.domain) {\n      invoke = process.domain.bind(invoke);\n    }\n\n    var invokeNext = invoke.bind(generator, \"next\");\n    var invokeThrow = invoke.bind(generator, \"throw\");\n    var invokeReturn = invoke.bind(generator, \"return\");\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return invoke(method, arg);\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : new Promise(function (resolve) {\n          resolve(callInvokeWithMethodAndArg());\n        });\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          if (method === \"return\" ||\n              (method === \"throw\" && delegate.iterator[method] === undefined)) {\n            // A return or throw (when the delegate iterator has no throw\n            // method) always terminates the yield* loop.\n            context.delegate = null;\n\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            var returnMethod = delegate.iterator[\"return\"];\n            if (returnMethod) {\n              var record = tryCatch(returnMethod, delegate.iterator, arg);\n              if (record.type === \"throw\") {\n                // If the return method threw an exception, let that\n                // exception prevail over the original return or throw.\n                method = \"throw\";\n                arg = record.arg;\n                continue;\n              }\n            }\n\n            if (method === \"return\") {\n              // Continue with the outer return, now that the delegate\n              // iterator has been terminated.\n              continue;\n            }\n          }\n\n          var record = tryCatch(\n            delegate.iterator[method],\n            delegate.iterator,\n            arg\n          );\n\n          if (record.type === \"throw\") {\n            context.delegate = null;\n\n            // Like returning generator.throw(uncaught), but without the\n            // overhead of an extra function call.\n            method = \"throw\";\n            arg = record.arg;\n            continue;\n          }\n\n          // Delegate generator ran and handled its own exceptions so\n          // regardless of what the method was, we continue as if it is\n          // \"next\" with an undefined arg.\n          method = \"next\";\n          arg = undefined;\n\n          var info = record.arg;\n          if (info.done) {\n            context[delegate.resultName] = info.value;\n            context.next = delegate.nextLoc;\n          } else {\n            state = GenStateSuspendedYield;\n            return info;\n          }\n\n          context.delegate = null;\n        }\n\n        if (method === \"next\") {\n          context._sent = arg;\n\n          if (state === GenStateSuspendedYield) {\n            context.sent = arg;\n          } else {\n            context.sent = undefined;\n          }\n        } else if (method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw arg;\n          }\n\n          if (context.dispatchException(arg)) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            method = \"next\";\n            arg = undefined;\n          }\n\n        } else if (method === \"return\") {\n          context.abrupt(\"return\", arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          var info = {\n            value: record.arg,\n            done: context.done\n          };\n\n          if (record.arg === ContinueSentinel) {\n            if (context.delegate && method === \"next\") {\n              // Deliberately forget the last sent value so that we don't\n              // accidentally pass it on to the delegate.\n              arg = undefined;\n            }\n          } else {\n            return info;\n          }\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(arg) call above.\n          method = \"throw\";\n          arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      this.sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.next = finallyEntry.finallyLoc;\n      } else {\n        this.complete(record);\n      }\n\n      return ContinueSentinel;\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = record.arg;\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n",
    "module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};",
    "// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = require('./$.wks')('unscopables')\n  , ArrayProto  = Array.prototype;\nif(ArrayProto[UNSCOPABLES] == undefined)require('./$.hide')(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function(key){\n  ArrayProto[UNSCOPABLES][key] = true;\n};",
    "var isObject = require('./$.is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};",
    "// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\n'use strict';\nvar toObject = require('./$.to-object')\n  , toIndex  = require('./$.to-index')\n  , toLength = require('./$.to-length');\n\nmodule.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){\n  var O     = toObject(this)\n    , len   = toLength(O.length)\n    , to    = toIndex(target, len)\n    , from  = toIndex(start, len)\n    , $$    = arguments\n    , end   = $$.length > 2 ? $$[2] : undefined\n    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)\n    , inc   = 1;\n  if(from < to && to < from + count){\n    inc  = -1;\n    from += count - 1;\n    to   += count - 1;\n  }\n  while(count-- > 0){\n    if(from in O)O[to] = O[from];\n    else delete O[to];\n    to   += inc;\n    from += inc;\n  } return O;\n};",
    "// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\n'use strict';\nvar toObject = require('./$.to-object')\n  , toIndex  = require('./$.to-index')\n  , toLength = require('./$.to-length');\nmodule.exports = [].fill || function fill(value /*, start = 0, end = @length */){\n  var O      = toObject(this)\n    , length = toLength(O.length)\n    , $$     = arguments\n    , $$len  = $$.length\n    , index  = toIndex($$len > 1 ? $$[1] : undefined, length)\n    , end    = $$len > 2 ? $$[2] : undefined\n    , endPos = end === undefined ? length : toIndex(end, length);\n  while(endPos > index)O[index++] = value;\n  return O;\n};",
    "// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./$.to-iobject')\n  , toLength  = require('./$.to-length')\n  , toIndex   = require('./$.to-index');\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index;\n    } return !IS_INCLUDES && -1;\n  };\n};",
    "// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\nvar ctx      = require('./$.ctx')\n  , IObject  = require('./$.iobject')\n  , toObject = require('./$.to-object')\n  , toLength = require('./$.to-length')\n  , asc      = require('./$.array-species-create');\nmodule.exports = function(TYPE){\n  var IS_MAP        = TYPE == 1\n    , IS_FILTER     = TYPE == 2\n    , IS_SOME       = TYPE == 3\n    , IS_EVERY      = TYPE == 4\n    , IS_FIND_INDEX = TYPE == 6\n    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX;\n  return function($this, callbackfn, that){\n    var O      = toObject($this)\n      , self   = IObject(O)\n      , f      = ctx(callbackfn, that, 3)\n      , length = toLength(self.length)\n      , index  = 0\n      , result = IS_MAP ? asc($this, length) : IS_FILTER ? asc($this, 0) : undefined\n      , val, res;\n    for(;length > index; index++)if(NO_HOLES || index in self){\n      val = self[index];\n      res = f(val, index, O);\n      if(TYPE){\n        if(IS_MAP)result[index] = res;            // map\n        else if(res)switch(TYPE){\n          case 3: return true;                    // some\n          case 5: return val;                     // find\n          case 6: return index;                   // findIndex\n          case 2: result.push(val);               // filter\n        } else if(IS_EVERY)return false;          // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n  };\n};",
    "// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar isObject = require('./$.is-object')\n  , isArray  = require('./$.is-array')\n  , SPECIES  = require('./$.wks')('species');\nmodule.exports = function(original, length){\n  var C;\n  if(isArray(original)){\n    C = original.constructor;\n    // cross-realm fallback\n    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;\n    if(isObject(C)){\n      C = C[SPECIES];\n      if(C === null)C = undefined;\n    }\n  } return new (C === undefined ? Array : C)(length);\n};",
    "// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./$.cof')\n  , TAG = require('./$.wks')('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};",
    "var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};",
    "'use strict';\nvar $            = require('./$')\n  , hide         = require('./$.hide')\n  , redefineAll  = require('./$.redefine-all')\n  , ctx          = require('./$.ctx')\n  , strictNew    = require('./$.strict-new')\n  , defined      = require('./$.defined')\n  , forOf        = require('./$.for-of')\n  , $iterDefine  = require('./$.iter-define')\n  , step         = require('./$.iter-step')\n  , ID           = require('./$.uid')('id')\n  , $has         = require('./$.has')\n  , isObject     = require('./$.is-object')\n  , setSpecies   = require('./$.set-species')\n  , DESCRIPTORS  = require('./$.descriptors')\n  , isExtensible = Object.isExtensible || isObject\n  , SIZE         = DESCRIPTORS ? '_s' : 'size'\n  , id           = 0;\n\nvar fastKey = function(it, create){\n  // return primitive with prefix\n  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if(!$has(it, ID)){\n    // can't set id to frozen object\n    if(!isExtensible(it))return 'F';\n    // not necessary to add id\n    if(!create)return 'E';\n    // add missing object id\n    hide(it, ID, ++id);\n  // return object id with prefix\n  } return 'O' + it[ID];\n};\n\nvar getEntry = function(that, key){\n  // fast case\n  var index = fastKey(key), entry;\n  if(index !== 'F')return that._i[index];\n  // frozen object case\n  for(entry = that._f; entry; entry = entry.n){\n    if(entry.k == key)return entry;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){\n    var C = wrapper(function(that, iterable){\n      strictNew(that, C, NAME);\n      that._i = $.create(null); // index\n      that._f = undefined;      // first entry\n      that._l = undefined;      // last entry\n      that[SIZE] = 0;           // size\n      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear(){\n        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){\n          entry.r = true;\n          if(entry.p)entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function(key){\n        var that  = this\n          , entry = getEntry(that, key);\n        if(entry){\n          var next = entry.n\n            , prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if(prev)prev.n = next;\n          if(next)next.p = prev;\n          if(that._f == entry)that._f = next;\n          if(that._l == entry)that._l = prev;\n          that[SIZE]--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /*, that = undefined */){\n        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)\n          , entry;\n        while(entry = entry ? entry.n : this._f){\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while(entry && entry.r)entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key){\n        return !!getEntry(this, key);\n      }\n    });\n    if(DESCRIPTORS)$.setDesc(C.prototype, 'size', {\n      get: function(){\n        return defined(this[SIZE]);\n      }\n    });\n    return C;\n  },\n  def: function(that, key, value){\n    var entry = getEntry(that, key)\n      , prev, index;\n    // change existing entry\n    if(entry){\n      entry.v = value;\n    // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key,                        // <- key\n        v: value,                      // <- value\n        p: prev = that._l,             // <- previous entry\n        n: undefined,                  // <- next entry\n        r: false                       // <- removed\n      };\n      if(!that._f)that._f = entry;\n      if(prev)prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if(index !== 'F')that._i[index] = entry;\n    } return that;\n  },\n  getEntry: getEntry,\n  setStrong: function(C, NAME, IS_MAP){\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    $iterDefine(C, NAME, function(iterated, kind){\n      this._t = iterated;  // target\n      this._k = kind;      // kind\n      this._l = undefined; // previous\n    }, function(){\n      var that  = this\n        , kind  = that._k\n        , entry = that._l;\n      // revert to the last existing entry\n      while(entry && entry.r)entry = entry.p;\n      // get next entry\n      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){\n        // or finish the iteration\n        that._t = undefined;\n        return step(1);\n      }\n      // return step by kind\n      if(kind == 'keys'  )return step(0, entry.k);\n      if(kind == 'values')return step(0, entry.v);\n      return step(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    setSpecies(NAME);\n  }\n};",
    "// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar forOf   = require('./$.for-of')\n  , classof = require('./$.classof');\nmodule.exports = function(NAME){\n  return function toJSON(){\n    if(classof(this) != NAME)throw TypeError(NAME + \"#toJSON isn't generic\");\n    var arr = [];\n    forOf(this, false, arr.push, arr);\n    return arr;\n  };\n};",
    "'use strict';\nvar hide              = require('./$.hide')\n  , redefineAll       = require('./$.redefine-all')\n  , anObject          = require('./$.an-object')\n  , isObject          = require('./$.is-object')\n  , strictNew         = require('./$.strict-new')\n  , forOf             = require('./$.for-of')\n  , createArrayMethod = require('./$.array-methods')\n  , $has              = require('./$.has')\n  , WEAK              = require('./$.uid')('weak')\n  , isExtensible      = Object.isExtensible || isObject\n  , arrayFind         = createArrayMethod(5)\n  , arrayFindIndex    = createArrayMethod(6)\n  , id                = 0;\n\n// fallback for frozen keys\nvar frozenStore = function(that){\n  return that._l || (that._l = new FrozenStore);\n};\nvar FrozenStore = function(){\n  this.a = [];\n};\nvar findFrozen = function(store, key){\n  return arrayFind(store.a, function(it){\n    return it[0] === key;\n  });\n};\nFrozenStore.prototype = {\n  get: function(key){\n    var entry = findFrozen(this, key);\n    if(entry)return entry[1];\n  },\n  has: function(key){\n    return !!findFrozen(this, key);\n  },\n  set: function(key, value){\n    var entry = findFrozen(this, key);\n    if(entry)entry[1] = value;\n    else this.a.push([key, value]);\n  },\n  'delete': function(key){\n    var index = arrayFindIndex(this.a, function(it){\n      return it[0] === key;\n    });\n    if(~index)this.a.splice(index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){\n    var C = wrapper(function(that, iterable){\n      strictNew(that, C, NAME);\n      that._i = id++;      // collection id\n      that._l = undefined; // leak store for frozen objects\n      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.3.3.2 WeakMap.prototype.delete(key)\n      // 23.4.3.3 WeakSet.prototype.delete(value)\n      'delete': function(key){\n        if(!isObject(key))return false;\n        if(!isExtensible(key))return frozenStore(this)['delete'](key);\n        return $has(key, WEAK) && $has(key[WEAK], this._i) && delete key[WEAK][this._i];\n      },\n      // 23.3.3.4 WeakMap.prototype.has(key)\n      // 23.4.3.4 WeakSet.prototype.has(value)\n      has: function has(key){\n        if(!isObject(key))return false;\n        if(!isExtensible(key))return frozenStore(this).has(key);\n        return $has(key, WEAK) && $has(key[WEAK], this._i);\n      }\n    });\n    return C;\n  },\n  def: function(that, key, value){\n    if(!isExtensible(anObject(key))){\n      frozenStore(that).set(key, value);\n    } else {\n      $has(key, WEAK) || hide(key, WEAK, {});\n      key[WEAK][that._i] = value;\n    } return that;\n  },\n  frozenStore: frozenStore,\n  WEAK: WEAK\n};",
    "'use strict';\nvar global         = require('./$.global')\n  , $export        = require('./$.export')\n  , redefine       = require('./$.redefine')\n  , redefineAll    = require('./$.redefine-all')\n  , forOf          = require('./$.for-of')\n  , strictNew      = require('./$.strict-new')\n  , isObject       = require('./$.is-object')\n  , fails          = require('./$.fails')\n  , $iterDetect    = require('./$.iter-detect')\n  , setToStringTag = require('./$.set-to-string-tag');\n\nmodule.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){\n  var Base  = global[NAME]\n    , C     = Base\n    , ADDER = IS_MAP ? 'set' : 'add'\n    , proto = C && C.prototype\n    , O     = {};\n  var fixMethod = function(KEY){\n    var fn = proto[KEY];\n    redefine(proto, KEY,\n      KEY == 'delete' ? function(a){\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'has' ? function has(a){\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'get' ? function get(a){\n        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }\n        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }\n    );\n  };\n  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){\n    new C().entries().next();\n  }))){\n    // create collection constructor\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n    redefineAll(C.prototype, methods);\n  } else {\n    var instance             = new C\n      // early implementations not supports chaining\n      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance\n      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false\n      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })\n      // most early implementations doesn't supports iterables, most modern - not close it correctly\n      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new\n      // for early implementations -0 and +0 not the same\n      , BUGGY_ZERO;\n    if(!ACCEPT_ITERABLES){ \n      C = wrapper(function(target, iterable){\n        strictNew(target, C, NAME);\n        var that = new Base;\n        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n        return that;\n      });\n      C.prototype = proto;\n      proto.constructor = C;\n    }\n    IS_WEAK || instance.forEach(function(val, key){\n      BUGGY_ZERO = 1 / key === -Infinity;\n    });\n    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){\n      fixMethod('delete');\n      fixMethod('has');\n      IS_MAP && fixMethod('get');\n    }\n    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);\n    // weak collections should not contains .clear method\n    if(IS_WEAK && proto.clear)delete proto.clear;\n  }\n\n  setToStringTag(C, NAME);\n\n  O[NAME] = C;\n  $export($export.G + $export.W + $export.F * (C != Base), O);\n\n  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);\n\n  return C;\n};",
    "var core = module.exports = {version: '1.2.6'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef",
    "// optional / simple context binding\nvar aFunction = require('./$.a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};",
    "// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};",
    "// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./$.fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});",
    "var isObject = require('./$.is-object')\n  , document = require('./$.global').document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};",
    "// all enumerable object keys, includes symbols\nvar $ = require('./$');\nmodule.exports = function(it){\n  var keys       = $.getKeys(it)\n    , getSymbols = $.getSymbols;\n  if(getSymbols){\n    var symbols = getSymbols(it)\n      , isEnum  = $.isEnum\n      , i       = 0\n      , key;\n    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);\n  }\n  return keys;\n};",
    "var global    = require('./$.global')\n  , core      = require('./$.core')\n  , hide      = require('./$.hide')\n  , redefine  = require('./$.redefine')\n  , ctx       = require('./$.ctx')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})\n    , key, own, out, exp;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && key in target;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if(target && !own)redefine(target, key, out);\n    // export\n    if(exports[key] != out)hide(exports, key, exp);\n    if(IS_PROTO && expProto[key] != out)expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;  // forced\n$export.G = 2;  // global\n$export.S = 4;  // static\n$export.P = 8;  // proto\n$export.B = 16; // bind\n$export.W = 32; // wrap\nmodule.exports = $export;",
    "var MATCH = require('./$.wks')('match');\nmodule.exports = function(KEY){\n  var re = /./;\n  try {\n    '/./'[KEY](re);\n  } catch(e){\n    try {\n      re[MATCH] = false;\n      return !'/./'[KEY](re);\n    } catch(f){ /* empty */ }\n  } return true;\n};",
    "module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};",
    "'use strict';\nvar hide     = require('./$.hide')\n  , redefine = require('./$.redefine')\n  , fails    = require('./$.fails')\n  , defined  = require('./$.defined')\n  , wks      = require('./$.wks');\n\nmodule.exports = function(KEY, length, exec){\n  var SYMBOL   = wks(KEY)\n    , original = ''[KEY];\n  if(fails(function(){\n    var O = {};\n    O[SYMBOL] = function(){ return 7; };\n    return ''[KEY](O) != 7;\n  })){\n    redefine(String.prototype, KEY, exec(defined, SYMBOL, original));\n    hide(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function(string, arg){ return original.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function(string){ return original.call(string, this); }\n    );\n  }\n};",
    "'use strict';\n// 21.2.5.3 get RegExp.prototype.flags\nvar anObject = require('./$.an-object');\nmodule.exports = function(){\n  var that   = anObject(this)\n    , result = '';\n  if(that.global)     result += 'g';\n  if(that.ignoreCase) result += 'i';\n  if(that.multiline)  result += 'm';\n  if(that.unicode)    result += 'u';\n  if(that.sticky)     result += 'y';\n  return result;\n};",
    "var ctx         = require('./$.ctx')\n  , call        = require('./$.iter-call')\n  , isArrayIter = require('./$.is-array-iter')\n  , anObject    = require('./$.an-object')\n  , toLength    = require('./$.to-length')\n  , getIterFn   = require('./core.get-iterator-method');\nmodule.exports = function(iterable, entries, fn, that){\n  var iterFn = getIterFn(iterable)\n    , f      = ctx(fn, that, entries ? 2 : 1)\n    , index  = 0\n    , length, step, iterator;\n  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){\n    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){\n    call(iterator, f, step.value, entries);\n  }\n};",
    "// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./$.to-iobject')\n  , getNames  = require('./$').getNames\n  , toString  = {}.toString;\n\nvar windowNames = typeof window == 'object' && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function(it){\n  try {\n    return getNames(it);\n  } catch(e){\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.get = function getOwnPropertyNames(it){\n  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);\n  return getNames(toIObject(it));\n};",
    "// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef",
    "var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};",
    "var $          = require('./$')\n  , createDesc = require('./$.property-desc');\nmodule.exports = require('./$.descriptors') ? function(object, key, value){\n  return $.setDesc(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};",
    "module.exports = require('./$.global').document && document.documentElement;",
    "// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function(fn, args, that){\n  var un = that === undefined;\n  switch(args.length){\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return              fn.apply(that, args);\n};",
    "// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./$.cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};",
    "// check on default Array iterator\nvar Iterators  = require('./$.iterators')\n  , ITERATOR   = require('./$.wks')('iterator')\n  , ArrayProto = Array.prototype;\n\nmodule.exports = function(it){\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};",
    "// 7.2.2 IsArray(argument)\nvar cof = require('./$.cof');\nmodule.exports = Array.isArray || function(arg){\n  return cof(arg) == 'Array';\n};",
    "// 20.1.2.3 Number.isInteger(number)\nvar isObject = require('./$.is-object')\n  , floor    = Math.floor;\nmodule.exports = function isInteger(it){\n  return !isObject(it) && isFinite(it) && floor(it) === it;\n};",
    "module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};",
    "// 7.2.8 IsRegExp(argument)\nvar isObject = require('./$.is-object')\n  , cof      = require('./$.cof')\n  , MATCH    = require('./$.wks')('match');\nmodule.exports = function(it){\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\n};",
    "// call something on iterator step with safe closing on error\nvar anObject = require('./$.an-object');\nmodule.exports = function(iterator, fn, value, entries){\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch(e){\n    var ret = iterator['return'];\n    if(ret !== undefined)anObject(ret.call(iterator));\n    throw e;\n  }\n};",
    "'use strict';\nvar $              = require('./$')\n  , descriptor     = require('./$.property-desc')\n  , setToStringTag = require('./$.set-to-string-tag')\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./$.hide')(IteratorPrototype, require('./$.wks')('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};",
    "'use strict';\nvar LIBRARY        = require('./$.library')\n  , $export        = require('./$.export')\n  , redefine       = require('./$.redefine')\n  , hide           = require('./$.hide')\n  , has            = require('./$.has')\n  , Iterators      = require('./$.iterators')\n  , $iterCreate    = require('./$.iter-create')\n  , setToStringTag = require('./$.set-to-string-tag')\n  , getProto       = require('./$').getProto\n  , ITERATOR       = require('./$.wks')('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , methods, key;\n  // Fix native\n  if($native){\n    var IteratorPrototype = getProto($default.call(new Base));\n    // Set @@toStringTag to native iterators\n    setToStringTag(IteratorPrototype, TAG, true);\n    // FF fix\n    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    // fix Array#{values, @@iterator}.name in V8 / FF\n    if(DEF_VALUES && $native.name !== VALUES){\n      VALUES_BUG = true;\n      $default = function values(){ return $native.call(this); };\n    }\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES  ? $default : getMethod(VALUES),\n      keys:    IS_SET      ? $default : getMethod(KEYS),\n      entries: !DEF_VALUES ? $default : getMethod('entries')\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};",
    "var ITERATOR     = require('./$.wks')('iterator')\n  , SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function(){ SAFE_CLOSING = true; };\n  Array.from(riter, function(){ throw 2; });\n} catch(e){ /* empty */ }\n\nmodule.exports = function(exec, skipClosing){\n  if(!skipClosing && !SAFE_CLOSING)return false;\n  var safe = false;\n  try {\n    var arr  = [7]\n      , iter = arr[ITERATOR]();\n    iter.next = function(){ safe = true; };\n    arr[ITERATOR] = function(){ return iter; };\n    exec(arr);\n  } catch(e){ /* empty */ }\n  return safe;\n};",
    "module.exports = function(done, value){\n  return {value: value, done: !!done};\n};",
    "module.exports = {};",
    "var $Object = Object;\nmodule.exports = {\n  create:     $Object.create,\n  getProto:   $Object.getPrototypeOf,\n  isEnum:     {}.propertyIsEnumerable,\n  getDesc:    $Object.getOwnPropertyDescriptor,\n  setDesc:    $Object.defineProperty,\n  setDescs:   $Object.defineProperties,\n  getKeys:    $Object.keys,\n  getNames:   $Object.getOwnPropertyNames,\n  getSymbols: $Object.getOwnPropertySymbols,\n  each:       [].forEach\n};",
    "var $         = require('./$')\n  , toIObject = require('./$.to-iobject');\nmodule.exports = function(object, el){\n  var O      = toIObject(object)\n    , keys   = $.getKeys(O)\n    , length = keys.length\n    , index  = 0\n    , key;\n  while(length > index)if(O[key = keys[index++]] === el)return key;\n};",
    "module.exports = false;",
    "// 20.2.2.14 Math.expm1(x)\nmodule.exports = Math.expm1 || function expm1(x){\n  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;\n};",
    "// 20.2.2.20 Math.log1p(x)\nmodule.exports = Math.log1p || function log1p(x){\n  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);\n};",
    "// 20.2.2.28 Math.sign(x)\nmodule.exports = Math.sign || function sign(x){\n  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n};",
    "var global    = require('./$.global')\n  , macrotask = require('./$.task').set\n  , Observer  = global.MutationObserver || global.WebKitMutationObserver\n  , process   = global.process\n  , Promise   = global.Promise\n  , isNode    = require('./$.cof')(process) == 'process'\n  , head, last, notify;\n\nvar flush = function(){\n  var parent, domain, fn;\n  if(isNode && (parent = process.domain)){\n    process.domain = null;\n    parent.exit();\n  }\n  while(head){\n    domain = head.domain;\n    fn     = head.fn;\n    if(domain)domain.enter();\n    fn(); // <- currently we use it only for Promise - try / catch not required\n    if(domain)domain.exit();\n    head = head.next;\n  } last = undefined;\n  if(parent)parent.enter();\n};\n\n// Node.js\nif(isNode){\n  notify = function(){\n    process.nextTick(flush);\n  };\n// browsers with MutationObserver\n} else if(Observer){\n  var toggle = 1\n    , node   = document.createTextNode('');\n  new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new\n  notify = function(){\n    node.data = toggle = -toggle;\n  };\n// environments with maybe non-completely correct, but existent Promise\n} else if(Promise && Promise.resolve){\n  notify = function(){\n    Promise.resolve().then(flush);\n  };\n// for other environments - macrotask based on:\n// - setImmediate\n// - MessageChannel\n// - window.postMessag\n// - onreadystatechange\n// - setTimeout\n} else {\n  notify = function(){\n    // strange IE + webpack dev server bug - use .call(global)\n    macrotask.call(global, flush);\n  };\n}\n\nmodule.exports = function asap(fn){\n  var task = {fn: fn, next: undefined, domain: isNode && process.domain};\n  if(last)last.next = task;\n  if(!head){\n    head = task;\n    notify();\n  } last = task;\n};",
    "// 19.1.2.1 Object.assign(target, source, ...)\nvar $        = require('./$')\n  , toObject = require('./$.to-object')\n  , IObject  = require('./$.iobject');\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = require('./$.fails')(function(){\n  var a = Object.assign\n    , A = {}\n    , B = {}\n    , S = Symbol()\n    , K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function(k){ B[k] = k; });\n  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;\n}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n  var T     = toObject(target)\n    , $$    = arguments\n    , $$len = $$.length\n    , index = 1\n    , getKeys    = $.getKeys\n    , getSymbols = $.getSymbols\n    , isEnum     = $.isEnum;\n  while($$len > index){\n    var S      = IObject($$[index++])\n      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n      , length = keys.length\n      , j      = 0\n      , key;\n    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n  }\n  return T;\n} : Object.assign;",
    "// most Object methods by ES6 should accept primitives\nvar $export = require('./$.export')\n  , core    = require('./$.core')\n  , fails   = require('./$.fails');\nmodule.exports = function(KEY, exec){\n  var fn  = (core.Object || {})[KEY] || Object[KEY]\n    , exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n};",
    "var $         = require('./$')\n  , toIObject = require('./$.to-iobject')\n  , isEnum    = $.isEnum;\nmodule.exports = function(isEntries){\n  return function(it){\n    var O      = toIObject(it)\n      , keys   = $.getKeys(O)\n      , length = keys.length\n      , i      = 0\n      , result = []\n      , key;\n    while(length > i)if(isEnum.call(O, key = keys[i++])){\n      result.push(isEntries ? [key, O[key]] : O[key]);\n    } return result;\n  };\n};",
    "// all object keys, includes non-enumerable and symbols\nvar $        = require('./$')\n  , anObject = require('./$.an-object')\n  , Reflect  = require('./$.global').Reflect;\nmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it){\n  var keys       = $.getNames(anObject(it))\n    , getSymbols = $.getSymbols;\n  return getSymbols ? keys.concat(getSymbols(it)) : keys;\n};",
    "'use strict';\nvar path      = require('./$.path')\n  , invoke    = require('./$.invoke')\n  , aFunction = require('./$.a-function');\nmodule.exports = function(/* ...pargs */){\n  var fn     = aFunction(this)\n    , length = arguments.length\n    , pargs  = Array(length)\n    , i      = 0\n    , _      = path._\n    , holder = false;\n  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;\n  return function(/* ...args */){\n    var that  = this\n      , $$    = arguments\n      , $$len = $$.length\n      , j = 0, k = 0, args;\n    if(!holder && !$$len)return invoke(fn, pargs, that);\n    args = pargs.slice();\n    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = $$[k++];\n    while($$len > k)args.push($$[k++]);\n    return invoke(fn, args, that);\n  };\n};",
    "module.exports = require('./$.global');",
    "module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};",
    "var redefine = require('./$.redefine');\nmodule.exports = function(target, src){\n  for(var key in src)redefine(target, key, src[key]);\n  return target;\n};",
    "// add fake Function#toString\n// for correct work wrapped methods / constructors with methods like LoDash isNative\nvar global    = require('./$.global')\n  , hide      = require('./$.hide')\n  , SRC       = require('./$.uid')('src')\n  , TO_STRING = 'toString'\n  , $toString = Function[TO_STRING]\n  , TPL       = ('' + $toString).split(TO_STRING);\n\nrequire('./$.core').inspectSource = function(it){\n  return $toString.call(it);\n};\n\n(module.exports = function(O, key, val, safe){\n  if(typeof val == 'function'){\n    val.hasOwnProperty(SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n    val.hasOwnProperty('name') || hide(val, 'name', key);\n  }\n  if(O === global){\n    O[key] = val;\n  } else {\n    if(!safe)delete O[key];\n    hide(O, key, val);\n  }\n})(Function.prototype, TO_STRING, function toString(){\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});",
    "module.exports = function(regExp, replace){\n  var replacer = replace === Object(replace) ? function(part){\n    return replace[part];\n  } : replace;\n  return function(it){\n    return String(it).replace(regExp, replacer);\n  };\n};",
    "// 7.2.9 SameValue(x, y)\nmodule.exports = Object.is || function is(x, y){\n  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\n};",
    "// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar getDesc  = require('./$').getDesc\n  , isObject = require('./$.is-object')\n  , anObject = require('./$.an-object');\nvar check = function(O, proto){\n  anObject(O);\n  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function(test, buggy, set){\n      try {\n        set = require('./$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch(e){ buggy = true; }\n      return function setPrototypeOf(O, proto){\n        check(O, proto);\n        if(buggy)O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};",
    "'use strict';\nvar global      = require('./$.global')\n  , $           = require('./$')\n  , DESCRIPTORS = require('./$.descriptors')\n  , SPECIES     = require('./$.wks')('species');\n\nmodule.exports = function(KEY){\n  var C = global[KEY];\n  if(DESCRIPTORS && C && !C[SPECIES])$.setDesc(C, SPECIES, {\n    configurable: true,\n    get: function(){ return this; }\n  });\n};",
    "var def = require('./$').setDesc\n  , has = require('./$.has')\n  , TAG = require('./$.wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};",
    "var global = require('./$.global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};",
    "// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject  = require('./$.an-object')\n  , aFunction = require('./$.a-function')\n  , SPECIES   = require('./$.wks')('species');\nmodule.exports = function(O, D){\n  var C = anObject(O).constructor, S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};",
    "module.exports = function(it, Constructor, name){\n  if(!(it instanceof Constructor))throw TypeError(name + \": use the 'new' operator!\");\n  return it;\n};",
    "var toInteger = require('./$.to-integer')\n  , defined   = require('./$.defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};",
    "// helper for String#{startsWith, endsWith, includes}\nvar isRegExp = require('./$.is-regexp')\n  , defined  = require('./$.defined');\n\nmodule.exports = function(that, searchString, NAME){\n  if(isRegExp(searchString))throw TypeError('String#' + NAME + \" doesn't accept regex!\");\n  return String(defined(that));\n};",
    "// https://github.com/ljharb/proposal-string-pad-left-right\nvar toLength = require('./$.to-length')\n  , repeat   = require('./$.string-repeat')\n  , defined  = require('./$.defined');\n\nmodule.exports = function(that, maxLength, fillString, left){\n  var S            = String(defined(that))\n    , stringLength = S.length\n    , fillStr      = fillString === undefined ? ' ' : String(fillString)\n    , intMaxLength = toLength(maxLength);\n  if(intMaxLength <= stringLength)return S;\n  if(fillStr == '')fillStr = ' ';\n  var fillLen = intMaxLength - stringLength\n    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));\n  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);\n  return left ? stringFiller + S : S + stringFiller;\n};",
    "'use strict';\nvar toInteger = require('./$.to-integer')\n  , defined   = require('./$.defined');\n\nmodule.exports = function repeat(count){\n  var str = String(defined(this))\n    , res = ''\n    , n   = toInteger(count);\n  if(n < 0 || n == Infinity)throw RangeError(\"Count can't be negative\");\n  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;\n  return res;\n};",
    "var $export = require('./$.export')\n  , defined = require('./$.defined')\n  , fails   = require('./$.fails')\n  , spaces  = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n      '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF'\n  , space   = '[' + spaces + ']'\n  , non     = '\\u200b\\u0085'\n  , ltrim   = RegExp('^' + space + space + '*')\n  , rtrim   = RegExp(space + space + '*$');\n\nvar exporter = function(KEY, exec){\n  var exp  = {};\n  exp[KEY] = exec(trim);\n  $export($export.P + $export.F * fails(function(){\n    return !!spaces[KEY]() || non[KEY]() != non;\n  }), 'String', exp);\n};\n\n// 1 -> String#trimLeft\n// 2 -> String#trimRight\n// 3 -> String#trim\nvar trim = exporter.trim = function(string, TYPE){\n  string = String(defined(string));\n  if(TYPE & 1)string = string.replace(ltrim, '');\n  if(TYPE & 2)string = string.replace(rtrim, '');\n  return string;\n};\n\nmodule.exports = exporter;",
    "var ctx                = require('./$.ctx')\n  , invoke             = require('./$.invoke')\n  , html               = require('./$.html')\n  , cel                = require('./$.dom-create')\n  , global             = require('./$.global')\n  , process            = global.process\n  , setTask            = global.setImmediate\n  , clearTask          = global.clearImmediate\n  , MessageChannel     = global.MessageChannel\n  , counter            = 0\n  , queue              = {}\n  , ONREADYSTATECHANGE = 'onreadystatechange'\n  , defer, channel, port;\nvar run = function(){\n  var id = +this;\n  if(queue.hasOwnProperty(id)){\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listner = function(event){\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif(!setTask || !clearTask){\n  setTask = function setImmediate(fn){\n    var args = [], i = 1;\n    while(arguments.length > i)args.push(arguments[i++]);\n    queue[++counter] = function(){\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id){\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if(require('./$.cof')(process) == 'process'){\n    defer = function(id){\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if(MessageChannel){\n    channel = new MessageChannel;\n    port    = channel.port2;\n    channel.port1.onmessage = listner;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){\n    defer = function(id){\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listner, false);\n  // IE8-\n  } else if(ONREADYSTATECHANGE in cel('script')){\n    defer = function(id){\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function(id){\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set:   setTask,\n  clear: clearTask\n};",
    "var toInteger = require('./$.to-integer')\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};",
    "// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};",
    "// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./$.iobject')\n  , defined = require('./$.defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};",
    "// 7.1.15 ToLength\nvar toInteger = require('./$.to-integer')\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};",
    "// 7.1.13 ToObject(argument)\nvar defined = require('./$.defined');\nmodule.exports = function(it){\n  return Object(defined(it));\n};",
    "// 7.1.1 ToPrimitive(input [, PreferredType])\r\nvar isObject = require('./$.is-object');\r\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\r\n// and the second argument - flag - preferred type is a string\r\nmodule.exports = function(it, S){\r\n  if(!isObject(it))return it;\r\n  var fn, val;\r\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\r\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\r\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\r\n  throw TypeError(\"Can't convert object to primitive value\");\r\n};",
    "var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};",
    "var store  = require('./$.shared')('wks')\n  , uid    = require('./$.uid')\n  , Symbol = require('./$.global').Symbol;\nmodule.exports = function(name){\n  return store[name] || (store[name] =\n    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));\n};",
    "var classof   = require('./$.classof')\n  , ITERATOR  = require('./$.wks')('iterator')\n  , Iterators = require('./$.iterators');\nmodule.exports = require('./$.core').getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};",
    "'use strict';\nvar $                 = require('./$')\n  , $export           = require('./$.export')\n  , DESCRIPTORS       = require('./$.descriptors')\n  , createDesc        = require('./$.property-desc')\n  , html              = require('./$.html')\n  , cel               = require('./$.dom-create')\n  , has               = require('./$.has')\n  , cof               = require('./$.cof')\n  , invoke            = require('./$.invoke')\n  , fails             = require('./$.fails')\n  , anObject          = require('./$.an-object')\n  , aFunction         = require('./$.a-function')\n  , isObject          = require('./$.is-object')\n  , toObject          = require('./$.to-object')\n  , toIObject         = require('./$.to-iobject')\n  , toInteger         = require('./$.to-integer')\n  , toIndex           = require('./$.to-index')\n  , toLength          = require('./$.to-length')\n  , IObject           = require('./$.iobject')\n  , IE_PROTO          = require('./$.uid')('__proto__')\n  , createArrayMethod = require('./$.array-methods')\n  , arrayIndexOf      = require('./$.array-includes')(false)\n  , ObjectProto       = Object.prototype\n  , ArrayProto        = Array.prototype\n  , arraySlice        = ArrayProto.slice\n  , arrayJoin         = ArrayProto.join\n  , defineProperty    = $.setDesc\n  , getOwnDescriptor  = $.getDesc\n  , defineProperties  = $.setDescs\n  , factories         = {}\n  , IE8_DOM_DEFINE;\n\nif(!DESCRIPTORS){\n  IE8_DOM_DEFINE = !fails(function(){\n    return defineProperty(cel('div'), 'a', {get: function(){ return 7; }}).a != 7;\n  });\n  $.setDesc = function(O, P, Attributes){\n    if(IE8_DOM_DEFINE)try {\n      return defineProperty(O, P, Attributes);\n    } catch(e){ /* empty */ }\n    if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n    if('value' in Attributes)anObject(O)[P] = Attributes.value;\n    return O;\n  };\n  $.getDesc = function(O, P){\n    if(IE8_DOM_DEFINE)try {\n      return getOwnDescriptor(O, P);\n    } catch(e){ /* empty */ }\n    if(has(O, P))return createDesc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);\n  };\n  $.setDescs = defineProperties = function(O, Properties){\n    anObject(O);\n    var keys   = $.getKeys(Properties)\n      , length = keys.length\n      , i = 0\n      , P;\n    while(length > i)$.setDesc(O, P = keys[i++], Properties[P]);\n    return O;\n  };\n}\n$export($export.S + $export.F * !DESCRIPTORS, 'Object', {\n  // 19.1.2.6 / 15.2.3.3 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $.getDesc,\n  // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n  defineProperty: $.setDesc,\n  // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)\n  defineProperties: defineProperties\n});\n\n  // IE 8- don't enum bug keys\nvar keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' +\n            'toLocaleString,toString,valueOf').split(',')\n  // Additional keys for getOwnPropertyNames\n  , keys2 = keys1.concat('length', 'prototype')\n  , keysLen1 = keys1.length;\n\n// Create object with `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = cel('iframe')\n    , i      = keysLen1\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write('<script>document.F=Object</script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict.prototype[keys1[i]];\n  return createDict();\n};\nvar createGetKeys = function(names, length){\n  return function(object){\n    var O      = toIObject(object)\n      , i      = 0\n      , result = []\n      , key;\n    for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n    // Don't enum bug & hidden keys\n    while(length > i)if(has(O, key = names[i++])){\n      ~arrayIndexOf(result, key) || result.push(key);\n    }\n    return result;\n  };\n};\nvar Empty = function(){};\n$export($export.S, 'Object', {\n  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\n  getPrototypeOf: $.getProto = $.getProto || function(O){\n    O = toObject(O);\n    if(has(O, IE_PROTO))return O[IE_PROTO];\n    if(typeof O.constructor == 'function' && O instanceof O.constructor){\n      return O.constructor.prototype;\n    } return O instanceof Object ? ObjectProto : null;\n  },\n  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),\n  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n  create: $.create = $.create || function(O, /*?*/Properties){\n    var result;\n    if(O !== null){\n      Empty.prototype = anObject(O);\n      result = new Empty();\n      Empty.prototype = null;\n      // add \"__proto__\" for Object.getPrototypeOf shim\n      result[IE_PROTO] = O;\n    } else result = createDict();\n    return Properties === undefined ? result : defineProperties(result, Properties);\n  },\n  // 19.1.2.14 / 15.2.3.14 Object.keys(O)\n  keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false)\n});\n\nvar construct = function(F, len, args){\n  if(!(len in factories)){\n    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';\n    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');\n  }\n  return factories[len](F, args);\n};\n\n// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)\n$export($export.P, 'Function', {\n  bind: function bind(that /*, args... */){\n    var fn       = aFunction(this)\n      , partArgs = arraySlice.call(arguments, 1);\n    var bound = function(/* args... */){\n      var args = partArgs.concat(arraySlice.call(arguments));\n      return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);\n    };\n    if(isObject(fn.prototype))bound.prototype = fn.prototype;\n    return bound;\n  }\n});\n\n// fallback for not array-like ES3 strings and DOM objects\n$export($export.P + $export.F * fails(function(){\n  if(html)arraySlice.call(html);\n}), 'Array', {\n  slice: function(begin, end){\n    var len   = toLength(this.length)\n      , klass = cof(this);\n    end = end === undefined ? len : end;\n    if(klass == 'Array')return arraySlice.call(this, begin, end);\n    var start  = toIndex(begin, len)\n      , upTo   = toIndex(end, len)\n      , size   = toLength(upTo - start)\n      , cloned = Array(size)\n      , i      = 0;\n    for(; i < size; i++)cloned[i] = klass == 'String'\n      ? this.charAt(start + i)\n      : this[start + i];\n    return cloned;\n  }\n});\n$export($export.P + $export.F * (IObject != Object), 'Array', {\n  join: function join(separator){\n    return arrayJoin.call(IObject(this), separator === undefined ? ',' : separator);\n  }\n});\n\n// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)\n$export($export.S, 'Array', {isArray: require('./$.is-array')});\n\nvar createArrayReduce = function(isRight){\n  return function(callbackfn, memo){\n    aFunction(callbackfn);\n    var O      = IObject(this)\n      , length = toLength(O.length)\n      , index  = isRight ? length - 1 : 0\n      , i      = isRight ? -1 : 1;\n    if(arguments.length < 2)for(;;){\n      if(index in O){\n        memo = O[index];\n        index += i;\n        break;\n      }\n      index += i;\n      if(isRight ? index < 0 : length <= index){\n        throw TypeError('Reduce of empty array with no initial value');\n      }\n    }\n    for(;isRight ? index >= 0 : length > index; index += i)if(index in O){\n      memo = callbackfn(memo, O[index], index, this);\n    }\n    return memo;\n  };\n};\n\nvar methodize = function($fn){\n  return function(arg1/*, arg2 = undefined */){\n    return $fn(this, arg1, arguments[1]);\n  };\n};\n\n$export($export.P, 'Array', {\n  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])\n  forEach: $.each = $.each || methodize(createArrayMethod(0)),\n  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])\n  map: methodize(createArrayMethod(1)),\n  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])\n  filter: methodize(createArrayMethod(2)),\n  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])\n  some: methodize(createArrayMethod(3)),\n  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])\n  every: methodize(createArrayMethod(4)),\n  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])\n  reduce: createArrayReduce(false),\n  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])\n  reduceRight: createArrayReduce(true),\n  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])\n  indexOf: methodize(arrayIndexOf),\n  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])\n  lastIndexOf: function(el, fromIndex /* = @[*-1] */){\n    var O      = toIObject(this)\n      , length = toLength(O.length)\n      , index  = length - 1;\n    if(arguments.length > 1)index = Math.min(index, toInteger(fromIndex));\n    if(index < 0)index = toLength(length + index);\n    for(;index >= 0; index--)if(index in O)if(O[index] === el)return index;\n    return -1;\n  }\n});\n\n// 20.3.3.1 / 15.9.4.4 Date.now()\n$export($export.S, 'Date', {now: function(){ return +new Date; }});\n\nvar lz = function(num){\n  return num > 9 ? num : '0' + num;\n};\n\n// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()\n// PhantomJS / old WebKit has a broken implementations\n$export($export.P + $export.F * (fails(function(){\n  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';\n}) || !fails(function(){\n  new Date(NaN).toISOString();\n})), 'Date', {\n  toISOString: function toISOString(){\n    if(!isFinite(this))throw RangeError('Invalid time value');\n    var d = this\n      , y = d.getUTCFullYear()\n      , m = d.getUTCMilliseconds()\n      , s = y < 0 ? '-' : y > 9999 ? '+' : '';\n    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +\n      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +\n      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +\n      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';\n  }\n});",
    "// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\nvar $export = require('./$.export');\n\n$export($export.P, 'Array', {copyWithin: require('./$.array-copy-within')});\n\nrequire('./$.add-to-unscopables')('copyWithin');",
    "// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\nvar $export = require('./$.export');\n\n$export($export.P, 'Array', {fill: require('./$.array-fill')});\n\nrequire('./$.add-to-unscopables')('fill');",
    "'use strict';\n// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)\nvar $export = require('./$.export')\n  , $find   = require('./$.array-methods')(6)\n  , KEY     = 'findIndex'\n  , forced  = true;\n// Shouldn't skip holes\nif(KEY in [])Array(1)[KEY](function(){ forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  findIndex: function findIndex(callbackfn/*, that = undefined */){\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\nrequire('./$.add-to-unscopables')(KEY);",
    "'use strict';\n// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\nvar $export = require('./$.export')\n  , $find   = require('./$.array-methods')(5)\n  , KEY     = 'find'\n  , forced  = true;\n// Shouldn't skip holes\nif(KEY in [])Array(1)[KEY](function(){ forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  find: function find(callbackfn/*, that = undefined */){\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\nrequire('./$.add-to-unscopables')(KEY);",
    "'use strict';\nvar ctx         = require('./$.ctx')\n  , $export     = require('./$.export')\n  , toObject    = require('./$.to-object')\n  , call        = require('./$.iter-call')\n  , isArrayIter = require('./$.is-array-iter')\n  , toLength    = require('./$.to-length')\n  , getIterFn   = require('./core.get-iterator-method');\n$export($export.S + $export.F * !require('./$.iter-detect')(function(iter){ Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\n    var O       = toObject(arrayLike)\n      , C       = typeof this == 'function' ? this : Array\n      , $$      = arguments\n      , $$len   = $$.length\n      , mapfn   = $$len > 1 ? $$[1] : undefined\n      , mapping = mapfn !== undefined\n      , index   = 0\n      , iterFn  = getIterFn(O)\n      , length, result, step, iterator;\n    if(mapping)mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){\n      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){\n        result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;\n      }\n    } else {\n      length = toLength(O.length);\n      for(result = new C(length); length > index; index++){\n        result[index] = mapping ? mapfn(O[index], index) : O[index];\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n",
    "'use strict';\nvar addToUnscopables = require('./$.add-to-unscopables')\n  , step             = require('./$.iter-step')\n  , Iterators        = require('./$.iterators')\n  , toIObject        = require('./$.to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./$.iter-define')(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');",
    "'use strict';\nvar $export = require('./$.export');\n\n// WebKit Array.of isn't generic\n$export($export.S + $export.F * require('./$.fails')(function(){\n  function F(){}\n  return !(Array.of.call(F) instanceof F);\n}), 'Array', {\n  // 22.1.2.3 Array.of( ...items)\n  of: function of(/* ...args */){\n    var index  = 0\n      , $$     = arguments\n      , $$len  = $$.length\n      , result = new (typeof this == 'function' ? this : Array)($$len);\n    while($$len > index)result[index] = $$[index++];\n    result.length = $$len;\n    return result;\n  }\n});",
    "require('./$.set-species')('Array');",
    "'use strict';\nvar $             = require('./$')\n  , isObject      = require('./$.is-object')\n  , HAS_INSTANCE  = require('./$.wks')('hasInstance')\n  , FunctionProto = Function.prototype;\n// 19.2.3.6 Function.prototype[@@hasInstance](V)\nif(!(HAS_INSTANCE in FunctionProto))$.setDesc(FunctionProto, HAS_INSTANCE, {value: function(O){\n  if(typeof this != 'function' || !isObject(O))return false;\n  if(!isObject(this.prototype))return O instanceof this;\n  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:\n  while(O = $.getProto(O))if(this.prototype === O)return true;\n  return false;\n}});",
    "var setDesc    = require('./$').setDesc\n  , createDesc = require('./$.property-desc')\n  , has        = require('./$.has')\n  , FProto     = Function.prototype\n  , nameRE     = /^\\s*function ([^ (]*)/\n  , NAME       = 'name';\n// 19.2.4.2 name\nNAME in FProto || require('./$.descriptors') && setDesc(FProto, NAME, {\n  configurable: true,\n  get: function(){\n    var match = ('' + this).match(nameRE)\n      , name  = match ? match[1] : '';\n    has(this, NAME) || setDesc(this, NAME, createDesc(5, name));\n    return name;\n  }\n});",
    "'use strict';\nvar strong = require('./$.collection-strong');\n\n// 23.1 Map Objects\nrequire('./$.collection')('Map', function(get){\n  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.1.3.6 Map.prototype.get(key)\n  get: function get(key){\n    var entry = strong.getEntry(this, key);\n    return entry && entry.v;\n  },\n  // 23.1.3.9 Map.prototype.set(key, value)\n  set: function set(key, value){\n    return strong.def(this, key === 0 ? 0 : key, value);\n  }\n}, strong, true);",
    "// 20.2.2.3 Math.acosh(x)\nvar $export = require('./$.export')\n  , log1p   = require('./$.math-log1p')\n  , sqrt    = Math.sqrt\n  , $acosh  = Math.acosh;\n\n// V8 bug https://code.google.com/p/v8/issues/detail?id=3509\n$export($export.S + $export.F * !($acosh && Math.floor($acosh(Number.MAX_VALUE)) == 710), 'Math', {\n  acosh: function acosh(x){\n    return (x = +x) < 1 ? NaN : x > 94906265.62425156\n      ? Math.log(x) + Math.LN2\n      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));\n  }\n});",
    "// 20.2.2.5 Math.asinh(x)\nvar $export = require('./$.export');\n\nfunction asinh(x){\n  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));\n}\n\n$export($export.S, 'Math', {asinh: asinh});",
    "// 20.2.2.7 Math.atanh(x)\nvar $export = require('./$.export');\n\n$export($export.S, 'Math', {\n  atanh: function atanh(x){\n    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;\n  }\n});",
    "// 20.2.2.9 Math.cbrt(x)\nvar $export = require('./$.export')\n  , sign    = require('./$.math-sign');\n\n$export($export.S, 'Math', {\n  cbrt: function cbrt(x){\n    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);\n  }\n});",
    "// 20.2.2.11 Math.clz32(x)\nvar $export = require('./$.export');\n\n$export($export.S, 'Math', {\n  clz32: function clz32(x){\n    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;\n  }\n});",
    "// 20.2.2.12 Math.cosh(x)\nvar $export = require('./$.export')\n  , exp     = Math.exp;\n\n$export($export.S, 'Math', {\n  cosh: function cosh(x){\n    return (exp(x = +x) + exp(-x)) / 2;\n  }\n});",
    "// 20.2.2.14 Math.expm1(x)\nvar $export = require('./$.export');\n\n$export($export.S, 'Math', {expm1: require('./$.math-expm1')});",
    "// 20.2.2.16 Math.fround(x)\nvar $export   = require('./$.export')\n  , sign      = require('./$.math-sign')\n  , pow       = Math.pow\n  , EPSILON   = pow(2, -52)\n  , EPSILON32 = pow(2, -23)\n  , MAX32     = pow(2, 127) * (2 - EPSILON32)\n  , MIN32     = pow(2, -126);\n\nvar roundTiesToEven = function(n){\n  return n + 1 / EPSILON - 1 / EPSILON;\n};\n\n\n$export($export.S, 'Math', {\n  fround: function fround(x){\n    var $abs  = Math.abs(x)\n      , $sign = sign(x)\n      , a, result;\n    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;\n    a = (1 + EPSILON32 / EPSILON) * $abs;\n    result = a - (a - $abs);\n    if(result > MAX32 || result != result)return $sign * Infinity;\n    return $sign * result;\n  }\n});",
    "// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])\nvar $export = require('./$.export')\n  , abs     = Math.abs;\n\n$export($export.S, 'Math', {\n  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars\n    var sum   = 0\n      , i     = 0\n      , $$    = arguments\n      , $$len = $$.length\n      , larg  = 0\n      , arg, div;\n    while(i < $$len){\n      arg = abs($$[i++]);\n      if(larg < arg){\n        div  = larg / arg;\n        sum  = sum * div * div + 1;\n        larg = arg;\n      } else if(arg > 0){\n        div  = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);\n  }\n});",
    "// 20.2.2.18 Math.imul(x, y)\nvar $export = require('./$.export')\n  , $imul   = Math.imul;\n\n// some WebKit versions fails with big numbers, some has wrong arity\n$export($export.S + $export.F * require('./$.fails')(function(){\n  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;\n}), 'Math', {\n  imul: function imul(x, y){\n    var UINT16 = 0xffff\n      , xn = +x\n      , yn = +y\n      , xl = UINT16 & xn\n      , yl = UINT16 & yn;\n    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);\n  }\n});",
    "// 20.2.2.21 Math.log10(x)\nvar $export = require('./$.export');\n\n$export($export.S, 'Math', {\n  log10: function log10(x){\n    return Math.log(x) / Math.LN10;\n  }\n});",
    "// 20.2.2.20 Math.log1p(x)\nvar $export = require('./$.export');\n\n$export($export.S, 'Math', {log1p: require('./$.math-log1p')});",
    "// 20.2.2.22 Math.log2(x)\nvar $export = require('./$.export');\n\n$export($export.S, 'Math', {\n  log2: function log2(x){\n    return Math.log(x) / Math.LN2;\n  }\n});",
    "// 20.2.2.28 Math.sign(x)\nvar $export = require('./$.export');\n\n$export($export.S, 'Math', {sign: require('./$.math-sign')});",
    "// 20.2.2.30 Math.sinh(x)\nvar $export = require('./$.export')\n  , expm1   = require('./$.math-expm1')\n  , exp     = Math.exp;\n\n// V8 near Chromium 38 has a problem with very small numbers\n$export($export.S + $export.F * require('./$.fails')(function(){\n  return !Math.sinh(-2e-17) != -2e-17;\n}), 'Math', {\n  sinh: function sinh(x){\n    return Math.abs(x = +x) < 1\n      ? (expm1(x) - expm1(-x)) / 2\n      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);\n  }\n});",
    "// 20.2.2.33 Math.tanh(x)\nvar $export = require('./$.export')\n  , expm1   = require('./$.math-expm1')\n  , exp     = Math.exp;\n\n$export($export.S, 'Math', {\n  tanh: function tanh(x){\n    var a = expm1(x = +x)\n      , b = expm1(-x);\n    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));\n  }\n});",
    "// 20.2.2.34 Math.trunc(x)\nvar $export = require('./$.export');\n\n$export($export.S, 'Math', {\n  trunc: function trunc(it){\n    return (it > 0 ? Math.floor : Math.ceil)(it);\n  }\n});",
    "'use strict';\nvar $           = require('./$')\n  , global      = require('./$.global')\n  , has         = require('./$.has')\n  , cof         = require('./$.cof')\n  , toPrimitive = require('./$.to-primitive')\n  , fails       = require('./$.fails')\n  , $trim       = require('./$.string-trim').trim\n  , NUMBER      = 'Number'\n  , $Number     = global[NUMBER]\n  , Base        = $Number\n  , proto       = $Number.prototype\n  // Opera ~12 has broken Object#toString\n  , BROKEN_COF  = cof($.create(proto)) == NUMBER\n  , TRIM        = 'trim' in String.prototype;\n\n// 7.1.3 ToNumber(argument)\nvar toNumber = function(argument){\n  var it = toPrimitive(argument, false);\n  if(typeof it == 'string' && it.length > 2){\n    it = TRIM ? it.trim() : $trim(it, 3);\n    var first = it.charCodeAt(0)\n      , third, radix, maxCode;\n    if(first === 43 || first === 45){\n      third = it.charCodeAt(2);\n      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix\n    } else if(first === 48){\n      switch(it.charCodeAt(1)){\n        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i\n        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i\n        default : return +it;\n      }\n      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){\n        code = digits.charCodeAt(i);\n        // parseInt parses a string to a first unavailable symbol\n        // but ToNumber should return NaN if a string contains unavailable symbols\n        if(code < 48 || code > maxCode)return NaN;\n      } return parseInt(digits, radix);\n    }\n  } return +it;\n};\n\nif(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){\n  $Number = function Number(value){\n    var it = arguments.length < 1 ? 0 : value\n      , that = this;\n    return that instanceof $Number\n      // check on 1..constructor(foo) case\n      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)\n        ? new Base(toNumber(it)) : toNumber(it);\n  };\n  $.each.call(require('./$.descriptors') ? $.getNames(Base) : (\n    // ES3:\n    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +\n    // ES6 (in case, if modules with ES6 Number statics required before):\n    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +\n    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'\n  ).split(','), function(key){\n    if(has(Base, key) && !has($Number, key)){\n      $.setDesc($Number, key, $.getDesc(Base, key));\n    }\n  });\n  $Number.prototype = proto;\n  proto.constructor = $Number;\n  require('./$.redefine')(global, NUMBER, $Number);\n}",
    "// 20.1.2.1 Number.EPSILON\nvar $export = require('./$.export');\n\n$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});",
    "// 20.1.2.2 Number.isFinite(number)\nvar $export   = require('./$.export')\n  , _isFinite = require('./$.global').isFinite;\n\n$export($export.S, 'Number', {\n  isFinite: function isFinite(it){\n    return typeof it == 'number' && _isFinite(it);\n  }\n});",
    "// 20.1.2.3 Number.isInteger(number)\nvar $export = require('./$.export');\n\n$export($export.S, 'Number', {isInteger: require('./$.is-integer')});",
    "// 20.1.2.4 Number.isNaN(number)\nvar $export = require('./$.export');\n\n$export($export.S, 'Number', {\n  isNaN: function isNaN(number){\n    return number != number;\n  }\n});",
    "// 20.1.2.5 Number.isSafeInteger(number)\nvar $export   = require('./$.export')\n  , isInteger = require('./$.is-integer')\n  , abs       = Math.abs;\n\n$export($export.S, 'Number', {\n  isSafeInteger: function isSafeInteger(number){\n    return isInteger(number) && abs(number) <= 0x1fffffffffffff;\n  }\n});",
    "// 20.1.2.6 Number.MAX_SAFE_INTEGER\nvar $export = require('./$.export');\n\n$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});",
    "// 20.1.2.10 Number.MIN_SAFE_INTEGER\nvar $export = require('./$.export');\n\n$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});",
    "// 20.1.2.12 Number.parseFloat(string)\nvar $export = require('./$.export');\n\n$export($export.S, 'Number', {parseFloat: parseFloat});",
    "// 20.1.2.13 Number.parseInt(string, radix)\nvar $export = require('./$.export');\n\n$export($export.S, 'Number', {parseInt: parseInt});",
    "// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./$.export');\n\n$export($export.S + $export.F, 'Object', {assign: require('./$.object-assign')});",
    "// 19.1.2.5 Object.freeze(O)\nvar isObject = require('./$.is-object');\n\nrequire('./$.object-sap')('freeze', function($freeze){\n  return function freeze(it){\n    return $freeze && isObject(it) ? $freeze(it) : it;\n  };\n});",
    "// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\nvar toIObject = require('./$.to-iobject');\n\nrequire('./$.object-sap')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor){\n  return function getOwnPropertyDescriptor(it, key){\n    return $getOwnPropertyDescriptor(toIObject(it), key);\n  };\n});",
    "// 19.1.2.7 Object.getOwnPropertyNames(O)\nrequire('./$.object-sap')('getOwnPropertyNames', function(){\n  return require('./$.get-names').get;\n});",
    "// 19.1.2.9 Object.getPrototypeOf(O)\nvar toObject = require('./$.to-object');\n\nrequire('./$.object-sap')('getPrototypeOf', function($getPrototypeOf){\n  return function getPrototypeOf(it){\n    return $getPrototypeOf(toObject(it));\n  };\n});",
    "// 19.1.2.11 Object.isExtensible(O)\nvar isObject = require('./$.is-object');\n\nrequire('./$.object-sap')('isExtensible', function($isExtensible){\n  return function isExtensible(it){\n    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;\n  };\n});",
    "// 19.1.2.12 Object.isFrozen(O)\nvar isObject = require('./$.is-object');\n\nrequire('./$.object-sap')('isFrozen', function($isFrozen){\n  return function isFrozen(it){\n    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;\n  };\n});",
    "// 19.1.2.13 Object.isSealed(O)\nvar isObject = require('./$.is-object');\n\nrequire('./$.object-sap')('isSealed', function($isSealed){\n  return function isSealed(it){\n    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;\n  };\n});",
    "// 19.1.3.10 Object.is(value1, value2)\nvar $export = require('./$.export');\n$export($export.S, 'Object', {is: require('./$.same-value')});",
    "// 19.1.2.14 Object.keys(O)\nvar toObject = require('./$.to-object');\n\nrequire('./$.object-sap')('keys', function($keys){\n  return function keys(it){\n    return $keys(toObject(it));\n  };\n});",
    "// 19.1.2.15 Object.preventExtensions(O)\nvar isObject = require('./$.is-object');\n\nrequire('./$.object-sap')('preventExtensions', function($preventExtensions){\n  return function preventExtensions(it){\n    return $preventExtensions && isObject(it) ? $preventExtensions(it) : it;\n  };\n});",
    "// 19.1.2.17 Object.seal(O)\nvar isObject = require('./$.is-object');\n\nrequire('./$.object-sap')('seal', function($seal){\n  return function seal(it){\n    return $seal && isObject(it) ? $seal(it) : it;\n  };\n});",
    "// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = require('./$.export');\n$export($export.S, 'Object', {setPrototypeOf: require('./$.set-proto').set});",
    "'use strict';\n// 19.1.3.6 Object.prototype.toString()\nvar classof = require('./$.classof')\n  , test    = {};\ntest[require('./$.wks')('toStringTag')] = 'z';\nif(test + '' != '[object z]'){\n  require('./$.redefine')(Object.prototype, 'toString', function toString(){\n    return '[object ' + classof(this) + ']';\n  }, true);\n}",
    "'use strict';\nvar $          = require('./$')\n  , LIBRARY    = require('./$.library')\n  , global     = require('./$.global')\n  , ctx        = require('./$.ctx')\n  , classof    = require('./$.classof')\n  , $export    = require('./$.export')\n  , isObject   = require('./$.is-object')\n  , anObject   = require('./$.an-object')\n  , aFunction  = require('./$.a-function')\n  , strictNew  = require('./$.strict-new')\n  , forOf      = require('./$.for-of')\n  , setProto   = require('./$.set-proto').set\n  , same       = require('./$.same-value')\n  , SPECIES    = require('./$.wks')('species')\n  , speciesConstructor = require('./$.species-constructor')\n  , asap       = require('./$.microtask')\n  , PROMISE    = 'Promise'\n  , process    = global.process\n  , isNode     = classof(process) == 'process'\n  , P          = global[PROMISE]\n  , Wrapper;\n\nvar testResolve = function(sub){\n  var test = new P(function(){});\n  if(sub)test.constructor = Object;\n  return P.resolve(test) === test;\n};\n\nvar USE_NATIVE = function(){\n  var works = false;\n  function P2(x){\n    var self = new P(x);\n    setProto(self, P2.prototype);\n    return self;\n  }\n  try {\n    works = P && P.resolve && testResolve();\n    setProto(P2, P);\n    P2.prototype = $.create(P.prototype, {constructor: {value: P2}});\n    // actual Firefox has broken subclass support, test that\n    if(!(P2.resolve(5).then(function(){}) instanceof P2)){\n      works = false;\n    }\n    // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162\n    if(works && require('./$.descriptors')){\n      var thenableThenGotten = false;\n      P.resolve($.setDesc({}, 'then', {\n        get: function(){ thenableThenGotten = true; }\n      }));\n      works = thenableThenGotten;\n    }\n  } catch(e){ works = false; }\n  return works;\n}();\n\n// helpers\nvar sameConstructor = function(a, b){\n  // library wrapper special case\n  if(LIBRARY && a === P && b === Wrapper)return true;\n  return same(a, b);\n};\nvar getConstructor = function(C){\n  var S = anObject(C)[SPECIES];\n  return S != undefined ? S : C;\n};\nvar isThenable = function(it){\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar PromiseCapability = function(C){\n  var resolve, reject;\n  this.promise = new C(function($$resolve, $$reject){\n    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject  = $$reject;\n  });\n  this.resolve = aFunction(resolve),\n  this.reject  = aFunction(reject)\n};\nvar perform = function(exec){\n  try {\n    exec();\n  } catch(e){\n    return {error: e};\n  }\n};\nvar notify = function(record, isReject){\n  if(record.n)return;\n  record.n = true;\n  var chain = record.c;\n  asap(function(){\n    var value = record.v\n      , ok    = record.s == 1\n      , i     = 0;\n    var run = function(reaction){\n      var handler = ok ? reaction.ok : reaction.fail\n        , resolve = reaction.resolve\n        , reject  = reaction.reject\n        , result, then;\n      try {\n        if(handler){\n          if(!ok)record.h = true;\n          result = handler === true ? value : handler(value);\n          if(result === reaction.promise){\n            reject(TypeError('Promise-chain cycle'));\n          } else if(then = isThenable(result)){\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch(e){\n        reject(e);\n      }\n    };\n    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach\n    chain.length = 0;\n    record.n = false;\n    if(isReject)setTimeout(function(){\n      var promise = record.p\n        , handler, console;\n      if(isUnhandled(promise)){\n        if(isNode){\n          process.emit('unhandledRejection', value, promise);\n        } else if(handler = global.onunhandledrejection){\n          handler({promise: promise, reason: value});\n        } else if((console = global.console) && console.error){\n          console.error('Unhandled promise rejection', value);\n        }\n      } record.a = undefined;\n    }, 1);\n  });\n};\nvar isUnhandled = function(promise){\n  var record = promise._d\n    , chain  = record.a || record.c\n    , i      = 0\n    , reaction;\n  if(record.h)return false;\n  while(chain.length > i){\n    reaction = chain[i++];\n    if(reaction.fail || !isUnhandled(reaction.promise))return false;\n  } return true;\n};\nvar $reject = function(value){\n  var record = this;\n  if(record.d)return;\n  record.d = true;\n  record = record.r || record; // unwrap\n  record.v = value;\n  record.s = 2;\n  record.a = record.c.slice();\n  notify(record, true);\n};\nvar $resolve = function(value){\n  var record = this\n    , then;\n  if(record.d)return;\n  record.d = true;\n  record = record.r || record; // unwrap\n  try {\n    if(record.p === value)throw TypeError(\"Promise can't be resolved itself\");\n    if(then = isThenable(value)){\n      asap(function(){\n        var wrapper = {r: record, d: false}; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch(e){\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      record.v = value;\n      record.s = 1;\n      notify(record, false);\n    }\n  } catch(e){\n    $reject.call({r: record, d: false}, e); // wrap\n  }\n};\n\n// constructor polyfill\nif(!USE_NATIVE){\n  // 25.4.3.1 Promise(executor)\n  P = function Promise(executor){\n    aFunction(executor);\n    var record = this._d = {\n      p: strictNew(this, P, PROMISE),         // <- promise\n      c: [],                                  // <- awaiting reactions\n      a: undefined,                           // <- checked in isUnhandled reactions\n      s: 0,                                   // <- state\n      d: false,                               // <- done\n      v: undefined,                           // <- value\n      h: false,                               // <- handled rejection\n      n: false                                // <- notify\n    };\n    try {\n      executor(ctx($resolve, record, 1), ctx($reject, record, 1));\n    } catch(err){\n      $reject.call(record, err);\n    }\n  };\n  require('./$.redefine-all')(P.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected){\n      var reaction = new PromiseCapability(speciesConstructor(this, P))\n        , promise  = reaction.promise\n        , record   = this._d;\n      reaction.ok   = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      record.c.push(reaction);\n      if(record.a)record.a.push(reaction);\n      if(record.s)notify(record, false);\n      return promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function(onRejected){\n      return this.then(undefined, onRejected);\n    }\n  });\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});\nrequire('./$.set-to-string-tag')(P, PROMISE);\nrequire('./$.set-species')(PROMISE);\nWrapper = require('./$.core')[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r){\n    var capability = new PromiseCapability(this)\n      , $$reject   = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x){\n    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n    if(x instanceof P && sameConstructor(x.constructor, this))return x;\n    var capability = new PromiseCapability(this)\n      , $$resolve  = capability.resolve;\n    $$resolve(x);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && require('./$.iter-detect')(function(iter){\n  P.all(iter)['catch'](function(){});\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable){\n    var C          = getConstructor(this)\n      , capability = new PromiseCapability(C)\n      , resolve    = capability.resolve\n      , reject     = capability.reject\n      , values     = [];\n    var abrupt = perform(function(){\n      forOf(iterable, false, values.push, values);\n      var remaining = values.length\n        , results   = Array(remaining);\n      if(remaining)$.each.call(values, function(promise, index){\n        var alreadyCalled = false;\n        C.resolve(promise).then(function(value){\n          if(alreadyCalled)return;\n          alreadyCalled = true;\n          results[index] = value;\n          --remaining || resolve(results);\n        }, reject);\n      });\n      else resolve(results);\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable){\n    var C          = getConstructor(this)\n      , capability = new PromiseCapability(C)\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      forOf(iterable, false, function(promise){\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  }\n});",
    "// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)\nvar $export = require('./$.export')\n  , _apply  = Function.apply;\n\n$export($export.S, 'Reflect', {\n  apply: function apply(target, thisArgument, argumentsList){\n    return _apply.call(target, thisArgument, argumentsList);\n  }\n});",
    "// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])\nvar $         = require('./$')\n  , $export   = require('./$.export')\n  , aFunction = require('./$.a-function')\n  , anObject  = require('./$.an-object')\n  , isObject  = require('./$.is-object')\n  , bind      = Function.bind || require('./$.core').Function.prototype.bind;\n\n// MS Edge supports only 2 arguments\n// FF Nightly sets third argument as `new.target`, but does not create `this` from it\n$export($export.S + $export.F * require('./$.fails')(function(){\n  function F(){}\n  return !(Reflect.construct(function(){}, [], F) instanceof F);\n}), 'Reflect', {\n  construct: function construct(Target, args /*, newTarget*/){\n    aFunction(Target);\n    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);\n    if(Target == newTarget){\n      // w/o altered newTarget, optimization for 0-4 arguments\n      if(args != undefined)switch(anObject(args).length){\n        case 0: return new Target;\n        case 1: return new Target(args[0]);\n        case 2: return new Target(args[0], args[1]);\n        case 3: return new Target(args[0], args[1], args[2]);\n        case 4: return new Target(args[0], args[1], args[2], args[3]);\n      }\n      // w/o altered newTarget, lot of arguments case\n      var $args = [null];\n      $args.push.apply($args, args);\n      return new (bind.apply(Target, $args));\n    }\n    // with altered newTarget, not support built-in constructors\n    var proto    = newTarget.prototype\n      , instance = $.create(isObject(proto) ? proto : Object.prototype)\n      , result   = Function.apply.call(Target, instance, args);\n    return isObject(result) ? result : instance;\n  }\n});",
    "// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)\nvar $        = require('./$')\n  , $export  = require('./$.export')\n  , anObject = require('./$.an-object');\n\n// MS Edge has broken Reflect.defineProperty - throwing instead of returning false\n$export($export.S + $export.F * require('./$.fails')(function(){\n  Reflect.defineProperty($.setDesc({}, 1, {value: 1}), 1, {value: 2});\n}), 'Reflect', {\n  defineProperty: function defineProperty(target, propertyKey, attributes){\n    anObject(target);\n    try {\n      $.setDesc(target, propertyKey, attributes);\n      return true;\n    } catch(e){\n      return false;\n    }\n  }\n});",
    "// 26.1.4 Reflect.deleteProperty(target, propertyKey)\nvar $export  = require('./$.export')\n  , getDesc  = require('./$').getDesc\n  , anObject = require('./$.an-object');\n\n$export($export.S, 'Reflect', {\n  deleteProperty: function deleteProperty(target, propertyKey){\n    var desc = getDesc(anObject(target), propertyKey);\n    return desc && !desc.configurable ? false : delete target[propertyKey];\n  }\n});",
    "'use strict';\n// 26.1.5 Reflect.enumerate(target)\nvar $export  = require('./$.export')\n  , anObject = require('./$.an-object');\nvar Enumerate = function(iterated){\n  this._t = anObject(iterated); // target\n  this._i = 0;                  // next index\n  var keys = this._k = []       // keys\n    , key;\n  for(key in iterated)keys.push(key);\n};\nrequire('./$.iter-create')(Enumerate, 'Object', function(){\n  var that = this\n    , keys = that._k\n    , key;\n  do {\n    if(that._i >= keys.length)return {value: undefined, done: true};\n  } while(!((key = keys[that._i++]) in that._t));\n  return {value: key, done: false};\n});\n\n$export($export.S, 'Reflect', {\n  enumerate: function enumerate(target){\n    return new Enumerate(target);\n  }\n});",
    "// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)\nvar $        = require('./$')\n  , $export  = require('./$.export')\n  , anObject = require('./$.an-object');\n\n$export($export.S, 'Reflect', {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){\n    return $.getDesc(anObject(target), propertyKey);\n  }\n});",
    "// 26.1.8 Reflect.getPrototypeOf(target)\nvar $export  = require('./$.export')\n  , getProto = require('./$').getProto\n  , anObject = require('./$.an-object');\n\n$export($export.S, 'Reflect', {\n  getPrototypeOf: function getPrototypeOf(target){\n    return getProto(anObject(target));\n  }\n});",
    "// 26.1.6 Reflect.get(target, propertyKey [, receiver])\nvar $        = require('./$')\n  , has      = require('./$.has')\n  , $export  = require('./$.export')\n  , isObject = require('./$.is-object')\n  , anObject = require('./$.an-object');\n\nfunction get(target, propertyKey/*, receiver*/){\n  var receiver = arguments.length < 3 ? target : arguments[2]\n    , desc, proto;\n  if(anObject(target) === receiver)return target[propertyKey];\n  if(desc = $.getDesc(target, propertyKey))return has(desc, 'value')\n    ? desc.value\n    : desc.get !== undefined\n      ? desc.get.call(receiver)\n      : undefined;\n  if(isObject(proto = $.getProto(target)))return get(proto, propertyKey, receiver);\n}\n\n$export($export.S, 'Reflect', {get: get});",
    "// 26.1.9 Reflect.has(target, propertyKey)\nvar $export = require('./$.export');\n\n$export($export.S, 'Reflect', {\n  has: function has(target, propertyKey){\n    return propertyKey in target;\n  }\n});",
    "// 26.1.10 Reflect.isExtensible(target)\nvar $export       = require('./$.export')\n  , anObject      = require('./$.an-object')\n  , $isExtensible = Object.isExtensible;\n\n$export($export.S, 'Reflect', {\n  isExtensible: function isExtensible(target){\n    anObject(target);\n    return $isExtensible ? $isExtensible(target) : true;\n  }\n});",
    "// 26.1.11 Reflect.ownKeys(target)\nvar $export = require('./$.export');\n\n$export($export.S, 'Reflect', {ownKeys: require('./$.own-keys')});",
    "// 26.1.12 Reflect.preventExtensions(target)\nvar $export            = require('./$.export')\n  , anObject           = require('./$.an-object')\n  , $preventExtensions = Object.preventExtensions;\n\n$export($export.S, 'Reflect', {\n  preventExtensions: function preventExtensions(target){\n    anObject(target);\n    try {\n      if($preventExtensions)$preventExtensions(target);\n      return true;\n    } catch(e){\n      return false;\n    }\n  }\n});",
    "// 26.1.14 Reflect.setPrototypeOf(target, proto)\nvar $export  = require('./$.export')\n  , setProto = require('./$.set-proto');\n\nif(setProto)$export($export.S, 'Reflect', {\n  setPrototypeOf: function setPrototypeOf(target, proto){\n    setProto.check(target, proto);\n    try {\n      setProto.set(target, proto);\n      return true;\n    } catch(e){\n      return false;\n    }\n  }\n});",
    "// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])\nvar $          = require('./$')\n  , has        = require('./$.has')\n  , $export    = require('./$.export')\n  , createDesc = require('./$.property-desc')\n  , anObject   = require('./$.an-object')\n  , isObject   = require('./$.is-object');\n\nfunction set(target, propertyKey, V/*, receiver*/){\n  var receiver = arguments.length < 4 ? target : arguments[3]\n    , ownDesc  = $.getDesc(anObject(target), propertyKey)\n    , existingDescriptor, proto;\n  if(!ownDesc){\n    if(isObject(proto = $.getProto(target))){\n      return set(proto, propertyKey, V, receiver);\n    }\n    ownDesc = createDesc(0);\n  }\n  if(has(ownDesc, 'value')){\n    if(ownDesc.writable === false || !isObject(receiver))return false;\n    existingDescriptor = $.getDesc(receiver, propertyKey) || createDesc(0);\n    existingDescriptor.value = V;\n    $.setDesc(receiver, propertyKey, existingDescriptor);\n    return true;\n  }\n  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);\n}\n\n$export($export.S, 'Reflect', {set: set});",
    "var $        = require('./$')\n  , global   = require('./$.global')\n  , isRegExp = require('./$.is-regexp')\n  , $flags   = require('./$.flags')\n  , $RegExp  = global.RegExp\n  , Base     = $RegExp\n  , proto    = $RegExp.prototype\n  , re1      = /a/g\n  , re2      = /a/g\n  // \"new\" creates a new object, old webkit buggy here\n  , CORRECT_NEW = new $RegExp(re1) !== re1;\n\nif(require('./$.descriptors') && (!CORRECT_NEW || require('./$.fails')(function(){\n  re2[require('./$.wks')('match')] = false;\n  // RegExp constructor can alter flags and IsRegExp works correct with @@match\n  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';\n}))){\n  $RegExp = function RegExp(p, f){\n    var piRE = isRegExp(p)\n      , fiU  = f === undefined;\n    return !(this instanceof $RegExp) && piRE && p.constructor === $RegExp && fiU ? p\n      : CORRECT_NEW\n        ? new Base(piRE && !fiU ? p.source : p, f)\n        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f);\n  };\n  $.each.call($.getNames(Base), function(key){\n    key in $RegExp || $.setDesc($RegExp, key, {\n      configurable: true,\n      get: function(){ return Base[key]; },\n      set: function(it){ Base[key] = it; }\n    });\n  });\n  proto.constructor = $RegExp;\n  $RegExp.prototype = proto;\n  require('./$.redefine')(global, 'RegExp', $RegExp);\n}\n\nrequire('./$.set-species')('RegExp');",
    "// 21.2.5.3 get RegExp.prototype.flags()\nvar $ = require('./$');\nif(require('./$.descriptors') && /./g.flags != 'g')$.setDesc(RegExp.prototype, 'flags', {\n  configurable: true,\n  get: require('./$.flags')\n});",
    "// @@match logic\nrequire('./$.fix-re-wks')('match', 1, function(defined, MATCH){\n  // 21.1.3.11 String.prototype.match(regexp)\n  return function match(regexp){\n    'use strict';\n    var O  = defined(this)\n      , fn = regexp == undefined ? undefined : regexp[MATCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n  };\n});",
    "// @@replace logic\nrequire('./$.fix-re-wks')('replace', 2, function(defined, REPLACE, $replace){\n  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)\n  return function replace(searchValue, replaceValue){\n    'use strict';\n    var O  = defined(this)\n      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];\n    return fn !== undefined\n      ? fn.call(searchValue, O, replaceValue)\n      : $replace.call(String(O), searchValue, replaceValue);\n  };\n});",
    "// @@search logic\nrequire('./$.fix-re-wks')('search', 1, function(defined, SEARCH){\n  // 21.1.3.15 String.prototype.search(regexp)\n  return function search(regexp){\n    'use strict';\n    var O  = defined(this)\n      , fn = regexp == undefined ? undefined : regexp[SEARCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));\n  };\n});",
    "// @@split logic\nrequire('./$.fix-re-wks')('split', 2, function(defined, SPLIT, $split){\n  // 21.1.3.17 String.prototype.split(separator, limit)\n  return function split(separator, limit){\n    'use strict';\n    var O  = defined(this)\n      , fn = separator == undefined ? undefined : separator[SPLIT];\n    return fn !== undefined\n      ? fn.call(separator, O, limit)\n      : $split.call(String(O), separator, limit);\n  };\n});",
    "'use strict';\nvar strong = require('./$.collection-strong');\n\n// 23.2 Set Objects\nrequire('./$.collection')('Set', function(get){\n  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.2.3.1 Set.prototype.add(value)\n  add: function add(value){\n    return strong.def(this, value = value === 0 ? 0 : value, value);\n  }\n}, strong);",
    "'use strict';\nvar $export = require('./$.export')\n  , $at     = require('./$.string-at')(false);\n$export($export.P, 'String', {\n  // 21.1.3.3 String.prototype.codePointAt(pos)\n  codePointAt: function codePointAt(pos){\n    return $at(this, pos);\n  }\n});",
    "// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])\n'use strict';\nvar $export   = require('./$.export')\n  , toLength  = require('./$.to-length')\n  , context   = require('./$.string-context')\n  , ENDS_WITH = 'endsWith'\n  , $endsWith = ''[ENDS_WITH];\n\n$export($export.P + $export.F * require('./$.fails-is-regexp')(ENDS_WITH), 'String', {\n  endsWith: function endsWith(searchString /*, endPosition = @length */){\n    var that = context(this, searchString, ENDS_WITH)\n      , $$   = arguments\n      , endPosition = $$.length > 1 ? $$[1] : undefined\n      , len    = toLength(that.length)\n      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)\n      , search = String(searchString);\n    return $endsWith\n      ? $endsWith.call(that, search, end)\n      : that.slice(end - search.length, end) === search;\n  }\n});",
    "var $export        = require('./$.export')\n  , toIndex        = require('./$.to-index')\n  , fromCharCode   = String.fromCharCode\n  , $fromCodePoint = String.fromCodePoint;\n\n// length should be 1, old FF problem\n$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {\n  // 21.1.2.2 String.fromCodePoint(...codePoints)\n  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars\n    var res   = []\n      , $$    = arguments\n      , $$len = $$.length\n      , i     = 0\n      , code;\n    while($$len > i){\n      code = +$$[i++];\n      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');\n      res.push(code < 0x10000\n        ? fromCharCode(code)\n        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\n      );\n    } return res.join('');\n  }\n});",
    "// 21.1.3.7 String.prototype.includes(searchString, position = 0)\n'use strict';\nvar $export  = require('./$.export')\n  , context  = require('./$.string-context')\n  , INCLUDES = 'includes';\n\n$export($export.P + $export.F * require('./$.fails-is-regexp')(INCLUDES), 'String', {\n  includes: function includes(searchString /*, position = 0 */){\n    return !!~context(this, searchString, INCLUDES)\n      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});",
    "'use strict';\nvar $at  = require('./$.string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./$.iter-define')(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});",
    "var $export   = require('./$.export')\n  , toIObject = require('./$.to-iobject')\n  , toLength  = require('./$.to-length');\n\n$export($export.S, 'String', {\n  // 21.1.2.4 String.raw(callSite, ...substitutions)\n  raw: function raw(callSite){\n    var tpl   = toIObject(callSite.raw)\n      , len   = toLength(tpl.length)\n      , $$    = arguments\n      , $$len = $$.length\n      , res   = []\n      , i     = 0;\n    while(len > i){\n      res.push(String(tpl[i++]));\n      if(i < $$len)res.push(String($$[i]));\n    } return res.join('');\n  }\n});",
    "var $export = require('./$.export');\n\n$export($export.P, 'String', {\n  // 21.1.3.13 String.prototype.repeat(count)\n  repeat: require('./$.string-repeat')\n});",
    "// 21.1.3.18 String.prototype.startsWith(searchString [, position ])\n'use strict';\nvar $export     = require('./$.export')\n  , toLength    = require('./$.to-length')\n  , context     = require('./$.string-context')\n  , STARTS_WITH = 'startsWith'\n  , $startsWith = ''[STARTS_WITH];\n\n$export($export.P + $export.F * require('./$.fails-is-regexp')(STARTS_WITH), 'String', {\n  startsWith: function startsWith(searchString /*, position = 0 */){\n    var that   = context(this, searchString, STARTS_WITH)\n      , $$     = arguments\n      , index  = toLength(Math.min($$.length > 1 ? $$[1] : undefined, that.length))\n      , search = String(searchString);\n    return $startsWith\n      ? $startsWith.call(that, search, index)\n      : that.slice(index, index + search.length) === search;\n  }\n});",
    "'use strict';\n// 21.1.3.25 String.prototype.trim()\nrequire('./$.string-trim')('trim', function($trim){\n  return function trim(){\n    return $trim(this, 3);\n  };\n});",
    "'use strict';\n// ECMAScript 6 symbols shim\nvar $              = require('./$')\n  , global         = require('./$.global')\n  , has            = require('./$.has')\n  , DESCRIPTORS    = require('./$.descriptors')\n  , $export        = require('./$.export')\n  , redefine       = require('./$.redefine')\n  , $fails         = require('./$.fails')\n  , shared         = require('./$.shared')\n  , setToStringTag = require('./$.set-to-string-tag')\n  , uid            = require('./$.uid')\n  , wks            = require('./$.wks')\n  , keyOf          = require('./$.keyof')\n  , $names         = require('./$.get-names')\n  , enumKeys       = require('./$.enum-keys')\n  , isArray        = require('./$.is-array')\n  , anObject       = require('./$.an-object')\n  , toIObject      = require('./$.to-iobject')\n  , createDesc     = require('./$.property-desc')\n  , getDesc        = $.getDesc\n  , setDesc        = $.setDesc\n  , _create        = $.create\n  , getNames       = $names.get\n  , $Symbol        = global.Symbol\n  , $JSON          = global.JSON\n  , _stringify     = $JSON && $JSON.stringify\n  , setter         = false\n  , HIDDEN         = wks('_hidden')\n  , isEnum         = $.isEnum\n  , SymbolRegistry = shared('symbol-registry')\n  , AllSymbols     = shared('symbols')\n  , useNative      = typeof $Symbol == 'function'\n  , ObjectProto    = Object.prototype;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n  return _create(setDesc({}, 'a', {\n    get: function(){ return setDesc(this, 'a', {value: 7}).a; }\n  })).a != 7;\n}) ? function(it, key, D){\n  var protoDesc = getDesc(ObjectProto, key);\n  if(protoDesc)delete ObjectProto[key];\n  setDesc(it, key, D);\n  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);\n} : setDesc;\n\nvar wrap = function(tag){\n  var sym = AllSymbols[tag] = _create($Symbol.prototype);\n  sym._k = tag;\n  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {\n    configurable: true,\n    set: function(value){\n      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    }\n  });\n  return sym;\n};\n\nvar isSymbol = function(it){\n  return typeof it == 'symbol';\n};\n\nvar $defineProperty = function defineProperty(it, key, D){\n  if(D && has(AllSymbols, key)){\n    if(!D.enumerable){\n      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n      D = _create(D, {enumerable: createDesc(0, false)});\n    } return setSymbolDesc(it, key, D);\n  } return setDesc(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P){\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P))\n    , i    = 0\n    , l = keys.length\n    , key;\n  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P){\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n  var E = isEnum.call(this, key);\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]\n    ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n  var D = getDesc(it = toIObject(it), key);\n  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n  var names  = getNames(toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);\n  return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n  var names  = getNames(toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);\n  return result;\n};\nvar $stringify = function stringify(it){\n  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n  var args = [it]\n    , i    = 1\n    , $$   = arguments\n    , replacer, $replacer;\n  while($$.length > i)args.push($$[i++]);\n  replacer = args[1];\n  if(typeof replacer == 'function')$replacer = replacer;\n  if($replacer || !isArray(replacer))replacer = function(key, value){\n    if($replacer)value = $replacer.call(this, key, value);\n    if(!isSymbol(value))return value;\n  };\n  args[1] = replacer;\n  return _stringify.apply($JSON, args);\n};\nvar buggyJSON = $fails(function(){\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n});\n\n// 19.4.1.1 Symbol([description])\nif(!useNative){\n  $Symbol = function Symbol(){\n    if(isSymbol(this))throw TypeError('Symbol is not a constructor');\n    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));\n  };\n  redefine($Symbol.prototype, 'toString', function toString(){\n    return this._k;\n  });\n\n  isSymbol = function(it){\n    return it instanceof $Symbol;\n  };\n\n  $.create     = $create;\n  $.isEnum     = $propertyIsEnumerable;\n  $.getDesc    = $getOwnPropertyDescriptor;\n  $.setDesc    = $defineProperty;\n  $.setDescs   = $defineProperties;\n  $.getNames   = $names.get = $getOwnPropertyNames;\n  $.getSymbols = $getOwnPropertySymbols;\n\n  if(DESCRIPTORS && !require('./$.library')){\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n}\n\nvar symbolStatics = {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function(key){\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(key){\n    return keyOf(SymbolRegistry, key);\n  },\n  useSetter: function(){ setter = true; },\n  useSimple: function(){ setter = false; }\n};\n// 19.4.2.2 Symbol.hasInstance\n// 19.4.2.3 Symbol.isConcatSpreadable\n// 19.4.2.4 Symbol.iterator\n// 19.4.2.6 Symbol.match\n// 19.4.2.8 Symbol.replace\n// 19.4.2.9 Symbol.search\n// 19.4.2.10 Symbol.species\n// 19.4.2.11 Symbol.split\n// 19.4.2.12 Symbol.toPrimitive\n// 19.4.2.13 Symbol.toStringTag\n// 19.4.2.14 Symbol.unscopables\n$.each.call((\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +\n  'species,split,toPrimitive,toStringTag,unscopables'\n).split(','), function(it){\n  var sym = wks(it);\n  symbolStatics[it] = useNative ? sym : wrap(sym);\n});\n\nsetter = true;\n\n$export($export.G + $export.W, {Symbol: $Symbol});\n\n$export($export.S, 'Symbol', symbolStatics);\n\n$export($export.S + $export.F * !useNative, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});\n\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);",
    "'use strict';\nvar $            = require('./$')\n  , redefine     = require('./$.redefine')\n  , weak         = require('./$.collection-weak')\n  , isObject     = require('./$.is-object')\n  , has          = require('./$.has')\n  , frozenStore  = weak.frozenStore\n  , WEAK         = weak.WEAK\n  , isExtensible = Object.isExtensible || isObject\n  , tmp          = {};\n\n// 23.3 WeakMap Objects\nvar $WeakMap = require('./$.collection')('WeakMap', function(get){\n  return function WeakMap(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.3.3.3 WeakMap.prototype.get(key)\n  get: function get(key){\n    if(isObject(key)){\n      if(!isExtensible(key))return frozenStore(this).get(key);\n      if(has(key, WEAK))return key[WEAK][this._i];\n    }\n  },\n  // 23.3.3.5 WeakMap.prototype.set(key, value)\n  set: function set(key, value){\n    return weak.def(this, key, value);\n  }\n}, weak, true, true);\n\n// IE11 WeakMap frozen keys fix\nif(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){\n  $.each.call(['delete', 'has', 'get', 'set'], function(key){\n    var proto  = $WeakMap.prototype\n      , method = proto[key];\n    redefine(proto, key, function(a, b){\n      // store frozen objects on leaky map\n      if(isObject(a) && !isExtensible(a)){\n        var result = frozenStore(this)[key](a, b);\n        return key == 'set' ? this : result;\n      // store all the rest on native weakmap\n      } return method.call(this, a, b);\n    });\n  });\n}",
    "'use strict';\nvar weak = require('./$.collection-weak');\n\n// 23.4 WeakSet Objects\nrequire('./$.collection')('WeakSet', function(get){\n  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.4.3.1 WeakSet.prototype.add(value)\n  add: function add(value){\n    return weak.def(this, value, true);\n  }\n}, weak, false, true);",
    "'use strict';\nvar $export   = require('./$.export')\n  , $includes = require('./$.array-includes')(true);\n\n$export($export.P, 'Array', {\n  // https://github.com/domenic/Array.prototype.includes\n  includes: function includes(el /*, fromIndex = 0 */){\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nrequire('./$.add-to-unscopables')('includes');",
    "// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar $export  = require('./$.export');\n\n$export($export.P, 'Map', {toJSON: require('./$.collection-to-json')('Map')});",
    "// http://goo.gl/XkBrjD\nvar $export  = require('./$.export')\n  , $entries = require('./$.object-to-array')(true);\n\n$export($export.S, 'Object', {\n  entries: function entries(it){\n    return $entries(it);\n  }\n});",
    "// https://gist.github.com/WebReflection/9353781\nvar $          = require('./$')\n  , $export    = require('./$.export')\n  , ownKeys    = require('./$.own-keys')\n  , toIObject  = require('./$.to-iobject')\n  , createDesc = require('./$.property-desc');\n\n$export($export.S, 'Object', {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){\n    var O       = toIObject(object)\n      , setDesc = $.setDesc\n      , getDesc = $.getDesc\n      , keys    = ownKeys(O)\n      , result  = {}\n      , i       = 0\n      , key, D;\n    while(keys.length > i){\n      D = getDesc(O, key = keys[i++]);\n      if(key in result)setDesc(result, key, createDesc(0, D));\n      else result[key] = D;\n    } return result;\n  }\n});",
    "// http://goo.gl/XkBrjD\nvar $export = require('./$.export')\n  , $values = require('./$.object-to-array')(false);\n\n$export($export.S, 'Object', {\n  values: function values(it){\n    return $values(it);\n  }\n});",
    "// https://github.com/benjamingr/RexExp.escape\nvar $export = require('./$.export')\n  , $re     = require('./$.replacer')(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});\n",
    "// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar $export  = require('./$.export');\n\n$export($export.P, 'Set', {toJSON: require('./$.collection-to-json')('Set')});",
    "'use strict';\n// https://github.com/mathiasbynens/String.prototype.at\nvar $export = require('./$.export')\n  , $at     = require('./$.string-at')(true);\n\n$export($export.P, 'String', {\n  at: function at(pos){\n    return $at(this, pos);\n  }\n});",
    "'use strict';\nvar $export = require('./$.export')\n  , $pad    = require('./$.string-pad');\n\n$export($export.P, 'String', {\n  padLeft: function padLeft(maxLength /*, fillString = ' ' */){\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);\n  }\n});",
    "'use strict';\nvar $export = require('./$.export')\n  , $pad    = require('./$.string-pad');\n\n$export($export.P, 'String', {\n  padRight: function padRight(maxLength /*, fillString = ' ' */){\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);\n  }\n});",
    "'use strict';\n// https://github.com/sebmarkbage/ecmascript-string-left-right-trim\nrequire('./$.string-trim')('trimLeft', function($trim){\n  return function trimLeft(){\n    return $trim(this, 1);\n  };\n});",
    "'use strict';\n// https://github.com/sebmarkbage/ecmascript-string-left-right-trim\nrequire('./$.string-trim')('trimRight', function($trim){\n  return function trimRight(){\n    return $trim(this, 2);\n  };\n});",
    "// JavaScript 1.6 / Strawman array statics shim\nvar $       = require('./$')\n  , $export = require('./$.export')\n  , $ctx    = require('./$.ctx')\n  , $Array  = require('./$.core').Array || Array\n  , statics = {};\nvar setStatics = function(keys, length){\n  $.each.call(keys.split(','), function(key){\n    if(length == undefined && key in $Array)statics[key] = $Array[key];\n    else if(key in [])statics[key] = $ctx(Function.call, [][key], length);\n  });\n};\nsetStatics('pop,reverse,shift,keys,values,entries', 1);\nsetStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);\nsetStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +\n           'reduce,reduceRight,copyWithin,fill');\n$export($export.S, 'Array', statics);",
    "require('./es6.array.iterator');\nvar global      = require('./$.global')\n  , hide        = require('./$.hide')\n  , Iterators   = require('./$.iterators')\n  , ITERATOR    = require('./$.wks')('iterator')\n  , NL          = global.NodeList\n  , HTC         = global.HTMLCollection\n  , NLProto     = NL && NL.prototype\n  , HTCProto    = HTC && HTC.prototype\n  , ArrayValues = Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;\nif(NLProto && !NLProto[ITERATOR])hide(NLProto, ITERATOR, ArrayValues);\nif(HTCProto && !HTCProto[ITERATOR])hide(HTCProto, ITERATOR, ArrayValues);",
    "var $export = require('./$.export')\n  , $task   = require('./$.task');\n$export($export.G + $export.B, {\n  setImmediate:   $task.set,\n  clearImmediate: $task.clear\n});",
    "// ie9- setTimeout & setInterval additional parameters fix\nvar global     = require('./$.global')\n  , $export    = require('./$.export')\n  , invoke     = require('./$.invoke')\n  , partial    = require('./$.partial')\n  , navigator  = global.navigator\n  , MSIE       = !!navigator && /MSIE .\\./.test(navigator.userAgent); // <- dirty ie9- check\nvar wrap = function(set){\n  return MSIE ? function(fn, time /*, ...args */){\n    return set(invoke(\n      partial,\n      [].slice.call(arguments, 2),\n      typeof fn == 'function' ? fn : Function(fn)\n    ), time);\n  } : set;\n};\n$export($export.G + $export.B + $export.F * MSIE, {\n  setTimeout:  wrap(global.setTimeout),\n  setInterval: wrap(global.setInterval)\n});",
    "require('./modules/es5');\nrequire('./modules/es6.symbol');\nrequire('./modules/es6.object.assign');\nrequire('./modules/es6.object.is');\nrequire('./modules/es6.object.set-prototype-of');\nrequire('./modules/es6.object.to-string');\nrequire('./modules/es6.object.freeze');\nrequire('./modules/es6.object.seal');\nrequire('./modules/es6.object.prevent-extensions');\nrequire('./modules/es6.object.is-frozen');\nrequire('./modules/es6.object.is-sealed');\nrequire('./modules/es6.object.is-extensible');\nrequire('./modules/es6.object.get-own-property-descriptor');\nrequire('./modules/es6.object.get-prototype-of');\nrequire('./modules/es6.object.keys');\nrequire('./modules/es6.object.get-own-property-names');\nrequire('./modules/es6.function.name');\nrequire('./modules/es6.function.has-instance');\nrequire('./modules/es6.number.constructor');\nrequire('./modules/es6.number.epsilon');\nrequire('./modules/es6.number.is-finite');\nrequire('./modules/es6.number.is-integer');\nrequire('./modules/es6.number.is-nan');\nrequire('./modules/es6.number.is-safe-integer');\nrequire('./modules/es6.number.max-safe-integer');\nrequire('./modules/es6.number.min-safe-integer');\nrequire('./modules/es6.number.parse-float');\nrequire('./modules/es6.number.parse-int');\nrequire('./modules/es6.math.acosh');\nrequire('./modules/es6.math.asinh');\nrequire('./modules/es6.math.atanh');\nrequire('./modules/es6.math.cbrt');\nrequire('./modules/es6.math.clz32');\nrequire('./modules/es6.math.cosh');\nrequire('./modules/es6.math.expm1');\nrequire('./modules/es6.math.fround');\nrequire('./modules/es6.math.hypot');\nrequire('./modules/es6.math.imul');\nrequire('./modules/es6.math.log10');\nrequire('./modules/es6.math.log1p');\nrequire('./modules/es6.math.log2');\nrequire('./modules/es6.math.sign');\nrequire('./modules/es6.math.sinh');\nrequire('./modules/es6.math.tanh');\nrequire('./modules/es6.math.trunc');\nrequire('./modules/es6.string.from-code-point');\nrequire('./modules/es6.string.raw');\nrequire('./modules/es6.string.trim');\nrequire('./modules/es6.string.iterator');\nrequire('./modules/es6.string.code-point-at');\nrequire('./modules/es6.string.ends-with');\nrequire('./modules/es6.string.includes');\nrequire('./modules/es6.string.repeat');\nrequire('./modules/es6.string.starts-with');\nrequire('./modules/es6.array.from');\nrequire('./modules/es6.array.of');\nrequire('./modules/es6.array.iterator');\nrequire('./modules/es6.array.species');\nrequire('./modules/es6.array.copy-within');\nrequire('./modules/es6.array.fill');\nrequire('./modules/es6.array.find');\nrequire('./modules/es6.array.find-index');\nrequire('./modules/es6.regexp.constructor');\nrequire('./modules/es6.regexp.flags');\nrequire('./modules/es6.regexp.match');\nrequire('./modules/es6.regexp.replace');\nrequire('./modules/es6.regexp.search');\nrequire('./modules/es6.regexp.split');\nrequire('./modules/es6.promise');\nrequire('./modules/es6.map');\nrequire('./modules/es6.set');\nrequire('./modules/es6.weak-map');\nrequire('./modules/es6.weak-set');\nrequire('./modules/es6.reflect.apply');\nrequire('./modules/es6.reflect.construct');\nrequire('./modules/es6.reflect.define-property');\nrequire('./modules/es6.reflect.delete-property');\nrequire('./modules/es6.reflect.enumerate');\nrequire('./modules/es6.reflect.get');\nrequire('./modules/es6.reflect.get-own-property-descriptor');\nrequire('./modules/es6.reflect.get-prototype-of');\nrequire('./modules/es6.reflect.has');\nrequire('./modules/es6.reflect.is-extensible');\nrequire('./modules/es6.reflect.own-keys');\nrequire('./modules/es6.reflect.prevent-extensions');\nrequire('./modules/es6.reflect.set');\nrequire('./modules/es6.reflect.set-prototype-of');\nrequire('./modules/es7.array.includes');\nrequire('./modules/es7.string.at');\nrequire('./modules/es7.string.pad-left');\nrequire('./modules/es7.string.pad-right');\nrequire('./modules/es7.string.trim-left');\nrequire('./modules/es7.string.trim-right');\nrequire('./modules/es7.regexp.escape');\nrequire('./modules/es7.object.get-own-property-descriptors');\nrequire('./modules/es7.object.values');\nrequire('./modules/es7.object.entries');\nrequire('./modules/es7.map.to-json');\nrequire('./modules/es7.set.to-json');\nrequire('./modules/js.array.statics');\nrequire('./modules/web.timers');\nrequire('./modules/web.immediate');\nrequire('./modules/web.dom.iterable');\nmodule.exports = require('./modules/$.core');"
  ]
}